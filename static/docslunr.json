{"/zh/docs/":{"url":"zh/docs/","title":"文档","description":"","language":"zh","body":"欢迎使用 Choerodon 文档 Choerodon 猪齿鱼是一个开源企业服务平台，是基于 Kubernetes 的容器编排和管理能力，整合 DevOps 工具链、微服务和移动应用框架，来帮助企业实现敏捷化的应用交付和自动化的运营管理，并提供 IoT 、支付、数据、智能洞察、企业应用市场等业务组件，来帮助企业聚焦于业务，加速数字化转型。 Choerodon 提供一整套支撑 DevOps 最佳实践的工具链，从计划、编程、构建、测试、发布与运营等支撑敏捷管理；并且还提供了一套基于 Spring Cloud 微服务应用框架，以帮助企业更加快捷高效的进行微服务开发。Choerodon 文档将从Choerodon相关概念，DevOps 工具链 和 应用开发 等方面详细介绍 Choerodon 作为DevOps支撑平台的架构、安装、配置、部署，以及如何使用等，以及 Choerodon 微服务应用框架的开发、部署等。 了解和学习 Choerodon 的概念和安装 概念 01 - Choerodon是什么 02 - 系统架构 03 - 使用的开源组件 更多 04 - 开发区与运行区 05 - 组织层次 06 - 安全 折叠 安装与配置 01 - 概述 02 - 安装开发区 03 - 安装运行区 更多 04 - 安装其他组件 05 - 迁移 06 - .deploy.yml文件说明 07 - .gitlab-ci.yml文件说明 08 - Dockerfile文件说明--> 折叠 了解和学习 Choerodon 的 DevOps 工具链 Choerodon 提供一整套 DevOps 的最佳实践，从计划、编程、构建、测试、发布与运营等。 快速入门 01 - 开发一个微服务前端 02 - 开发一个微服务后端 03 - 开发一个Web应用 更多 04 - 开发一个移动应用 05 - 从用户故事到运营监控 折叠 功能说明 01 - 系统配置 02 - 敏捷管理 03 - 持续集成 更多 04 - 持续部署 05 - 洞察监控 折叠 了解和学习 Choerodon 的开发应用 Choerodon 微服务应用框架是基于多年企业应用服务的经验，面向微服务架构思想和分布式应用架构研发的分布式应用开发平台，以满足应用微服务化和混合云IT架构分布式应用的开发。 快速入门 01 - 开发一个微服务前端 02 - 开发一个微服务后端 开发手册 01 - 后端开发 02 - 前端开发 03 - 后端环境部署 04 - 前端项目部署 最佳实践 01 - 开发规范 02 - 命名规范 03 - 测试 "},"/zh/docs/concept/":{"url":"zh/docs/concept/","title":"概念","description":"","language":"zh","body":"概念 介绍Choerodon相关概念。Choerodon的用户可以通过此章节了解Choerodon的作用、系统架构、使用了哪些开源组件以及系统的组织层次和安全设计等，对Choerodon的有一个全貌的了解。 Choerodon 是什么 说明Choerodon的设计和开发的目的、特点，以及它能够解决的问题和给用户带来哪些价值等。 系统架构 描述Choerodon的微服务系统架构，以及一般性企业系统架构的演进历程。 使用的开源组件 描述Choerodon使用到的开源工具集或者产品。分为两部分，其一是微服务应用框架使用的开源工具集或者产品，其二是DevOps业务流程使用的工具集。 开发区与运行区 介绍说明Choerodon开发区和运行区的概念，涉及到的服务，以及对应的系统部署方式。 组织层次 介绍说明Choerodon采用全局、组织和项目三个层次来组织系统资源。 安全 描述说明Choerodon的认证体系和权限控制。 "},"/zh/docs/concept/choerodon-concept":{"url":"zh/docs/concept/choerodon-concept","title":"Choerodon 是什么?","description":"","language":"zh","body":"Choerodon 是什么？ 企业级数字化服务平台 Choerodon猪齿鱼是一个开源企业服务平台，是基于Kubernetes的容器编排和管理能力，整合DevOps工具链、微服务和移动应用框架，来帮助企业实现敏捷化的应用交付和自动化的运营管理，并提供IoT、支付、数据、智能洞察、企业应用市场等业务组件，来帮助企业聚焦于业务，加速数字化转型。 Choerodon使用Kubernetes来管理和部署服务。关于Kubernetes，请参考Kubernetes 概览。 同时，Choerodon使用Spring Cloud作为微服务分布式系统，并且Choerodon还使用Spring Boot进行了通用性模块的封装，例如组织管理、用户管理、权限管理等；前端使用React作为开发组件。关于Choerodon的开发请参考 Cloud Framework 开发。 有关Choerodon组件的详细概念信息，请参阅我们的其他概念指南。 为什么要使用 Choerodon ？ Choerodon解决了开发人员和运维人员面临的许多挑战。随着企业或者组织业务模式不断的互联网化，尤其是对于一些有软件研发能力的公司或者组织，如何有效的应对开发和运维之间的关系，提高IT部门的总体运作效率，以支撑业务的快速发展，已成为了我们面临的重大挑战。 同时，现代企业或者组织对于软件系统的需求，也在随着互联网和大数据等新技术的进步在悄然发生变化，尤其是在数字化转型的思潮中，企业或者组织要求： 零宕机 部署松耦合的组件，通过冗余来避免故障，零停机的情况下完成升级 极短反馈周期 经常发布代码，缩短反馈回路，降低风险 移动和多设备 充分利用移动设备，用户能够在多种设备使用，系统能够适应扩展的需求 设备互联 互联网连接的设备导致数据量剧增和要求“边缘”的计算能力，需要新的软件设计和实践 数据驱动 使用数据，通过更智能的应用向客户提供极致的体验和更高的价值 Choerodon可以有效的帮助企业或者组织提升IT效能。Choerodon采用DevOps的原则和流程来管理软件的开发和运维。Choerodon可以有效提高软件交付的质量（比如，提高可用性，提高变更成功率，减少故障，等等），加快产品推向市场（比如，缩短开发周期时间和更高的部署频率），并且提高组织的有效性（比如，将时间花在价值增加活动中，减少浪费，同时交付更多的价值至客户手中）。 Choerodon是将服务和应用构建在Kubernetes上，后端服务使用Spring Boot开发，前端使用React开发。Choerodon分为两类环境，即应用PaaS环境和产品PaaS环境，应用PaaS环境为主要软件开发区，包括应用构建、敏捷管理、开发管理和持续发布管理等核心功能；产品PaaS环境主要软件运行区，包括测试环境、用户集成测试环境、正式环境等，用户可以根据自身需求定义。 以下是对Choerodon关键特性说明： 应用构建 我们可以方便的通过Choerodon开发构建微服务、Web前端、移动、普通应用和Java库。 敏捷管理 Choerodon采用Scrum来管理需求和计划执行，包括用户故事地图，ISSUE管理，冲刺管理和电子看板。 开发管理 Choerodon使用gitlab管理代码，包括代码托管、分支管理（Gitflow分支模型），根据服务类型提供持续集成的流水线模板，开发人员也可以根据需要进行定制化修改，以及代码质量管理等。 持续发布管理 在应用PaaS环境，Choerodon通过Gitlab CI/CD产生软件应用的版本，例如2.0.3，Choerodon将2.0.3发布到生产PaaS环境，然后在生产PaaS环境部署应用版本，同时也可以进行灰度发布。 运营管理 Choerodon提供一整套完整的监控工具来监控PaaS平台，监控主要包含开发类指标、日志和微服务调用链三类信息。 "},"/zh/docs/concept/choerodon-development-deployment":{"url":"zh/docs/concept/choerodon-development-deployment","title":"开发区与运行区","description":"","language":"zh","body":"开发区与运行区 Choerodon 采用微服务架构融合多个开源组件实现 DevOps的开发相关功能，包括计划、编码、构建、测试、部署、运行、运维等，并且Choerodon是以Docker容器作为运行环境和使用Kubernetes作为容器编排和管理工具，在一个Kubernetes集群中运行DevOps流程的开发相关（计划、编码、构建、测试）微服务和开源工具，我们将此Kubernetes集群称作开发区；在一个Kubernetes集群中运行DevOps流程的运行相关（部署、运行、运维）微服务和开源工具，我们将此Kubernetes集群称作运行区。 关于开发区的安装，请参考开发区安装。 关于运行区的安装，请参考运行区安装。 部署 Choerodon 可以有两种不同的部署方式，用户可以选择单集群部署，将开发和运行相关服务部署到一个Kubernetes集群上，也可以将开发区和运行区的服务分别部署到不同的Kubernetes集群上。 一个Kubernetes集群如果仅部署开发区相关的服务，则可作为DevOps开发端使用，如果仅部署运行区相关服务，则可作为DevOps运行端使用，如果既部署开发区相关服务和组件，又部署运行区相关服务和组件，则可以为一个完整的PaaS平台。 单集群部署 单集群部署是将开发区相关的服务和运行区相关的服务部署到一个Kubernetes集群中。用户的开发和应用的部署和运行全部在一个Kubernetes集群中。 多集群部署 多集群部署是将开发区相关的服务和运行区相关的服务分别部署到多个Kubernetes集群中，开发区和运行区集群之间通过http通信。我们可以把多个运行区看做是多套环境，例如测试环境、正式环境等。 开发区相关服务 Choerodon 开发区各服务版本信息如下： 服务名 服务组 服务代码 版本号 K8S消息收集 com.choerodon.devops k8s-informer V0.1.1 Gitlab服务 com.choerodon.devops choerodon-gitlab-service 1.1.0 K8S服务 com.choerodon.devops devops-kubernetes-service 1.1.0 文件服务 com.choerodon.devops choerodon-file-service 1.1.0 开发服务 com.choerodon.devops choerodon-devops-service 1.1.0 部署服务 com.choerodon.devops devops-deploy-service 1.1.6 SonarQube服务 com.choerodon.insight data-sonar-service 1.0.1 数据整合服务 com.choerodon.insight data-intergration-service 1.0.0 数据提供服务 com.choerodon.insight data-provide-service 1.0.1 数据操作服务 com.choerodon.insight data-operation-service 1.0.0 看板服务 com.choerodon.kanban choerodon-kanban-service 1.1.0 移动服务 com.choerodon.mobile mobile-cloud-service 1.0.0 开发前端 com.choerodon.devops devops-front 1.1.3 部署前端 com.choerodon.devops deploy-front 1.1.5 洞察前端 com.choerodon.insight analysis-insight-front 1.0.0 监控前端 com.choerodon.insight monitor-front 1.0.0 看板前端 com.choerodon.kanban choerodon-kanban-front 1.1.0 移动前端 com.choerodon.mobile mobile-front 1.0.0 运行区相关服务 Choerodon 运行区各服务版本信息如下： 服务名 服务组 服务代码 版本号 K8S消息收集 com.choerodon.devops k8s-informer V0.1.1 K8S服务 com.choerodon.devops devops-kubernetes-service 1.1.0 文件服务 com.choerodon.devops choerodon-file-service 1.1.0 部署服务 com.choerodon.devops devops-deploy-service 1.1.6 数据整合服务 com.choerodon.insight data-intergration-service 1.0.0 数据提供服务 com.choerodon.insight data-provide-service 1.0.1 数据操作服务 com.choerodon.insight data-operation-service 1.0.0 移动服务 com.choerodon.mobile mobile-cloud-service 1.0.0 部署前端 com.choerodon.devops deploy-front 1.1.5 监控前端 com.choerodon.insight monitor-front 1.0.0 移动前端 com.choerodon.mobile mobile-front 1.0.0 "},"/zh/docs/concept/choerodon-opensource-component":{"url":"zh/docs/concept/choerodon-opensource-component","title":"使用的开源组件","description":"","language":"zh","body":"Choerodon 使用的开源组件 Choerodon 完全基于开源产品打造。我们从两个方面来叙述Choerodon使用的开源产品或者工具。其一，Choerodon的本身是使用Spring Cloud作为微服务架构，运行在Docker上，同时使用Kubernetes作为容器管理和编排工具；其二，它以DevOps为理论指导，实现了敏捷的最佳实践。 以下我们从两个方面来阐述Choerodon使用了哪些开源产品和工具： 微服务应用框架使用的开源工具集 Choerodon 的微服务应用系统架构由五个不同的层组成，从应用程序代码到所需运行平台和连接服务。这些应用程序和服务通过一致的调度和编排和监督进行管理，所有这些应用程序和服务都运行在K8s提供的运行环境上。 应用前端 Choerodon前端使用react和mobx。 核心组件有： React。React 是一个用于构建用户界面的 JAVASCRIPT 库。 Mobo。Mobx是一个功能强大，上手非常容易的状态管理工具。 微服务后端 Choerodon的微服务后端采用Spring Cloud作为微服务框架，使用Spring Boot作为开发脚手架。 核心组件有： Spring Cloud。Spring Cloud是一个集成了众多开源的框架，利用Spring Boot的开发便利性实现了服务治理、服务注册与发现、负载均衡、数据监控，REST API发布方式等，基本囊括了分布式框架所需要的所有功能。是一套易开放、易部署、易维护的分布式开发工具包。 Spring Boot。Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 消息中间件 Choerodon使用Kafka作为消息中间件。 核心组件有： Kafka。Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 数据服务层 Choerodon采用MySQL作为关系型数据存储库，Redis作为缓存库。 核心组件有： MySQL。Mysql是最流行的开源关系型数据库管理系统。 Redis。Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API 运行环境 Choerodon运行在Docker上。 核心组件有： Docker。Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器编排 Choerodon使用Kubernetes作为容器编排和管理工具。 核心组件有： Kubernetes。Kubernetes是一个开源平台 用于跨主机群集自动部署 扩展和操作应用程序容器 提供以容器为中心的基础架构。 DevOps平台使用的开源工具集 自动化是整个DevOps实现的核心，对应生命周期的每个阶段都可以选择开源工具框架。将DevOps工具集环境作为整体服务交付是一件非常有挑战的事情。Choerodon融合了多个DevOps的开源工具，并且结合自身的能力。DevOps不同阶段的工具使用不同的编程语言开发，需要不同的运行环境(OS、数据库、中间件服务器等)。我们选取了如下的工具集的组合来落地实施DevOps，并且通过Choerodon平台融合能力，将不同的工具融合到Choerodon的DevOps流程中，用户仅需简单的配置即可使用，开始敏捷迭代之旅。 计划 Choerodon使用自主开发的敏捷管理开完成DevOps的计划步骤的工作。Choerodon敏捷管理的核心是需求，计划和执行。即通过用户故事地图来管理用户故事和发布计划，通过迭代来管理冲刺，最后通过看板来可视化冲刺的执行。 核心组件有： 用户故事地图。Choerodon的用户故事地图可以将你的backlog变成一张二维地图，而不是传统的简单列表。 迭代。迭代可以计划冲刺的用户故事数量、故事点、工时，并且拆分用户故事等。 看板。Choerodon的看板是Choerodon敏捷管理中执行部分，它的核心作用是可视化整个迭代的计划执行，并且暴露开发执行过程中的短板或者瓶颈 关于敏捷管理的详情，请参考敏捷管理。 编码 Choerodon采用主流的Git和Gitlab作为代码的管理和托管工具，同时使用Maven作为项目代码的组织和管理工具。 核心组件有： Git。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Gitlab。GitLab 是一个基于 Git 的仓库管理程序 也是一个方便软件开发的强大完整应用。 Maven。Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具 构建 Choerodon在构建阶段，采用Gitlab CI作为持续集成工具，Harbor作为镜像的存放库，同时Choerodon融合了Gitlab CI和Harbor这两个工具，以实现自动化和版本的控制。 Gitlab CI。Gitlab CI是Gitlab提供的一个持续集成工具。主要通过.gitlab-ci.yml 配置文件管理CI过程。 Harbor。Harbor 是一个企业级的 Docker Registry，可以实现 images 的私有存储和日志统计权限控制等功能，并支持创建多项目。 测试 Choerodon采用多个代码检查和测试工具，其中，SonarQube作为自动化代码检查工具；JUnit作为后端Java代码的测试工具； Selenium作为前端测试的工具。 核心组件有： SonarQube。SonarQube是一个用于代码质量管理的开源平台，用于管理源代码的质量，可以从七个维度检测代码质量搜索。通过插件形式，可以支持包括java C# C/C++ PL/SQL Cobol JavaScrip Groovy等等二十几种编程语言的代码质量管理与检测 JUnit。JUnit是一个Java语言的单元测试框架。 Selenium。Selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE） 编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。 部署和运营 Choerodon融合使用Docker、Kubernetes和Harbor作为部署工具。 核心组件有： Docker。Docker是一个开源的引擎 可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。 Kubernetes。Kubernetes是一个开源平台 用于跨主机群集自动部署 扩展和操作应用程序容器 提供以容器为中心的基础架构。 Harbor。Harbor 是一个企业级的 Docker Registry，可以实现 images 的私有存储和日志统计权限控制等功能，并支持创建多项目。 监控 Choerodon的监控包括了从用户故事开始到服务的运营全生命周期的状态、反馈、监控等，帮助开发和运营管理更好的提升效能。 核心组件有： Zipkin。Zipkin为分布式链路调用监控系统 聚合各业务系统调用延迟数据 达到链路调用监控跟踪。 Grafana。Grafana 是一个开箱即用的可视化工具，具有功能齐全的度量仪表盘和图形编辑器，有灵活丰富的图形化选项，可以混合多种风格，支持多个数据源特点。 Promethues。Promethues是由 SoundCloud 开发的开源监控报警系统和时序列数据库(TSDB)。 Micrometer。Micrometer 是一个监控指标的度量类库。 "},"/zh/docs/concept/choerodon-org":{"url":"zh/docs/concept/choerodon-org","title":"组织层次","description":"","language":"zh","body":"Choerodon 的组织架构 组织层次 Choerodon中有三层组织层次，即全局层、组织层和项目层。Choerodon使用三层组织结构来管理用户、权限、项目、环境资源、菜单，以及其他系统资源和功能。Choerodon这样的设计其实是借用的SaaS组织管理概念，主要是Choerodon应用开发框架为了满足用户SaaS化的需求而设计的，在Choerodon的应用开发和运营管理中使用的不多。 下面我们将从如下几个方面来阐述Choerodon的组织层次： 全局层 Choerodon的全局层中包含了系统的一些基本设置，例如组织管理、菜单管理、全局角色管理等。另外，在全局层还可以查看Choerodon系统中的服务和权限分配等。 全局层可以包含多个组织，例如运营组织。 关于全局的具体操作，请查看用户手册全局管理。 组织层 Choerodon使用组织来管理用户、权限、项目、环境资源，以及其它系统资源和功能。在系统中有一个默认的组织运营组织，目前Choerodon中所有的服务、功能和资源都定义在整个组织下面。举个例子，有一个零售公司，想通过Choerodon搭建一个基于微服务的数字化服务平台，此平台涵盖了从门店、零售到库存等整个供应链的管理，需要开发门店管理服务、零售服务、支付服务、库存服务、商品服务等，此时我们可以整个公司看做一个组织，将数字服务平台中包含的所有服务放在这个组织下。当然，如何以项目的形式开发，我们将在项目层中说明。 一个组织可以包含多个项目，例如智能监控。 关于组织的具体操作，请查看用户手册组织管理。 运营组织是Choerodon自带的缺省组织，Choerodon平台上所有的基础服务全部放在次组织下面。例如，用户服务、权限服务、看板服务、Gitlab服务等。 项目层 Choerodon通过项目来管理软件的开发，项目属于组织。Choerodon中项目的含义和现实项目的含义相似。在组织层我们提到零售公司的例子，需要开发门店管理服务、零售服务、支付服务、库存服务、商品服务等五个服务，我们有两个项目组来完成五个服务的开发，A项目组开发门店管理服务、零售服务、支付服务，B项目组负责库存服务、商品服务的开发，我们可以在零售公司组织下创建两个项目，A项目和B项目，在A项目中创建门店管理服务、零售服务、支付服务三个服务，在B项目下创建库存服务、商品服务两个服务。当然，根据具体的业务系统来定义项目，例如数字化服务平台项目，在此项目下创建门店管理服务、零售服务、支付服务、库存服务、商品服务等五个服务。 关于项目的具体操作，请查看用户手册项目管理。 "},"/zh/docs/concept/choerodon-system-architecture":{"url":"zh/docs/concept/choerodon-system-architecture","title":"系统架构","description":"","language":"zh","body":"Choerodon 的系统架构 Choerodon采用Spring Cloud作为微服务架构，本文介绍Spring Cloud微服务架构的概念并描述了Spring Cloud的功能，然后介绍基于Spring Cloud的各个组件搭建Choerodon的微服务整体架构，并对总体架构进行了设计和说明。 企业级系统服务架构演进 单体应用 在诞生之初始，应用与数据库是部署在同一台机器上，这时的用户量、数据量规模都比较小，这样的架构既简单实用、便于维护，成本又低，成为了这个时代的主流架构方式（这种架构仍然存在，在一些小型应用或者实验环境仍是主流，主要还是成本与方便性的原因）。 随着安全意识的提高及技术的发展，数据与应用分离的呼声渐高，原始单一应用逐步转化为WebServer＋DatabaseServer的模式。这一阶段的发展已经走到的尽头。 垂直应用 当单一应用不能满足需求时（主要是响应速度与吞吐量），如何改变架构以应对实际问题呢？问题是推动技术发展的源动力，当问题出现时，总是会有响应的解决方案，垂直型应用架构在这种背景下出现了。 所谓垂直型应用架构，是指将一个大的单一应用拆分成若干个小的单一应用，这样每个应用的压力大约有原来的1/n（粗略估计值）。这种拆分方式为后来的技 术发展奠定了基础，每次架构的变化都与这次有着密不可分的关系——分治（将一个大的问题按一定业务规则分成若干个小的问题，逐个解决）。 SOA 当垂直应用越来越多，业务上跨应用的交互不可避免，这给垂直应用架构带来了很大的挑战，如何才能进行跨应用的交互呢？RPC的出现解决了这个问 题，RPC作为分布式架构的核心内容，在提高业务复用、业务整合、架构扩展等方面发挥着不可替代的作用。因为RPC的实现方式有很多种，单一语言、跨语言 都存在相应的开源产品（当然也可以自建），这为RPC的使用及推广奠定了良好的基础。 此时需要注意，服务一定是无状态的、接口稳定的。 在分布式架构中，将剥离出来的核心业务构成的服务层相对独立、稳定，以这些服务为基础进行不同形式的组合使用，使前端（view、消费者）能够快速适应业务发展、变化。这时的前端架构也逐渐被从整体架构中剥离并越来越受到重视（尤其是移动应用的快速发展）。 微服务架构 分布式架构中的服务越来越多，导致交互越发复杂，不可避免会出现资源浪费的情况。如何才能更好的管理复杂的调用关系、提高资源利用率、对整个服务集群进行动态控制。服务治理被引入来解决上述问题。 如何在服务化架构中实现服务治理以及要对哪些内容进行治理，需要根据实际情况进行取舍，因为每个服务化架构中关注的内容可能都会有所不同。治理的实现方案也没有统一的方案、规范，在能满足自身需要的前提下，尽量避免过度管理、控制。 下面是一些建议： 服务注册与发现，能做到自动化最好，尽量少的人工干预会给后期运维带来非常大的好处； 路由、负载可以通过类似LVS这样的工具或者编码实现软复杂各有好处； 服务升、降级分自动与手动，根据实际访问情况进行动态调整； 服务监测、依赖关系尽量做到自动化； 监控、统计一定要自动化，并且能够进行细粒度分析。 Choerodon 微服务架构 Choerodon 是基于Spring Cloud构建的微服务系统。构件一套完整的微服务架构需要考虑许多问题，包括API Gateway、服务间调用、服务发现、服务容错、服务部署、数据调用等。基于Spring Cloud构建微服务架构可以通过自动配置和绑定Spring环境和其他Spring编程模型来实现微服务。采用Spring Boot应用程序提供的集成功能，通过几个简单的注释，开发人员可以快速配置和启用应用程序中的常见功能模块，并使用久经考验的Netflix组件构建大型分布式系统。 提供的微服务功能模块包括服务发现（Eureka），断路器（Hystrix），智能路由（Zuul）和客户端负载均衡（Ribbon）等。下图显示了采用Spring Cloud系列平台构建的微服务整体架构。 服务网关 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 认证中心 在Spring Cloud需要使用OAUTH2来实现多个微服务的统一认证授权，通过向OAUTH服务发送某个类型的grant type进行集中认证和授权，从而获得access_token，而这个token是受其他微服务信任的，我们在后续的访问可以通过access_token来进行，从而实现了微服务的统一认证授权。 注册中心 Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现。Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server，并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。Spring Cloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。 Eureka由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。 配置服务 Spring Cloud Config为服务端和客户端提供了分布式系统的外部化配置支持。配置服务中心采用Git的方式存储配置文件，因此我们很容易部署修改，有助于对环境配置进行版本管理。 消息服务 Kafka是分布式发布-订阅消息系统，最初由LinkedIn公司开发，之后成为之后成为Apache基金会的一部分，由Scala和Java编写。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。 服务监控 Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间 请求成功率等数据。但是只使用Hystrix Dashboard的话 你只能看到单个应用内的服务信息 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上 这个工具就是Turbine. 调用链追踪 Zipkin 是一款开源的分布式实时数据追踪系统（Distributed Tracking System），基于 Google Dapper 的论文设计而来，由 Twitter 公司开发贡献。其主要功能是聚集来自各个异构系统的实时监控数据，用来追踪微服务架构下的系统延时问题。 "},"/zh/docs/concept/security/RBAC":{"url":"zh/docs/concept/security/RBAC","title":"角色控制访问(RBAC)","description":"","language":"zh","body":"Choerodon 角色控制访问权限(RBAC) Choerodon 的对资源的管理是基于角色控制的，并从组织层、项目层和用户层对角色进行划分。 包含如下的特点： 基于角色的权限访问控制 基于组织层、项目层和用户层的三层权限体系 自定义角色创建和绑定 架构 下图介绍了Choerodon RBAC的架构。 工作流 下图介绍了RBAC的流程图。 组成 Choerodon RBAC 包含资源、角色、用户。同时包含资源与角色的关联，角色与用户的关联。 资源 Choerodon 遵循REST 原则，视HTTP-based REST API 为一个或一组资源。 对资源的引用和操作则视为权限。 权限的级别对应全局、组织、项目。 角色 角色是资源的超集。 角色的级别对应为全局、组织、项目。 角色和资源之间通过RBAC 关联起来。 一个角色严格遵循只能访问所属资源的原则。 角色支持自定义角色，通过标签将角色和第三方系统进行关联。 用户 用户是资源的实际使用者。 用户和角色之间通过RBAC 关联起来。 "},"/zh/docs/concept/security/":{"url":"zh/docs/concept/security/","title":"安全","description":"","language":"zh","body":"安全 介绍Choerodon的认证体系和权限控制功能。 认证体系 介绍 Choerodon 的认证体系， Choerodon 采用 Spring Cloud Security 和 Spring Cloud OAuth2 作为认证技术框架。 权限控制 介绍 Choerodon 的权限控制功能， Choerodon 采用基于角色的权限访问控制（Role-Based Access Control）。 "},"/zh/docs/concept/security/authentication":{"url":"zh/docs/concept/security/authentication","title":"认证体系","description":"","language":"zh","body":"Choerodon 认证体系 身份验证的目的是增强微服务和保证微服务之间的通信安全。 主要负责如下功能： 提供给网关一个统一的认证入口。 提供微服务通信的统一的用户 session 保证。 提供 token 管理系统，用来生成 token ，存储 token ， 撤销 token 。 架构 下图介绍了Choerodon 认证体系的架构。 组成 认证服务器 认证服务器，即专门用来处理认证的服务器。 资源服务器 资源服务器，即存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 在Choerodon 中，资源服务器主要指系统中的一个个微服务。 工作流 认证流程包含三个阶段， 授权阶段，鉴权阶段和使用阶段。 授权阶段 资源拥有者根据用户名和密码，调用授权服务器。 授权服务器校验用户名和密码，生成对应的token返回给客户端，并将token存储下来，用于之后的鉴权。 客户端将token存储在本地，用于之后每次请求的鉴权。 鉴权阶段 客户端根据本地的token请求资源。 网关将根据token去授权服务器鉴权。 授权服务器将网关传来的token 和存储的token 进行对比，来确定本次操作是否是合法的。 使用阶段 鉴权通过，网关将token转化成包含用户信息的JWT token，并将JWT token 传给资源服务器。 资源服务器根据JWT token 解析成用户信息，执行资源操作。 "},"/zh/docs/development-guide/":{"url":"zh/docs/development-guide/","title":"开发手册","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/":{"url":"zh/docs/development-guide/backend/","title":"后端开发","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/basic_env/":{"url":"zh/docs/development-guide/backend/basic_env/","title":"基础环境准备","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/basic_env/init":{"url":"zh/docs/development-guide/backend/basic_env/init","title":"数据初始化","date":"2017-02-01","language":"zh","body":"数据初始化 启动容器 在IDEA启动 mysql，redis，rabbitmq 容器 创建Mysql数据库 1.查看容器，确认存在容器名为mysql的容器: $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d616dd00797b registry.saas.hand-china.com/tools/redis \"/sbin/entrypoint.sh\" 2 hours ago Up 2 hours 0.0.0.0:6379->6379/tcp redis eda713caef09 registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management \"/docker-entrypoin...\" 2 hours ago Up 2 hours 4369/tcp 5671/tcp 0.0.0.0:5672->5672/tcp 15671/tcp 25672/tcp 0.0.0.0:15672->15672/tcp rabbitmq 03ad58a5da5b registry.saas.hand-china.com/tools/phpmyadmin \"/run.sh phpmyadmin\" 2 hours ago Up 2 hours 0.0.0.0:80->80/tcp phpmyadmin d86c2bb3bd28 registry.saas.hand-china.com/tools/mysql:5.7.17 \"docker-entrypoint...\" 2 hours ago Up 2 hours 0.0.0.0:3306->3306/tcp mysql 2.用root用户命令行登陆 mysql 容器，密码为 root docker exec -ti mysql mysql -uroot -p 3.创建用户和数据库: CREATE USER 'hapcloud'@'%' IDENTIFIED BY \"handhand\"; CREATE DATABASE hap_user_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_framework_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_scheduler_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_cloud_test DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_zipkin_ui DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON hap_user_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_framework_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_scheduler_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_cloud_test.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_zipkin_ui.* TO hapcloud@'%'; FLUSH PRIVILEGES; 初始化数据库 1.在git bash中通过命令进入 hap-user-service 目录和 hap-framework-service-parent 目录和hap-scheduler-service目录 2.执行命令: sh init-local-database.sh 3.命令执行成功之后，刷新 hap_user_service 、 hap_framework_service 和 hap_scheduler_service 数据库，会出现初始化脚本中的表以及初始化数据 repository信息安装 进入hap-cloud-parent子模块执行mvn install指令 开发分支 若要进行开发任务，希望确保与最新代码协作，请进入各个子模块使用git checkout release-1.0.0切换到当前的开发分支。 "},"/zh/docs/development-guide/backend/basic_env/run":{"url":"zh/docs/development-guide/backend/basic_env/run","title":"运行","date":"2017-02-01","language":"zh","body":"运行 运行程序 前提 在IDEA启动 mysql，redis，rabbitmq 容器。 在IDEA中运行程序 在对应模块目录下执行如下命令或在IDE内进行等效操作可以启动该模块 mvn spring-boot:run 要使功能完整可用，在本地至少启动如下模块 hap-register-server hap-oauth-server hap-api-gateway hap-user-service hap-user-admin-service hap-framework-service hap-framework-service 在仓库 hap-framework-service-parent 内。 若要使用调度服务，则在启动下列服务 hap-scheduler-service "},"/zh/docs/development-guide/backend/basic_env/test":{"url":"zh/docs/development-guide/backend/basic_env/test","title":"验证测试","date":"2017-02-01","language":"zh","body":"验证测试 register-server测试 打开浏览器访问 http://localhost:8000。正常显示说明注册服务启动成功，可以看到已经注册好的服务。 api-gateway测试 打开浏览器访问 http://localhost:8080/swagger-ui.html。正常显示说明API网关启动成功 上方列表一栏分别与一个服务相关联，通过切换可以看到各个服务的api oauth-server测试 在api-gateway测试页面，通过以下步骤获得授权 账号密码为admin/admin 获得授权后，在 http://localhost:8080/swagger-ui.html 便可以直接访问api user-service测试 以获取某组织下的客户端数据为例 发送参数 获取结果 user-admin-service测试 framework-service测试 "},"/zh/docs/development-guide/backend/demo/":{"url":"zh/docs/development-guide/backend/demo/","title":"开发Demo程序","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/demo/application":{"url":"zh/docs/development-guide/backend/demo/application","title":"编写Application类","date":"2017-02-01","language":"zh","body":"编写Application类 编写TodoServiceApplication类 package com.hand.hap.cloud.todo.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; /** * Created by ziling.zhong on 2017/7/5. */ @EnableEurekaClient @SpringBootApplication public class TodoServiceApplication { public static void main(String[] args) { SpringApplication.run(TodoServiceApplication.class args); } } 结构图 "},"/zh/docs/development-guide/backend/demo/controller":{"url":"zh/docs/development-guide/backend/demo/controller","title":"编写Controller","date":"2017-02-01","language":"zh","body":"编写Controller Controller 类 Controller 负责对 Model 和 View 的处理，创建在 项目模块 的 xxx..controller 包下。 每一个 Controller 是对一个具体的 domain 资源进行处理的，所以命名为 domain 类名 + Controller。如： UserController 对应 User 类。 需要通过 @Controller 指定该类为一个 Controller 类。 需要在每一个 Controller 中通过 @Autowired 注入 Service 。 Controller 的每一个方法只在最后调用一次该 Controller 所注入的 Service ，因此当有调用多个Service的需求应该放在注入的 Service 中。 代码 TaskController.java 注意Controller中的path需要以V1开头，否则后续步骤中swagger无法获取api。 @Permission注解进行权限控制，以下代码中@Permission注解的permissionLogin属性设置为true，表示需登录授权后进行访问。 package com.hand.hap.cloud.todo.demo.controller; import com.hand.hap.cloud.resource.exception.HapException; import com.hand.hap.cloud.swagger.annotation.MenuLevel; import com.hand.hap.cloud.swagger.annotation.Permission; import com.hand.todo.demo.domain.TodoTask; import com.hand.todo.demo.service.TaskService; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import javax.validation.Valid; import java.util.List; import java.util.Map; import java.util.Optional; import java.util.TreeMap; /** * Created by ziling.zhong on 2017/7/5. */ @RestController @RequestMapping(value = \"/v1/todoTask\") public class TaskController { @Autowired private TaskService taskService; /** * 创建task * * @param task task信息 * @return 创建的task信息 * @throws HapException 创建失败 */ @Permission(permissionLogin = true) @ApiOperation(value = \"创建task\") @RequestMapping(value = \"/create\" method = RequestMethod.POST) public ResponseEntity create(@RequestBody @Valid TodoTask task) throws HapException { return Optional.ofNullable(taskService.create(task)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new HapException(\"error.todoTask.create\")); } @Permission(permissionLogin = true) @ApiOperation(value = \"根据任务编号获取任务\") @RequestMapping(value = \"/findByNumber/{taskNumber}\" method = RequestMethod.GET) public ResponseEntity findByNumber(@PathVariable @Valid String taskNumber) throws HapException { return Optional.ofNullable(taskService.findByTaskNumber(taskNumber)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new HapException(\"error.todoTask.notFound\")); } /** * 根据任务ID更新任务信息 * * 注意：更新task时需在json数据中添加objectVersionNumber属性及值才能更新成功。 * * @param id 任务ID * @param task 任务信息 * @return 更新后的任务信息 * @throws HapException 更新失败 */ @Permission(permissionLogin = true) @ApiOperation(value = \"根据任务ID更新任务信息\") @RequestMapping(value = \"/{id}\" method = RequestMethod.PUT) public ResponseEntity updateUser(@PathVariable Long id @RequestBody @Valid TodoTask task) throws HapException { return Optional.ofNullable(taskService.update(id task)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new HapException(\"error.todoTask.update\")); } @Permission(permissionLogin = true) @ApiOperation(value = \"根据版本编号获取任务\") @RequestMapping(value = \"/findByVersionNumber/{objectVersionNumber}\" method = RequestMethod.GET) public ResponseEntity> findByVersionNumber(@PathVariable @Valid Long objectVersionNumber) throws HapException { Map map = new TreeMap<>(); map.put(\"tasks\" taskService.findByTaskVersionNumber(objectVersionNumber)); return Optional.ofNullable(map).map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new HapException(\"error.todoTask.notFound\")); } // @Permission(permissionLogin = true) // @ApiOperation(value = \"根据版本编号获取任务\") // @RequestMapping(value = \"/findByVersionNumber/{objectVersionNumber}\" method = RequestMethod.GET) // public ResponseEntity> findByVersionNumber(@PathVariable @Valid Long objectVersionNumber) throws HapException { // return Optional.ofNullable(taskService.findByTaskVersionNumber(objectVersionNumber)) // .map(result -> new ResponseEntity<>(result HttpStatus.OK)) // .orElseThrow(() -> new HapException(\"error.todoTask.findByVersionNumber\")); // } @Permission(permissionLogin = true) @ApiOperation(value = \"根据ID删除任务\") @RequestMapping(value = \"/{id}\" method = RequestMethod.DELETE) public ResponseEntity deleteByEmployeeId(@PathVariable Long id) throws HapException { taskService.delete(id); return new ResponseEntity(HttpStatus.NO_CONTENT); } @Permission(permissionLogin = true) @ApiOperation(value = \"根据任务号码删除任务\") @RequestMapping(value = \"/taskNumber/{taskNumber}\" method = RequestMethod.DELETE) public ResponseEntity deleteByTaskNumber(@PathVariable String taskNumber) throws HapException { taskService.deleteByTaskNumber(taskNumber); return new ResponseEntity(HttpStatus.NO_CONTENT); } } "},"/zh/docs/development-guide/backend/demo/hap-cloud-backend":{"url":"zh/docs/development-guide/backend/demo/hap-cloud-backend","title":"集成HAPCloudBackend项目配置","date":"2017-02-01","language":"zh","body":"集成HAPCloudBackend项目配置 HAPCloudBackend项目配置 HAPCloudBackend项目地址：[https://rdc.hand-china.com/gitlab/HAPCloud/HAPCloudBackend.git] 开发环境配置 详见 windows开发环境安装或Linux开发环境安装或macOS开发环境安装 基础环境准备 详见 基础环境准备 启动服务 这里至少需要启动 hap-register-server ， hap-oauth-server ， hap-api-gateway 三个服务。 如需其他功能，可按需启动其他服务。 hap-register-server:即eureka服务发现，所有的服务都会注册在这里，需要第一个启动。无须额外配置。 hap-oauth-server:oauth服务，通过jwt token对所有服务的连接进行认证。无须额外配置。 hap-api-gateway:包含了swagger服务和gateway服务，对eureka服务中的注册服务进行监听捕获，在swagger中测试会进行自动的转发路由至对应的api。需要修改配置文件，主要内容为redis服务器以及端口、rabbitmq服务器以及端口、eureka服务器地址，指定todo service的service id。注意localhost为本地docker-machine的ip地址，根据自己本地的情况经行对应的修改。 方式一：直接修改application-default.yml 注意根据自己的需求进行修改，修改dev的配置信息，不要提交代码。 spring: datasource: url: jdbc:mysql://localhost/hap_user_service?useUnicode=true&characterEncoding=utf-8&useSSL=false username: hapcloud password: handhand rabbitmq: host: localhost port: 5672 zuul: addHostHeader: true routes: dev: path: /todo/** serviceId: hap-todo-service uaa: path: /uaa/** serviceId: hap-user-service fws: path: /fws/** serviceId: hap-framework-service admin: path: /admin/** serviceId: hap-user-admin-service oauth: path: /oauth/** sensitiveHeaders: serviceId: hap-oauth-server stripPrefix: false security: oauth2: resource: userInfoUri: http://hap-oauth-server/oauth/api/user ignored: - /oauth/** 方式二：在启动gat-way的配置信息中添加自订的配置信息： -Dzuul.routes.todo.serviceId=hap-todo-service -Dspring.redis.host=localhost -Dspring.redis.port=6379 -Dspring.rabbitmq.port=5672 -Deureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka -Dspring.application.name=hap-api-gateway-test "},"/zh/docs/development-guide/backend/demo/init":{"url":"zh/docs/development-guide/backend/demo/init","title":"初始化数据库","date":"2017-02-01","language":"zh","body":"初始化数据库 在Mysql管理工具中新建数据库与用户，并赋权限，sql如下： CREATE USER 'hapdemo'@'%' IDENTIFIED BY \"handhand\"; CREATE DATABASE hap_demo_service_todo DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON hap_demo_service_todo.* TO hapdemo@'%'; FLUSH PRIVILEGES; 编写执行脚本 init-local-database.sh 放在项目根目录下 #!/usr/bin/env bash # 获取初始化数据库的jar包 mkdir -p target if [ ! -f target/hap-liquibase-tools.jar ] then curl http://nexus.saas.hand-china.com/content/repositories/rdc/com/hand/hap/cloud/hap-liquibase-tools/1.0/hap-liquibase-tools-1.0.jar -o target/hap-liquibase-tools.jar fi # 初始化项目数据库 java -Dspring.datasource.url=\"jdbc:mysql://localhost:3306/hap_demo_service_todo?useUnicode=true&characterEncoding=utf-8&useSSL=false\" \\ -Dspring.datasource.username=hapdemo \\ -Dspring.datasource.password=handhand \\ -Ddata.init=true -Ddata.drop=true \\ -Ddata.dir=hap-todo-service/src/main/resources \\ -jar target/hap-liquibase-tools.jar # 追加项目数据信息到hap-user-service数据库中 java -Dspring.datasource.url=\"jdbc:mysql://localhost:3306/hap_user_service?useUnicode=true&characterEncoding=utf-8&useSSL=false\" \\ -Dspring.datasource.username=hapcloud \\ -Dspring.datasource.password=handhand \\ -Ddata.init=true \\ -Ddata.dir=hap-user-service-db \\ -jar target/hap-liquibase-tools.jar 脚本执行程序会自动扫描resources中的groovy数据库初始化文件以及excel初始化数据。 groovy脚本文件名要以编写时的日期开头，因为导入是按照文件名排序，这样可以保证导入顺序 groovy内的databaseChangeLog块内要有logicalFilePath参数为当前文件名 新增的数据库修改一般要新建 changeSet，不可直接修改原来的changeSet，并且 id 值按以下案例规范操作，并写上作者 author 信息 详细参考文档： 参考文档 在执行程序的参数中，-Ddata.drop=true 只能在本地开发环境使用，在正式环境必须设置为 -Ddata.drop=false groovy初始化数据库脚本 2017-07-11-demo.groovy 如下，在模块中的resources文件夹中新建db文件夹，放在该文件夹下： package db databaseChangeLog(logicalFilePath: '2017-05-11-demo.groovy') { changeSet(id: '2017-05-29-todo' author: 'zhuang.chang@hand-china.com') { createTable(tableName: \"todo_user\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'employee_name' type: 'VARCHAR(32)' remarks: '员工名') column(name: 'employee_number' type: 'VARCHAR(32)' remarks: '员工号') { constraints(unique: true) } column(name: 'email' type: 'VARCHAR(32)' remarks: '邮箱') column(name: \"OBJECT_VERSION_NUMBER\" type: \"BIGINT\" defaultValue : \"1\") column(name: \"CREATED_BY\" type: \"BIGINT\" defaultValue : \"-1\") column(name: \"CREATION_DATE\" type: \"DATETIME\" defaultValueComputed : \"CURRENT_TIMESTAMP\") column(name: \"LAST_UPDATED_BY\" type: \"BIGINT\" defaultValue : \"-1\") column(name: \"LAST_UPDATE_DATE\" type: \"DATETIME\" defaultValueComputed : \"CURRENT_TIMESTAMP\") } createTable(tableName: \"todo_task\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'employee_id' type: 'BIGINT' remarks: '员工ID') column(name: 'state' type: 'VARCHAR(36)' remarks: '状态') column(name: 'task_number' type: 'VARCHAR(64)' remarks: '任务编号') { constraints(unique: true) } column(name: 'task_description' type: 'VARCHAR(256)' remarks: '任务编号') column(name: \"OBJECT_VERSION_NUMBER\" type: \"BIGINT\" defaultValue : \"1\") column(name: \"CREATED_BY\" type: \"BIGINT\" defaultValue : \"-1\") column(name: \"CREATION_DATE\" type: \"DATETIME\" defaultValueComputed : \"CURRENT_TIMESTAMP\") column(name: \"LAST_UPDATED_BY\" type: \"BIGINT\" defaultValue : \"-1\") column(name: \"LAST_UPDATE_DATE\" type: \"DATETIME\" defaultValueComputed : \"CURRENT_TIMESTAMP\") } createTable(tableName: \"todo_swimlane\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'state' type: 'VARCHAR(36)' remarks: '状态') { constraints(unique: true) } column(name: 'next_state' type: 'VARCHAR(36)' remarks: '下一状态') } } } 初始化数据excel文档：在项目根目录下新建hap-user-service-db文件夹，放在该文件夹下。 2017-07-11-demo.xls 具体编写规则见excel中 README sheet页。 结构图 准备好三个文件后，在项目根目录执行 sh init-local-database.sh 初始化数据库 "},"/zh/docs/development-guide/backend/demo/mapper":{"url":"zh/docs/development-guide/backend/demo/mapper","title":"编写实体类和Mapper类","date":"2017-02-01","language":"zh","body":"编写实体类和Mapper类 实体类 创建domain类 domain 类不需要提供任何实现，所以属于供应方的服务接口层。创建在 项目模块 的 xxx..domain 包下。 每一个 domain 类即为一个实体类，对应数据库中的一个具体表。 名称与表名称相同，表名中 _ 替换为驼峰命名法，首字母大写。如：UserRole 对应表为 user_role。 指定对应表 @Table(name = “table_name”) 指定 domain 对应数据库中表的名称。 每一个 domain 对应数据库中的一个具体表，一般都需要继承 AuditDomain 类。 属性规范 所有属性均为private属性。 每一个属性需要生成对应的 getter 和 setter 方法。 字段名称应根据驼峰命名规则从数据库列名转换过来。例如：数据库列名为 USER_NAME ，则字段名为 UserName，特殊字段名称，可以在字段在添加 @Column(name = “xxx”) 注解，指定数据库列名。 非数据库字段 需要用 @Transient 标注 javax.persistence.Transient 属性的的类型与字段的 type 对应 不使用基本类型，全部使用基本类型的包装类，如 Long 对应数据库中的 INTEGER，而不是使用 long 数字类型主键统一采用 Long 金额、数量 等精度严格浮点类型采用 BigDecimal 注意：BigDecimal 在计算、比较方面的特殊性 所有的主键字段都需要用@Id标注 对于自增张、序列（SEQUENCE）类型的主键，需要添加注解@GeneratedValue 序列命名规范：表名_S。例如：表 SYS_USER 对应的序列为 SYS_USER_S TodoTask.java 代码 package com.hand.hap.cloud.todo.demo.domain; import com.hand.hap.cloud.mybatis.annotation.ModifyAudit; import com.hand.hap.cloud.mybatis.annotation.VersionAudit; import com.hand.hap.cloud.mybatis.domain.AuditDomain; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.Table; import javax.validation.constraints.NotNull; /** * Created by chang on 2017/5/27. */ @ModifyAudit @VersionAudit @Table(name = \"todo_task\") public class TodoTask extends AuditDomain { @Id @GeneratedValue private Long id; @NotNull(message = \"error.todoTask.employeeNotNull\") private Long employeeId; @NotNull(message = \"error.todoTask.taskNumberNotNull\") private String taskNumber; private String taskDescription; @NotNull(message = \"error.todoTask.stateNotNull\") private String state; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Long getEmployeeId() { return employeeId; } public void setEmployeeId(Long employeeId) { this.employeeId = employeeId; } public String getTaskNumber() { return taskNumber; } public void setTaskNumber(String taskNumber) { this.taskNumber = taskNumber; } public String getTaskDescription() { return taskDescription; } public void setTaskDescription(String taskDescription) { this.taskDescription = taskDescription; } public String getState() { return state; } public void setState(String state) { this.state = state; } } Mapper mapper接口类 Mapper 接口类即为传统意义上的 DAO，但与 interface 不同，Mapper 本身就是对数据访问的具体实现，所以属于供应方的服务实现层。创建在 项目模块 的 xxx..mapper 包下。 每一个 Mapper 接口类封装了对数据库表的操作，每一个 Mapper 对应一个 domian 类，所以命名为 domian 类名 + Mapper。如：UserRoleMapper 对应表为 UserRole 类。 基础的 CRUD 操作不需要再次实现，通过继承 BaseMapper 类实现。其中 T 为 对应 domian 的泛型。 复杂的数据库操作需要定义具体的接口方法。 mapper.xml Mapper.xml 是数据库的的具体映射，与 Mapper 接口同级，创建在 项目模块 resources 目录的 xxx..mapper 包下。 Mapper.xml，与 Mapper 接口对应。所以命名 Mapper 接口类相同。 对于基本的 CRUD 不需要进行配置，所以也就不需要创建对应的 Mapper.xml 文件。 对于自定义的数据库方法，需要创建对应的 Mapper.xml 文件。 Mapper.xml 中的操作 id 对应 Mapper 接口类的方法名。 以下为一个示例，不在本项目中使用: # mapper接口类定义sql接口，以及参数 public interface MenuMapper { List selectMenuByLevelAndOrganization(@Param(\"menuLevel\") String menuLevel @Param(\"organizationId\") Long organizationId); } SELECT resource.id AS resource_id resource.code AS resource_code resource.name AS resource_name resource.entry AS resource_entry service.id AS service_id service.code AS service_code service.name AS service_name product.id AS product_id product.code AS product_code product.name AS product_name FROM resource LEFT JOIN service ON resource.service_id = service.id LEFT JOIN product ON service.product_id = product.id WHERE resource.menu_level = #{menuLevel} AND service.id IN( SELECT service.id FROM service WHERE service.id NOT IN( SELECT label.resource_id FROM label WHERE label.resource_type = 'service' ) UNION SELECT s.resource_id FROM label s label o WHERE s.label_key = o.label_key AND s.label_value = s.label_value AND s.resource_type = 'service' AND o.resource_type = 'organization' AND o.resource_id = #{organizationId} ) 以下为本项目中使用的mappper接口 TodoTaskMapper.java ，未定义额外的sql： package com.hand.hap.cloud.todo.demo.mapper; import com.hand.hap.cloud.mybatis.common.BaseMapper; import com.hand.todo.demo.domain.TodoTask; /** * Created by chang on 2017/5/30. */ public interface TodoTaskMapper extends BaseMapper { } "},"/zh/docs/development-guide/backend/demo/new":{"url":"zh/docs/development-guide/backend/demo/new","title":"新建项目","date":"2017-02-01","language":"zh","body":"新建项目 新建maven项目 创建子模块 添加pom依赖 父级pom 这里添加一些公用的pom属性，类似私有仓库等等。 com.hand.hap.cloud hap-cloud-parent 1.0.0-Release hand-snapshot-repository Hand Snapshot Repository http://nexus.saas.hand-china.com/content/repositories/rdcsnapshot/ true hand-release-repository Hand Release Repository http://nexus.saas.hand-china.com/content/repositories/rdc/ org.springframework.cloud spring-cloud-dependencies Dalston.RELEASE pom import org.springframework.boot spring-boot-maven-plugin 子级pom 根据子级模块所需jar包添加需要的依赖。以下介绍一些hap-cloud特有的依赖： hap-feign-replay-starter，为feign提供token转发功能，如果本服务需要使用feign调用其他服务需加 hap-mybatis-mapper-starter，mybatis的工具包，增删改查和分页和多语言功能。 hap-resource-server-starter，resource-server工具包，resource-server必加，我们这个就是resource-server。 hap-swagger-starter，swgger工具包，对菜单和权限注解的解析 com.hand.hap.cloud hap-resource-server-starter 1.0.0-Release com.hand.hap.cloud hap-swagger-starter 1.0.0-Release com.hand.hap.cloud hap-mybatis-mapper-starter 1.0.0-Release com.hand.hap.cloud hap-feign-replay-starter 1.0.0-Release org.springframework.cloud spring-cloud-starter-eureka mysql mysql-connector-java org.springframework.cloud spring-cloud-config-client org.springframework.boot spring-boot-starter-aop org.springframework.retry spring-retry org.springframework.cloud spring-cloud-starter-bus-amqp org.springframework.cloud spring-cloud-starter-sleuth org.springframework.cloud spring-cloud-sleuth-stream org.springframework.cloud spring-cloud-stream-binder-rabbit org.springframework.boot spring-boot-starter-test test 项目结构 在子模块resource文件夹中配置 项目基础配置，类如数据库、端口号等等 项目与hap-cloud-parent进行集成，关联注册服务器、验证服务器、以及gateway、swagger服务器 bootstrap.yml 一定会执行的配置文件，声明项目的一些基本配置.spring.profiles会指定application.yml生效的版本，这里是default。 server: port: 8378 mybatis: mapperLocations: classpath*:/mapper/*.xml configuration: mapUnderscoreToCamelCase: true spring: application: name: hap-todo-service eureka: instance: preferIpAddress: true leaseRenewalIntervalInSeconds: 1 leaseExpirationDurationInSeconds: 3 client: serviceUrl: defaultZone: ${EUREKA_DEFAULT_ZONE:http://localhost:8000/eureka/} --- spring: profiles: default cloud: config: enabled: false --- spring: profiles: docker sit cloud: config: discovery: serviceId: hap-config-server enabled: true failFast: true retry: maxAttempts: 32 multiplier: 1.5 maxInterval: 10000 application-default.yml spring: datasource: url: jdbc:mysql://localhost/hap_demo_service_todo?useUnicode=true&characterEncoding=utf-8&useSSL=false username: hapdemo password: handhand eureka: client: serviceUrl: defaultZone: http://localhost:8000/eureka swagger: oauthUrl: http://localhost:8080/oauth/oauth/authorize 结构图 "},"/zh/docs/development-guide/backend/demo/overview":{"url":"zh/docs/development-guide/backend/demo/overview","title":"项目需求","date":"2017-02-01","language":"zh","body":"项目需求 业务需求 创建一个简单的项目，实现记录待办事项的功能，具体功能包括:创建任务、根据任务编号获取任务、根据ID删除任务、根据任务号码删除任务、根据任务ID更新任务信息。 表结构 创建todo_task表，包括id employee_id task_number task_description state等字段。 功能测试 要求与HAP Cloud框架结合，进行API测试。 开发环境 在开发之前，要保证环境已经安装正确，详见 windows开发环境安装或Linux开发环境安装或macOS开发环境安装 "},"/zh/docs/development-guide/backend/demo/permission_data":{"url":"zh/docs/development-guide/backend/demo/permission_data","title":"权限及相关数据初始化及菜单添加","date":"2017-02-01","language":"zh","body":"权限及相关数据初始化及菜单添加 gateway在拉取各个资源服务的api接口文档时会初始化相关权限数据。拉取方式分为自动和手动。 当我们直接访问gateway的swagger页面时，会访问到资源服务的/api/doc接口，此时gateway会根据该服务的api文档初始化权限相关数据。 资源服务在注册中心注册时，会发出一个消息，gateway会监听这个消息会在后台自动拉取该资源服务的api接口文档。 代码初始化时只会初始化表中一些关键字段，其余字段完善需要人工完善 service表与service_tl表 当hap-demo-service初始化后，会在service表中插入一条数据，但是name字段等需要手动添加。 同样在service_tl多语言表中完善相应数据，其中id字段对应service表的id。 role表 role表需完善decription字段，否则前段界面显示不出该角色中文描述 添加菜单 如要在界面上添加新的菜单，需要新建初始化数据的excel，通过初始化数据库工具初始化数据。格式如同hap-user-service的数据库初始化excel。其中表中service_id表示该菜单所挂载的服务。menu_level表示该菜单挂载在组织层还是项目层.如果直接在数据库表中操作则需要注意同时修改menu表和menu_tl表。 "},"/zh/docs/development-guide/backend/demo/scheduler":{"url":"zh/docs/development-guide/backend/demo/scheduler","title":"服务调度（可选）","date":"2017-11-07","language":"zh","body":"服务调度 若开发者在实际开发过程中有如下需求，则需要阅读本节 某种周期性（如每天某一时刻）的服务调用 指定时间后进行服务调用 准备 为了能够为开发者的服务提供一个定时调度的功能，请确保hap-scheduler-service服务处于启动状态 使用 因为调度服务只负责时间的轮询，故而任务的建立与执行依靠http请求。 任务发起方需向调度平台发起如下请求: host: hap-scheduler-service url: /v1/job method: POST { \"accessToken\": \"string\" // 请求所用的token，若不设置，则将发起申请请求时HEAD所携带的token作为执行请求时的token \"triggerType\": \"string\" // 所需要的触发器类型，必须设置，有SIMPLE与CRON两种 \"startTime\": \"string\" // 任务开始时间，若不设置则请求成功立刻开始 单位毫秒 \"endTime\": \"string\" // 结束时间，可不设置，单位毫秒 \"id\": 0 // id不设置 \"jobDescription\": \"string\" // 任务描述，必须设置 \"jobGroup\": \"string\" // 任务所在组，推荐设置为发起请求的服务名，若不设置则为default \"priority\": 0 // 优先级，默认为5 \"repeatCount\": 0 // 当TriggerType为SIMPLE时可设置，任务重复执行次数，不设置则不重复执行，即只执行一次 \"repeatInterval\": 0 // 当TriggerType为SIMPLE时可设置，任务重复时间间隔，不设置则间隔时间设置为1s，单位毫秒 \"cronExpression\": \"string\" // 周期定时任务表达式 当triggerType为CRON时必须设置 \"requestBody\": \"string\" // 当需要请求报文实体时可设置 \"requestMethod\": \"string\" // 请求的http方法，必须设置 \"requestService\": \"string\" // 所要请求的服务，必须设置 \"requestUrl\": \"string\" // 所请求api的url，必须设置(如/v1/job) \"triggerState\": \"string\" // 触发器状态，无需设置，由服务内部处理 } 解释 触发器类型 SimpleTrigger: 它可以触发一个已经安排进调度程序（任务执行计划）的任务，并可以指定时间间隔重复执行该任务。 特点 开始时间 结束时间 重复次数 重复执行的时间间隔。 重复的次数可以是零，一个正整数。总执行次数为重复次数+1，即重复0次将执行1次，若重复次数为-1则永远执行。 重复执行的时间间隔为long类型的数值表示毫秒。 结束时间的属性会重写重复的次数，如果你想创建一个触发器，如每10秒触发一次，直到一个给定的时刻，而不是要计算的次数，它会在开始时间和结束时间重复执行。结束时间一到，就算你指定了重复次数很多次(比如执行10W次)，但是时间一到它将不再执行。 CronTrigger: 主要基于日历的概念，而不是对具体间隔的行为。 特点: 采用cron表达式(若需要此功能请自行了解) 示例 确保应用的启动类上具有@EnableFeignClients注解(声明该应用为feign客户端)，若有该注解时依然产生bean无法获取的异常，则为该注解制定basePackages 为应用的依赖添加以下项 com.hand.hap.cloud hap-scheduler-helper 1.0.0-Release 编写示例代码 `java package com.hand.hap.cloud.todo.demo.controller; import com.hand.hap.cloud.resource.exception.HapException; import com.hand.hap.cloud.scheduler.helper.SchedulerTemplate; import com.hand.hap.cloud.scheduler.helper.domain.JobInfo; import com.hand.hap.cloud.scheduler.helper.util.JobGenerator; import com.hand.hap.cloud.swagger.annotation.Permission; import com.hand.hap.cloud.todo.demo.domain.TodoTask; import com.hand.hap.cloud.todo.demo.service.TaskService; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import java.util.Date; @RestController @RequestMapping(value = \"/v1/scheduler\") public class SchedulerController { @Autowired private TaskService taskService; @Autowired private SchedulerTemplate schedulerTemplate; @Permission(permissionLogin = true) @ApiOperation(value = \"测试调度功能\") @RequestMapping(value = \"/test\" method = RequestMethod.POST) public ResponseEntity test() throws HapException { TodoTask task = new TodoTask(); task.setTaskNumber(String.valueOf(Math.random())); task = taskService.create(task); JobInfo jobInfo = JobGenerator.generateSimpleJob(); jobInfo.setRequestService(\"hap-todo-service\"); jobInfo.setRequestUrl(\"/v1/todoTask/\" + task.getId()); jobInfo.setRequestMethod(RequestMethod.DELETE.name()); jobInfo.setJobDescription(\"测试删除待办事项\" + task.getId()); jobInfo.setStartTime(new Date(System.currentTimeMillis()+10000)); schedulerTemplate.createJob(jobInfo); return new ResponseEntity(task HttpStatus.OK); } } ``` 访问接口进行测试，可以看到代办事项被新建，在10秒后被删除(可能因服务器压力导致时间误差) "},"/zh/docs/development-guide/backend/demo/service":{"url":"zh/docs/development-guide/backend/demo/service","title":"编写Service","date":"2017-02-01","language":"zh","body":"编写Service Service 接口类 Service 接口类定义了业务操作的一系列接口，并不提供实现，具体实现需要通过服务实现层提供，所以属于供应方的服务接口层。创建在 项目模块 的 xxx..service 包下。 每一个 Service 对应一个 domain 类，所以命名为domain 类名 + Service。如：UserService 对应表为 User 类。 Service 接口，如无特殊例外，需要继承 BaseService 接口 T 为 Service 本身 Service 实现类 Service 接口的具体实现通过服务实现层提供，所以属于供应方的服务实现层。创建在 项目模块 的 xxx..service.impl 包下。 实现类，如无特殊情况，需要用 @Service 标注，以自动扫描注册 实现类可以通过继承 BaseServiceImpl 来获得标准的 CRUD 操作支持 需要 Service 接口类 继承 BaseServiceImpl ServiceImpl 中对于 Mapper 的 CRUD 操作参照 基础 CRUD 操作。 代码 接口类 TaskService.java package com.hand.hap.cloud.todo.demo.service; import com.hand.hap.cloud.mybatis.service.BaseService; import com.hand.todo.demo.domain.TodoTask; import java.util.List; /** * Created by ziling.zhong on 2017/7/5. */ public interface TaskService extends BaseService{ TodoTask findByTaskNumber(String taskNumber); int delete(Long id); int deleteByTaskNumber(String taskNumber); TodoTask create(TodoTask task); TodoTask update(Long id TodoTask task); List findByTaskVersionNumber(Long objectVersionNumber); } 实现类 TaskServiceImpl.java package com.hand.todo.demo.service.impl; import com.hand.hap.cloud.mybatis.service.BaseServiceImpl; import com.hand.hap.cloud.resource.exception.HapException; import com.hand.todo.demo.domain.TodoTask; import com.hand.todo.demo.service.TaskService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.List; /** * Created by ziling.zhong on 2017/7/5. */ @Service @Transactional(rollbackFor = HapException.class) public class TaskServiceImpl extends BaseServiceImpl implements TaskService { @Override public TodoTask findByTaskNumber(String taskNumber) { TodoTask task = new TodoTask(); task.setTaskNumber(taskNumber); List tasks = select(task); if (!tasks.isEmpty()) { return tasks.get(0); } return null; } @Override public int delete(Long id) { TodoTask task = selectByPrimaryKey(id); if (task == null) { throw new HapException(\"error.todoTask.taskNumberExist\"); } return deleteByPrimaryKey(id); } @Override public int deleteByTaskNumber(String taskNumber) { TodoTask task = findByTaskNumber(taskNumber); if (task == null) { throw new HapException(\"error.todoTask.taskNumberExist\"); } return delete(task); } @Override public TodoTask create(TodoTask task) throws HapException { if (findByTaskNumber(task.getTaskNumber()) != null) { throw new HapException(\"error.todoTask.taskNumberExist\"); } if (insert(task) != 1) { throw new HapException(\"error.todoTask.insertNotOne\"); } return selectByPrimaryKey(task.getId()); } @Override public TodoTask update(Long id TodoTask task) { TodoTask oldTask = selectByPrimaryKey(id); if (oldTask == null) { throw new HapException(\"error.todoTask.notFound\"); } String taskNumber = task.getTaskNumber(); if (taskNumber != null && !oldTask.getTaskNumber().equals(taskNumber) && findByTaskNumber(taskNumber) != null) { throw new HapException(\"error.todoTask.taskNumberExist\"); } task.setId(id); if (updateByPrimaryKeySelective(task) != 1) { throw new HapException(\"error.client.update\"); } return selectByPrimaryKey(id); } @Override public List findByTaskVersionNumber(Long objectVersionNumber) { TodoTask task = new TodoTask(); task.setObjectVersionNumber(objectVersionNumber); List tasks = select(task); return tasks; } } "},"/zh/docs/development-guide/backend/demo/swagger":{"url":"zh/docs/development-guide/backend/demo/swagger","title":"swagger测试","date":"2017-02-01","language":"zh","body":"swagger测试 Eureka服务发现 如果上述步骤执行无误，可在本地的 http://localhost:8000/ 查看注册成功的服务:HAP-OAUTH-SERVER HAP-API-GATEWAY-TEST HAP-DEMO-SERVICE-TODO; swagger Api服务 打开 http://localhost:8080/swagger-ui.html 打开任意一个api，点击右边红色的叹号对调用该api进行授权 在弹出界面输入用户名密码，本地默认为admin/admin 在这里便可以对controller中声明的api进行测试 "},"/zh/docs/development-guide/backend/demo/test":{"url":"zh/docs/development-guide/backend/demo/test","title":"编写测试用例","date":"2017-02-01","language":"zh","body":"编写测试用例 Mapper测试 @SpringBootTest:指定执行测试的SpringBootApplication TodoTaskMapperTest 代码 package com.hand.hap.cloud.todo.demo.mapper; import com.hand.hap.cloud.resource.exception.HapException; import com.hand.todo.demo.TodoServiceApplication; import com.hand.todo.demo.domain.TodoTask; import com.hand.todo.demo.mapper.TodoTaskMapper; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.transaction.annotation.Transactional; import java.util.Date; /** * Created by ziling.zhong on 2017/7/5. */ @RunWith(SpringRunner.class) @SpringBootTest(classes = TodoServiceApplication.class) @Transactional public class TodoTaskMapperTest { @Autowired(required = false) private TodoTaskMapper taskMapper; private static TodoTask todoTask; private static Long employId; private static String taskNumber; private static String taskDescription; public static void taskSetValue() { todoTask.setEmployeeId(employId); todoTask.setTaskNumber(taskNumber); todoTask.setTaskDescription(taskDescription); } //插入todoTask @Test public void test1Insert() { todoTask = new TodoTask(); employId = new Long(1); taskNumber = \"test-\" + new Date().getTime(); taskDescription = \"testInsert\"; taskSetValue(); //插入数据 if (taskMapper.insertSelective(todoTask) != 1) { throw new HapException(\"error.client.insert\"); } todoTask = taskMapper.selectByPrimaryKey(todoTask.getId()); Assert.assertEquals(employId todoTask.getEmployeeId()); Assert.assertEquals(taskNumber todoTask.getTaskNumber()); Assert.assertEquals(taskDescription todoTask.getTaskDescription()); } //更新todoTask @Test public void test2Update() { test1Insert(); employId = new Long(2); taskNumber = \"test-\" + new Date().getTime(); taskDescription = \"testUpdate\"; taskSetValue(); if (taskMapper.updateByPrimaryKeySelective(todoTask) != 1) { throw new HapException(\"error.client.update\"); } todoTask = taskMapper.selectByPrimaryKey(todoTask.getId()); Assert.assertEquals(employId todoTask.getEmployeeId()); Assert.assertEquals(taskNumber todoTask.getTaskNumber()); Assert.assertEquals(taskDescription todoTask.getTaskDescription()); } //删除todoTask @Test public void test99Delete() { test1Insert(); if (taskMapper.deleteByPrimaryKey(todoTask.getId()) != 1) { throw new HapException(\"error.client.delete\"); } Assert.assertNull(taskMapper.selectByPrimaryKey(todoTask.getId())); } } TodoServiceTest package com.hand.hap.cloud.todo.demo.service; import com.hand.hap.cloud.resource.exception.HapException; import com.hand.todo.demo.TodoServiceApplication; import com.hand.todo.demo.domain.TodoTask; import com.hand.todo.demo.service.TaskService; import org.junit.Assert; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.transaction.annotation.Transactional; import java.util.Date; import java.util.List; /** * Created by ziling.zhong on 2017/7/5. */ @RunWith(SpringRunner.class) @SpringBootTest(classes = TodoServiceApplication.class) @Transactional public class TodoServiceTest { @Autowired private TaskService taskService; private static TodoTask todoTask; private static String taskNumber; private static Long employId; private static String taskDescription; public static void taskSetValue() { todoTask.setEmployeeId(employId); todoTask.setTaskNumber(taskNumber); todoTask.setTaskDescription(taskDescription); } @Test public void test1Create() { todoTask = new TodoTask(); taskNumber = \"test-\" + new Date().getTime(); employId = new Long(1); taskDescription = \"testInsert\"; String taskState = \"testState\"; taskSetValue(); todoTask.setState(taskState); //创建后数据会回写，最终调用insertSelective(T) if (taskService.create(todoTask) == null) { throw new HapException(\"error.client.create\"); } todoTask = taskService.selectByPrimaryKey(todoTask.getId()); Assert.assertEquals(employId todoTask.getEmployeeId()); Assert.assertEquals(taskNumber todoTask.getTaskNumber()); Assert.assertEquals(taskDescription todoTask.getTaskDescription()); Assert.assertEquals(taskState todoTask.getState()); } @Test public void test2FindByTaskNumber() { test1Create(); todoTask = taskService.findByTaskNumber(todoTask.getTaskNumber()); Assert.assertEquals(employId todoTask.getEmployeeId()); Assert.assertEquals(taskNumber todoTask.getTaskNumber()); Assert.assertEquals(taskDescription todoTask.getTaskDescription()); } @Test public void test3FindByVersionNumber() { for (int i = 0; i todoTasks = taskService.findByTaskVersionNumber(new Long(1)); Assert.assertFalse(todoTasks.isEmpty()); } @Test public void test4Update() { test1Create(); todoTask = taskService.selectByPrimaryKey(todoTask.getId()); taskNumber = \"testService2-\" + new Date().getTime(); taskDescription = \"testServiceUpdate2\"; employId = new Long(2); taskSetValue(); if (taskService.updateByPrimaryKeySelective(todoTask) != 1) { throw new HapException(\"error.client.update\"); } todoTask = taskService.selectByPrimaryKey(todoTask.getId()); Assert.assertEquals(employId todoTask.getEmployeeId()); Assert.assertEquals(taskNumber todoTask.getTaskNumber()); Assert.assertEquals(taskDescription todoTask.getTaskDescription()); } @Test public void test99Delete() { test1Create(); Assert.assertNotNull(taskService.selectByPrimaryKey(todoTask.getId())); if (taskService.deleteByPrimaryKey(todoTask.getId()) != 1) { throw new HapException(\"error.client.delete\"); } Assert.assertNull(taskService.selectByPrimaryKey(todoTask.getId())); } @Test public void test999DeleteByTaskNumber() { test1Create(); Assert.assertNotNull(taskService.selectByPrimaryKey(todoTask.getId())); if (taskService.deleteByTaskNumber(todoTask.getTaskNumber()) != 1) { throw new HapException(\"error.client.delete\"); } Assert.assertNull(taskService.selectByPrimaryKey(todoTask.getId())); } } controller测试 BaseControllerTest package com.hand.hap.cloud.todo.demo.controller; import com.fasterxml.jackson.databind.ObjectMapper; import com.hand.todo.demo.TodoServiceApplication; import org.junit.Before; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.http.HttpRequest; import org.springframework.http.client.ClientHttpRequestExecution; import org.springframework.http.client.ClientHttpRequestInterceptor; import org.springframework.http.client.ClientHttpResponse; import org.springframework.test.context.junit4.SpringRunner; import java.io.IOException; /** * Created by chang on 2017/5/20. */ @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT classes = TodoServiceApplication.class) public abstract class BaseControllerTest { private final static String TOKEN = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\" + \".eyJwYXNzd29yZCI6InVua25vd24gcGFzc3dvcmQiLCJ1c2VybmFtZSI6ImFkbWl\" + \"uIiwiYXV0aG9yaXRpZXMiOltdLCJhY2NvdW50Tm9uRXhwaXJlZCI6dHJ1ZSwiYWN\" + \"jb3VudE5vbkxvY2tlZCI6dHJ1ZSwiY3JlZGVudGlhbHNOb25FeHBpcmVkIjp0cnV\" + \"lLCJlbmFibGVkIjp0cnVlLCJ1c2VySWQiOjEsInRpbWVab25lIjoiQ1RUIiwibGF\" + \"uZ3VhZ2UiOiJ6aF9DTiIsIm9yZ2FuaXphdGlvbklkIjoxLCJwcm9qZWN0SWQiOjE\" + \"sImFkZGl0aW9uSW5mbyI6bnVsbH0.g2kWetvUZTytG-umdGm1JKiAvAb9RV6B7Dy\" + \"44ef9qRI\"; private static boolean first = true; @Autowired protected TestRestTemplate restTemplate; protected final static ObjectMapper MAPPER = new ObjectMapper(); @Before public void before() { if (first) { restTemplate.getRestTemplate().getInterceptors().add(new OAuthAuthorizationInterceptor(TOKEN)); first = false; } } class OAuthAuthorizationInterceptor implements ClientHttpRequestInterceptor { private final String token; private OAuthAuthorizationInterceptor(String token) { this.token = token; } public ClientHttpResponse intercept(HttpRequest request byte[] body ClientHttpRequestExecution execution) throws IOException { request.getHeaders().add(\"Authorization\" \"Bearer \" + token); return execution.execute(request body); } } } TaskControllerTest package com.hand.hap.cloud.todo.demo.controller; import com.hand.todo.demo.domain.TodoTask; import org.junit.Assert; import org.junit.FixMethodOrder; import org.junit.Test; import org.junit.runners.MethodSorters; import org.springframework.http.HttpStatus; import java.util.Date; import java.util.List; import java.util.Map; /** * Created by ziling.zhong on 2017/7/5. */ @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class TaskControllerTest extends BaseControllerTest { private static TodoTask target; @Test public void test1Create() throws Exception { TodoTask todoTask = new TodoTask(); String taskNumber = \"testController\" + new Date().getTime(); Long employId = new Long(1); String taskDescription = \"testControllerInsert\"; String taskState = \"taskState\"; todoTask.setEmployeeId(employId); todoTask.setTaskNumber(taskNumber); todoTask.setTaskDescription(taskDescription); todoTask.setState(taskState); target = restTemplate.postForEntity(\"/v1/todoTask/create\" todoTask TodoTask.class).getBody(); Assert.assertEquals(employId target.getEmployeeId()); Assert.assertEquals(taskNumber target.getTaskNumber()); Assert.assertEquals(taskDescription target.getTaskDescription()); Assert.assertEquals(taskState target.getState()); } @Test public void test2FindByNumber() throws Exception { TodoTask todoTask = restTemplate.getForEntity(\"/v1/todoTask/findByNumber/{taskNumber}\" TodoTask.class target.getTaskNumber()).getBody(); Assert.assertEquals(todoTask.getEmployeeId() target.getEmployeeId()); Assert.assertEquals(todoTask.getTaskNumber() target.getTaskNumber()); Assert.assertEquals(todoTask.getTaskDescription() target.getTaskDescription()); } //由于TodoTask类继承AuditDomain基类，在更新数据通过Controller层调用时会进行审计，其它层不用考虑 //此时在提交的数据target中必须包含objectVersionNumber字段，并给该字段赋予数据库中的数据。 @Test public void test3Update() throws Exception { target.setState(\"Yes\"); //更新数据 restTemplate.put(\"/v1/todoTask/{id}\" target target.getId()); TodoTask todoTask = restTemplate.getForEntity(\"/v1/todoTask/findByNumber/{taskNumber}\" TodoTask.class target.getTaskNumber()).getBody(); Assert.assertEquals(target.getState() todoTask.getState()); } @Test public void test4FindByVersionNumber() throws Exception { Map result = restTemplate.getForEntity(\"/v1/todoTask/findByVersionNumber/{objectVersionNumber}\" Map.class target.getObjectVersionNumber()).getBody(); Assert.assertFalse(result.isEmpty()); Assert.assertNotNull(result.get(\"tasks\")); } // @Test // public void test4FindByVersionNumber() throws Exception { // List result = restTemplate.getForEntity(\"/v1/todoTask/findByVersionNumber/{objectVersionNumber}\" List.class target.getObjectVersionNumber()).getBody(); // Assert.assertFalse(result.isEmpty()); // } @Test public void test99DeleteById() throws Exception { restTemplate.delete(\"/v1/todoTask/{id}\" target.getId()); HttpStatus status = restTemplate.getForEntity(\"/v1/todoTask/findByNumber/{taskNumber}\" TodoTask.class target.getTaskNumber()).getStatusCode(); Assert.assertEquals(HttpStatus.BAD_REQUEST status); } @Test public void test999DeleteByNumber() throws Exception { test1Create(); restTemplate.delete(\"/v1/todoTask/taskNumber/{taskNumber}\" target.getTaskNumber()); HttpStatus status = restTemplate.getForEntity(\"/v1/todoTask/findByNumber/{taskNumber}\" TodoTask.class target.getTaskNumber()).getStatusCode(); Assert.assertEquals(HttpStatus.BAD_REQUEST status); } } 目录结构 运行测试 mvn clean compile test -DskipTests=false "},"/zh/docs/development-guide/backend/develop_env/":{"url":"zh/docs/development-guide/backend/develop_env/","title":"开发环境配置","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/develop_env/install-linux":{"url":"zh/docs/development-guide/backend/develop_env/install-linux","title":"软件安装(Linux)","date":"2017-02-01","language":"zh","body":"软件安装(以Ubuntu为例) 开发工具 Git JDK 1.8.0 及以上 maven 3.3 及以上 Docker for Ubuntu IntelliJ IDEA Mysql Rabbit MQ Redis Phpmyadmin (可选) Visual Studio Code (可选) 更新源 在命令行里输入sudo apt-get update，回车。 Git 安装 在命令行输入sudo apt-get install git 安装完成后在命令行执行 git version命令 ，输出Git版本信息则安装成功。 配置 curl -o ~/.gitconfig -SL https://raw.githubusercontent.com/carllhw/dotfiles/master/.gitconfig-others # 请将下面命令按实际情况进行执行 git config --global user.name \"Your Name\" git config --global user.email \"Your Email\" Java 安装 在命令行中输入sudo apt-get install openjdk-8-jdk，回车安装jdk 安装完成后在命令行执行 java -version命令 ，输出Java版本信息则安装成功。 Maven 安装 在命令行输入sudo apt-get install maven，回车安装maven 安装完成后打开 git bash 执行 mvn -v ，有提示则说明环境安装成功。 Docker安装 若电脑有旧版的docker，请执行sudo apt-get remove docker docker-engine docker.io，将其删除 依次执行以下指令，安装docker $ sudo apt-get update $ sudo apt-get install \\ linux-image-extra-$(uname -r) \\ linux-image-extra-virtual $ sudo apt-get update $ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" $ sudo apt-get update $ sudo apt-get install docker-ce $ sudo gpasswd -a ${USER} docker # 将当前用户加入docker组，避免每次使用docker指令都得使用sudo $ docker version # 验证是否安装成功 $ sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose # 安装docker-compose $ sudo chmod +x /usr/local/bin/docker-compose $ docker-compose --version # 验证安装时否成功 Note. 注意机器必须开启虚拟化支持，部分机型默认禁用，需进入bios进行设置，因各机型设置不相一致，在此不做详细说明 IntelliJ IDEA 安装配置 在 IDEA官网 下载与本机系统相符的安装包。 解压 进入解压出的文件夹里的bin文件夹，使用命令行运行./idea.sh Idea配置 安装Docker插件。在File-Settings-Plugins中，搜索Docker integration，点击Install安装，并重启软件加载插件。 因网络原因，可能导致下载失败，若一直不能下载成功，可跳过Idea关于Docker的相关配置步骤，在下方关于Docker容器启动方式选择第二种——Docker-Compose IDEA中配置Docker，在File-Settings-Build Execution Deployment-Clouds中，点击加号新建，会自动读取docker信息，直接保存即可。 克隆代码 克隆代码到本地 使用 git clone https://rdc.hand-china.com/gitlab/HAPCloud/HAPCloudBackend.git 将项目 clone 到本地 进入项目中执行git submodule update --init --recursive命令将所有后端子模块初始化。 导入项目到IDEA开发工具中 打开已安装好的IDEA开发工具，将clone到本地的项目导入到开发工具IDEA中，会自动下载依赖包。 因为各模块分离，故而可通过idea的File > Project Structure添加module 服务环境准备 准备 在~/Docker/mysql下新建mysql_data文件夹，同时新建一个mysql_db.cnf文件，内容如下 [mysqld] lower_case_table_names=1 character_set_server=utf8 max_connections=500 也可在其他位置创建，但需注意与下方使用该配置文件时的路径相对应。 安装 首先，打开cmd或者powershell分别执行以下指令，对所需的Docker镜像进行拉取。 docker pull registry.saas.hand-china.com/tools/mysql:5.7.17 docker pull registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management docker pull registry.saas.hand-china.com/tools/redis docker pull registry.saas.hand-china.com/tools/phpmyadmin 启动Docker容器 以下两种方式任选一种进行 1. Idea启动Docker MySQL配置 Name: mysql Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/mysql:5.7.17 Container name: mysql Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 3306 | tcp | | 3306 Volume bindings Container Path | Host path | Read only ---|---|--- /var/lib/mysql | /home/用户名/Docker/mysql/mysql_data | /etc/mysql/conf.d/mysql_db.cnf | /home/用户名/Docker/mysql/mysql_db.cnf | 用户名请以当前用户名替代。 Host path 可以根据自己需求自己选择映射位置，第一项为mysql的数据存放文件夹，第二项为mysql的配置文件，请确保确映射类型对应且必须存在。 Environment variables Name | value ---|--- MYSQL_ROOT_PASSWORD | root Rabbit MQ配置 Name: rabbitmq Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management Container name: rabbitmq Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 15672 | tcp | | 15672 5672 | tcp | | 5672 Redis配置 Name: redis Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/redis Container name: redis Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 6379 | tcp | | 6379 phpadmin Name: phpadmin Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/phpmyadmin Container name: phpadmin Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 80 | tcp | | 80 Environment variables Name | value ---|--- PMA_ARBITRARY | 1 2. 通过docker-compose来启动docker 在~/Docker目录下新建docker-compose.yml文件内容如下: version: \"3\" services: mysql: container_name: mysql # 容器名 image: registry.saas.hand-china.com/tools/mysql:5.7.17 # 容器所使用的镜像，镜像形式为[username 或 url]/repository:tag，该镜像为公司搭设的docker仓库内的镜像 ports: - \"3306:3306\" # [本机端口:容器内端口] 将本机端口与docker容器内部应用的端口映射，以提供外部对容器内应用的访问能力 environment: MYSQL_ROOT_PASSWORD: root # 设置mysql密码 volumes: - ./mysql/mysql_data:/var/lib/mysql # 将mysql中的数据文件映射到本机文件夹，\":\"前的为本机地址，后的为容器内地址 - ./mysql/mysql_db.cnf:/etc/mysql/conf.d/mysql_db.cnf # 将mysql的配置文件映射到本机文件 rabbitmq: container_name: rabbitmq image: registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management ports: - \"15672:15672\" - \"5672:5672\" redis: container_name: redis image: registry.saas.hand-china.com/tools/redis ports: - \"6379:6379\" phpadmin: container_name: phpadmin image: registry.saas.hand-china.com/tools/phpmyadmin ports: - \"80:80\" # 80端口方便浏览器直接访问 environment: PMA_ARBITRARY: 1 # 用于开启phpadmin关于可否输入host的设置 通过命令行进入~/Docker目录下，执行docker-compose up -d启动docker服务，通过docker ps查看容器是否启动。若需要停止，同样在该目录下执行docker-compose down 有关Docker的更多信息请见此处 有关Docker-Compose的更多信息请见此处 Visual Studio Code (可选) 1.在 vscode 官网 下载对应平台的安装包。 2.本地执行安装文件，安装。 VSCode配置 文件 > 首选项 > 设置 // Place your settings in this file to overwrite the default settings { \"files.eol\": \"\\n\" \"editor.formatOnSave\": true } "},"/zh/docs/development-guide/backend/develop_env/install-macOS":{"url":"zh/docs/development-guide/backend/develop_env/install-macOS","title":"软件安装(macOS)","date":"2017-02-01","language":"zh","body":"软件安装(以macOS High Sierra为例) 开发工具 brew Git JDK 1.8.0 及以上 maven 3.3 及以上 Docker for Mac IntelliJ IDEA 2017.2 Mysql Rabbit MQ Redis Phpmyadmin (可选) Visual Studio Code (可选) 安装brew软件包管理工具 在命令行里输入以下命令，回车。 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Git 安装 macOS中已预装Git，可跳过此步骤也可执行以下命令进行Git版本升级。 在命令行输入brew install git，回车安装Git。 安装完成后在命令行执行 git version命令 ，输出Git版本信息则安装成功。 配置 curl -o ~/.gitconfig -SL https://raw.githubusercontent.com/carllhw/dotfiles/master/.gitconfig-others # 请将下面命令按实际情况进行执行 git config --global user.name \"Your Name\" git config --global user.email \"Your Email\" Java 安装 在命令行中输入brew cask install java，回车安装Jdk。 安装完成后在命令行执行 java -version命令 ，输出Java版本信息则安装成功。 Maven 安装 在命令行输入brew install maven，回车安装Maven。 安装完成后在命令行执行 mvn -v命令 ，输出Maven版本信息则安装成功。 Docker安装 在命令行输入brew cask install docker，回车安装Docker。 Docker安装完成后，请点击Docker应用图标运行Docker。 运行后在命令行执行 docker version命令 ，输出Docker版本信息则安装成功。 安装docker-composesudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose # 验证安装时否成功 docker-compose --version IntelliJ IDEA 安装配置 在命令行输入brew cask install intellij-idea，回车安装IntelliJ IDEA。 Idea配置 安装Docker插件。在IntelliJ IDEA > Preferences > Plugins中，搜索Docker integration，点击Install安装，并重启软件加载插件。 因网络原因，可能导致下载失败，若一直不能下载成功，可跳过Idea关于Docker的相关配置步骤，在下方关于Docker容器启动方式选择第二种——Docker-Compose IDEA中配置Docker，在IntelliJ IDEA > Preferences > Build Execution Deployment > Docker中，点击加号新建，会自动读取docker信息，直接保存即可。 克隆代码 克隆代码到本地 在命令行输入 git clone https://rdc.hand-china.com/gitlab/HAPCloud/HAPCloudBackend.git 将项目 clone 到本地 进入项目中执行git submodule update --init --recursive命令将所有后端子模块初始化。 导入项目到IDEA开发工具中 打开已安装好的IDEA开发工具，将clone到本地的项目导入到开发工具IDEA中，会自动下载依赖包。 因为各模块分离，故而可通过IDEA的菜单File > Project Structure添加module 服务环境准备 准备 在~/Docker/mysql下新建mysql_data文件夹，同时新建一个mysql_db.cnf文件，内容如下 [mysqld] lower_case_table_names=1 character_set_server=utf8 max_connections=500 也可在其他位置创建，但需注意与下方使用该配置文件时的路径相对应。 安装 以下是开发中会用到的镜像，执行以下命令进行镜像拉取；也可跳过此步，因为IDEA启动Docker容器和使用docker-compose来启动Docker容器都会自动拉取镜像。 docker pull registry.saas.hand-china.com/tools/mysql:5.7.17 docker pull registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management docker pull registry.saas.hand-china.com/tools/redis docker pull registry.saas.hand-china.com/tools/phpmyadmin 启动Docker容器 以下两种方式任选一种进行 1. Idea启动Docker MySQL配置 Name: mysql Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/mysql:5.7.17 Container name: mysql Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 3306 | tcp | | 3306 Volume bindings Container Path | Host path | Read only ---|---|--- /var/lib/mysql | /Users/用户名/Docker/mysql/mysql_data | /etc/mysql/conf.d/mysql_db.cnf | /Users/用户名/Docker/mysql/mysql_db.cnf | 用户名请以当前用户名替代。 Host path 可以根据自己需求自己选择映射位置，第一项为mysql的数据存放文件夹，第二项为mysql的配置文件，请确保确映射类型对应且必须存在。 Environment variables Name | value ---|--- MYSQL_ROOT_PASSWORD | root Rabbit MQ配置 Name: rabbitmq Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management Container name: rabbitmq Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 15672 | tcp | | 15672 5672 | tcp | | 5672 Redis配置 Name: redis Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/redis Container name: redis Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 6379 | tcp | | 6379 phpadmin Name: phpadmin Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/phpmyadmin Container name: phpadmin Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 80 | tcp | | 80 Environment variables Name | value ---|--- PMA_ARBITRARY | 1 2. 通过docker-compose来启动docker 在~/Docker目录下新建docker-compose.yml文件内容如下: version: \"3\" services: mysql: container_name: mysql # 容器名 image: registry.saas.hand-china.com/tools/mysql:5.7.17 # 容器所使用的镜像，镜像形式为[username 或 url]/repository:tag，该镜像为公司搭设的docker仓库内的镜像 ports: - \"3306:3306\" # [本机端口:容器内端口] 将本机端口与docker容器内部应用的端口映射，以提供外部对容器内应用的访问能力 environment: MYSQL_ROOT_PASSWORD: root # 设置mysql密码 volumes: - ./mysql/mysql_data:/var/lib/mysql # 将mysql中的数据文件映射到本机文件夹，\":\"前的为本机地址，后的为容器内地址 - ./mysql/mysql_db.cnf:/etc/mysql/conf.d/mysql_db.cnf # 将mysql的配置文件映射到本机文件 rabbitmq: container_name: rabbitmq image: registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management ports: - \"15672:15672\" - \"5672:5672\" redis: container_name: redis image: registry.saas.hand-china.com/tools/redis ports: - \"6379:6379\" phpadmin: container_name: phpadmin image: registry.saas.hand-china.com/tools/phpmyadmin ports: - \"80:80\" # 80端口方便浏览器直接访问 environment: PMA_ARBITRARY: 1 # 用于开启phpadmin关于可否输入host的设置 通过命令行进入~/Docker目录下，执行docker-compose up -d启动docker服务，通过docker ps查看容器是否启动。若需要停止，同样在该目录下执行docker-compose down 有关Docker的更多信息请见此处 有关Docker-Compose的更多信息请见此处 Visual Studio Code (可选) 1.在 vscode 官网 下载对应平台的安装包 也可以执行brew cask install visual-studio-code命令进行安装。 VSCode配置 Code > 首选项 > 设置 // Place your settings in this file to overwrite the default settings { \"files.eol\": \"\\n\" \"editor.formatOnSave\": true } "},"/zh/docs/development-guide/backend/develop_env/install-windows":{"url":"zh/docs/development-guide/backend/develop_env/install-windows","title":"软件安装(Windows)","date":"2017-02-01","language":"zh","body":"软件安装 开发工具 Git JDK 1.8.0 及以上 maven 3.3 及以上 Docker for Windows IntelliJ IDEA Mysql Rabbit MQ Redis Phpmyadmin (可选) Visual Studio Code (可选) Git 安装 在 Git 官网 下载对应平台的 Git。 本地执行安装文件，安装 Git 环境。 配置完成后打开 git bash 执行 git ，有提示则说明环境安装成功。 配置 curl -o ~/.gitconfig -SL https://raw.githubusercontent.com/carllhw/dotfiles/master/.gitconfig-others # 请将下面命令按实际情况进行执行 git config --global user.name \"Your Name\" git config --global user.email \"Your Email\" Java 安装 在 Oracle 官网 下载对应平台的 JDK 1.8.0 以上的环境。 本地执行安装文件，安装 JDK 环境。 Win 在环境变量系统变量中 path 配置 JDK 的环境变量指向 JDK 安装目录下 JDK/bin，并配置环境变量 JAVA_HOME。 配置完成后打开 git bash 执行 java ，有提示则说明环境安装成功。(git bash执行会有乱码，cmd则正常) Maven 安装 在 Maven 官网 下载对应平台的合适的 maven 版本的压缩包。 本地解压压缩包。 Win 在环境变量中系统变量的 path 配置 maven 的环境变量指向 maven 解压目录下的 /bin 。 配置完成后打开 git bash 执行 mvn -v ，有提示则说明环境安装成功。 Docker for Windows 安装 在 Docker for Windows 下载安装包 本地执行安装文件，安装Docker 启动Docker，然后会提示启用Hyper-V需要重启 重启后Docker会自动启动 打开 git bash 执行 docker --version ，有提示则说明环境安装成功。 Note. 注意要使用Docker for Windows，机器必须开启虚拟化支持，部分机型默认禁用，需进入bios进行设置，因各机型设置不相一致，在此不做详细说明 Docker配置 IntelliJ IDEA 安装配置 在 IDEA官网 下载与本机系统相符的安装包，并安装。 Idea配置 菜单栏File > Setting打开设置 Editor > Code Style > Line separator (for new lines): Unix and OS X (n) 确保idea使用utf-8编码 安装Docker插件。在File-Settings-Plugins中，搜索Docker integration，点击Install安装，并重启软件加载插件。 因网络原因，可能导致下载失败，若一直不能下载成功，可跳过Idea关于Docker的相关配置步骤，在下方关于Docker容器启动方式选择第二种——docker-compose IDEA中配置Docker，在File-Settings-Build Execution Deployment-Clouds中，点击加号新建，会自动读取docker信息，直接保存即可。 克隆代码 克隆代码到本地 使用 git clone https://rdc.hand-china.com/gitlab/HAPCloud/HAPCloudBackend.git 将项目 clone 到本地 进入项目中执行git submodule update --init --recursive命令将所有后端子模块初始化。 导入项目到IDEA开发工具中 打开已安装好的IDEA开发工具，将clone到本地的项目导入到开发工具IDEA中，会自动下载依赖包。 因为各模块分离，故而可通过idea的File > Project Structure添加各模块 服务环境准备 准备 在E:\\Docker\\mysql下新建mysql_data文件夹，同时新建一个mysql_db.cnf文件，内容如下 [mysqld] lower_case_table_names=1 character_set_server=utf8 max_connections=500 也可在其他位置创建，但需注意与下方使用该配置文件时的路径相对应。 注意：因为要将docker容器中的mysql文件映射到本机上，若使用docker for windows，需要通过右键系统菜单栏的docker图标 > settings > Shared Drives 对卷绑定的驱动盘进行勾选 安装 首先，打开cmd或者powershell分别执行以下指令，对所需的Docker镜像进行拉取。 docker pull registry.saas.hand-china.com/tools/mysql:5.7.17 docker pull registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management docker pull registry.saas.hand-china.com/tools/redis docker pull registry.saas.hand-china.com/tools/phpmyadmin 启动Docker容器 以下两种方式任选一种进行 1. Idea启动Docker MySQL配置 Name: mysql Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/mysql:5.7.17 Container name: mysql Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 3306 | tcp | | 3306 Volume bindings Container Path | Host path | Read only ---|---|--- /var/lib/mysql | E:/Docker/mysql/mysql_data | /etc/mysql/conf.d/mysql_db.cnf | E:/Docker/mysql/mysql_db.cnf | Host path 可以根据自己需求自己选择映射位置，第一项为mysql的数据存放文件夹，第二项为mysql的配置文件，请确保确映射类型对应且必须存在。 Environment variables Name | value ---|--- MYSQL_ROOT_PASSWORD | root Rabbit MQ配置 Name: rabbitmq Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management Container name: rabbitmq Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 15672 | tcp | | 15672 5672 | tcp | | 5672 Redis配置 Name: redis Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/redis Container name: redis Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 6379 | tcp | | 6379 phpadmin Name: phpmyadmin Docker Deployment Server: Docker Deployment: Docker Image Image ID: registry.saas.hand-china.com/tools/phpmyadmin Container name: phpmyadmin Docker Container Port bindings Container Port | Protocol | Host IP | Host Port ---|---|---|--- 80 | tcp | | 80 Environment variables Name | value ---|--- PMA_ARBITRARY | 1 2. 通过docker-compose来启动docker 在E:\\Docker新建docker-compose.yml文件内容如下: version: \"3\" services: mysql: container_name: mysql # 容器名 image: registry.saas.hand-china.com/tools/mysql:5.7.17 # 容器所使用的镜像，镜像形式为[username 或 url]/repository:tag，该镜像为公司搭设的docker仓库内的镜像 ports: - \"3306:3306\" # [本机端口:容器内端口] 将本机端口与docker容器内部应用的端口映射，以提供外部对容器内应用的访问能力 environment: MYSQL_ROOT_PASSWORD: root # 设置mysql密码 volumes: - ./mysql/mysql_data:/var/lib/mysql # 将mysql中的数据文件映射到本机文件夹，\":\"前的为本机地址，后的为容器内地址 - ./mysql/mysql_db.cnf:/etc/mysql/conf.d/mysql_db.cnf # 将mysql的配置文件映射到本机文件 rabbitmq: container_name: rabbitmq image: registry.saas.hand-china.com/tools/rabbitmq:3.6.1-management ports: - \"15672:15672\" - \"5672:5672\" redis: container_name: redis image: registry.saas.hand-china.com/tools/redis ports: - \"6379:6379\" phpadmin: container_name: phpadmin image: registry.saas.hand-china.com/tools/phpmyadmin ports: - \"80:80\" # 80端口方便浏览器直接访问 environment: PMA_ARBITRARY: 1 # 用于开启phpadmin关于可否输入host的设置 启动cmd或powershell，通过cd命令跳转至E:\\Docker目录下，执行docker-compose.exe up -d启动docker服务，通过docker ps查看容器是否启动。若需要停止，同样在该目录下执行docker-compose.exe down 有关Docker的更多信息请见此处 有关Docker-Compose的更多信息请见此处 Visual Studio Code (可选) 1.在 vscode 官网 下载对应平台的安装包。 2.本地执行安装文件，安装。安装时可以选择 添加到PATH，重启后可以在Git Bash直接用code命令来打开目录或文件。 VSCode配置 文件 > 首选项 > 设置 // Place your settings in this file to overwrite the default settings { \"files.eol\": \"\\n\" \"editor.formatOnSave\": true } 导入安全证书到JDK 1.获取需要的安全证书的网页URL 然后在浏览器中打开 2.在浏览器中右击检查，然后选中 security 点击 View Certificate 3.从上述步骤进入证书之后，点击详细信息，然后复制到文件 4.然后依次按着向导导出证书到本地，导出成功后如下图 5.从证书的位置右击进入命令窗口，执行命令: keytool -import -v -trustcacerts -alias test2 -file test2.cer -storepass changeit -keystore \"%JAVA_HOME%/jre/lib/security/cacerts\" 注：此处文件名称需要改为自己本地证书的名称 6.上述命令执行完成后会提示是否信任此证书，输入 Y 证书将被添加进JDK "},"/zh/docs/development-guide/backend/event/":{"url":"zh/docs/development-guide/backend/event/","title":"数据一致性支持","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/event/base":{"url":"zh/docs/development-guide/backend/event/base","title":"整体架构","date":"2017-11-17","language":"zh","body":" 流程 业务服务A在事务提交前，通过实时事件服务向事件系统请求发送事件，事件系统只记录事件并不真正发送。 业务服务A在提交后，通过实时事件服务向事件系统确认发送，事件得到确认后事件系统才真正发布事件到消息代理。业务服务B在消息代理中拿到消息并消费 业务服务A在业务回滚时，通过实时事件向事件系统取消事件。 如果业务服务A在发送确认或取消之前停止服务了，事件系统的事件恢复服务会定期找到未确认发送的事件向业务服务查询状态，根据业务服务A返回的状态决定事件是要发布还是取消。 三部分 业务服务A：封装了hap-event-helper方便使用 事件系统：实现了hap-event-store-service 业务服务B：封装了hap-event-consume-helper方便使用 完整demo hap-event-demo-parent "},"/zh/docs/development-guide/backend/event/event_store":{"url":"zh/docs/development-guide/backend/event/event_store","title":"事件系统","date":"2017-11-17","language":"zh","body":" 共支持四种消息队列: kafka rabbitmq rocketmq redis的pub/sub 克隆项目 git clone https://rdc.hand-china.com/gitlab/HAPCloud/hap-event-store-service.git 创建用户和数据库 进入MySQL命令行，执行以下命令 CREATE USER 'hapcloud'@'%' IDENTIFIED BY \"handhand\"; CREATE DATABASE hap_event_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON hap_event_service.* TO hapcloud@'%'; FLUSH PRIVILEGES; 初始化数据库 Linux/Mac 用户直接执行以下命令 Windows 用户使用 git bash 或其他类 bash 环境执行 sh init-local-database.sh 配置使用的消息队列类型 修改EventStoreApplication上的@MessageQueue(QueueType.kafka)。 支持kafka rabbitmq rocketmq redis的pub/sub四种 接口使用 创建事件 接口: POST /v1/events/ 参数: Event的json形式 返回值: Event的uuid(string类型) Event实体内容： public class Event { private String uuid; private String type; //发布事件的服务的serviceId 例如hap-user-service private String publisherServiceId; private List messages; public static class Message { /** * 要发送给消息队列的通道名 */ private String topicName; /** * 要发送给消息队列的消息内容(json格式) */ private String payload; } } 确认事件：业务服务执行完毕，向本服务发送确认事件请求 接口: PUT /v1/events/{eventId}/confirm 取消事件：业务服务执行失败，回滚事务，并向本服务发送取消事件请求 接口: PUT /v1/events/{eventId}/cancel 向业务服务接口查询事件状态：会根据创建Event的publisherServiceI向业务接口查询事件状态. 业务服务需要提供的接口为GET /v1/api/eventRecords/{eventId}/{type} 查询接口返回值应为两种 1. **finished**: 事件已完成 2. **detached**: 事件已取消 "},"/zh/docs/development-guide/backend/event/service_a":{"url":"zh/docs/development-guide/backend/event/service_a","title":"event-helper","date":"2017-11-17","language":"zh","body":"添加hap-event-helper依赖 com.hand.hap.cloud hap-event-helper 1.0.0-Release 提供事件系统回查接口 当业务A服务A宕机等，长时间未向事件系统(hap-event-store-service)发送请求 事件系统会向次接口发送请求，以确定取消事件还是确认事件。 @GetMapping(\"/v1/api/eventRecords/{id}/{type}\") public ResponseEntity queryEventStatus(@PathVariable String id @PathVariable String type){ return new ResponseEntity<>(service.queryEventStatus(id type) HttpStatus.OK); } 向事件系统发送请求demo @Override public boolean createTrade(TradeDto tradeDto) throws Exception { //1. 生成全局uuid String uuid = EventTools.generateUuid(); //2. 创建event Event event = new Event(); event.setUuid(uuid); //3. 设置本服务的服务名(用于事件系统回查) event.setPublisherServiceId(\"hap-event-demo-trade-service\"); //4. 要发送到消息队列的消息，该消息必须含有uuid字段！！！ TradeAmqp payload = new TradeAmqp(uuid tradeDto.getAmount() tradeDto.getBuyerId() tradeDto.getSellerId()); //5. 传入要写入消息队列的topic和消息体 Event.Message message = new Event.Message(\"trade\" mapper.writeValueAsString(payload)); event.setMessages(Collections.singletonList(message)); event.setType(EVENT_TYPE_TRADE); boolean result = eventTemplate.execute(() -> { //6. 业务员A的执行逻辑。。。 } event); //7. 通过result判断是否创建事件成功 if (!result){ throw new HapException(\"error.trade.create\"); } return true; } demo hap-event-demo-trade-service "},"/zh/docs/development-guide/backend/event/service_b":{"url":"zh/docs/development-guide/backend/event/service_b","title":"event-consumer-helper","date":"2017-11-17","language":"zh","body":"添加hap-event-consume-helper依赖 com.hand.hap.cloud hap-event-consume-helper 1.0.0-Release 设置使用的消息队列 kafka 1. 运行主类添加MessageQueue注解 @MessageQueue(value = QueueType.kafka) 2. 添加kafka的依赖 org.apache.kafka kafka-clients version>0.11.0.1 3. yaml配置kafka event: consumer: kafka: bootstrap-servers: 10.211.109.185:9092 session-timeout-ms: 30000 max-poll-records: 500 heartbeat-interval-ms: 3000 fetch-max-bytes: 52428800 fetch-max-wait-ms: 500 rabbitmq 1. 运行主类添加MessageQueue注解 @MessageQueue(value = QueueType.rabbitmq) 2. 添加rabbitmq的依赖 org.springframework.cloud spring-cloud-starter-stream-rabbit 1.2.0.RELEASE 3. yaml配置rabbitmq spring: rabbitmq: host: localhost port: 5672 rocketmq 1. 运行主类添加MessageQueue注解 @MessageQueue(value = QueueType.rocketmq) 2. 添加rocketmq的依赖 org.apache.rocketmq rocketmq-client RELEASE 3. yaml配置rocketmq event: consumer: rocketmq: namesrv-addr: 127.0.0.1:9876 consume-thread-min: 1 consume-thread-max: 2 redis 1. 运行主类添加MessageQueue注解 @MessageQueue(value = QueueType.redis) 2. 添加redis的依赖 org.springframework.boot spring-boot-starter-data-redis 3. yaml配置redis spring: redis: host: localhost port: 6379 @Topic接收消息 1. value: 订阅的topic名称 2. retryTimes： 方法失败后自动重试的次数 3. firstInterval： 第一次重试间隔(毫秒) 4. retryInterval： 每次重试的间隔(毫秒) 5. afterRetryFailedHandler： 消息重试全都失败之后的处理逻辑 @Service public class TopicTestService { @Topic(value = \"foo\" retryTimes = 15 firstInterval = 5000 retryInterval = 2000 afterRetryFailedHandler = StockMsgFailedHandler.class) public void executeMsg(String msg){ System.out.println(\"message \"+msg); } } @Service public class StockMsgFailedHandler implements AfterRetryFailedHandler { @Override public void handleMsg(String msg) { //执行消息重试15次失败之后的操作 System.out.println(\"msg \"+msg); } } MessageQueue的配置 @MessageQueue(value = QueueType.kafka enableDuplicateRemoveByUuid = false enableTransaction = true enableCache = false) 1. value： 指明消息队列类型，支持kafka，rabbitmq，rocketmq，redis pub/sub 四种。 2. enableTransaction： 是否启用事务，启用之后@Topic声明的方法会封装数据库事务，任何异常会回滚。 3. enableCache： 是否启用缓存，启用之后消息失败写入缓存刷入硬盘，即使宕机消息也不会丢失。 4. enableDuplicateRemoveByUuid： 是否启用去重，启用后。 注意 每条消息中请确保拥有uuid字段 启用enableDuplicateRemoveByUuid后，确保有数据库中msg_record表 DROP TABLE IF EXISTS `msg_record`; CREATE TABLE `msg_record` ( `uuid` varchar(255) NOT NULL `create_time` datetime DEFAULT NULL PRIMARY KEY (`uuid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; demo hap-event-demo-user-service "},"/zh/docs/development-guide/backend/menulevel/":{"url":"zh/docs/development-guide/backend/menulevel/","title":"@Permission注解简介","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/menulevel/permission":{"url":"zh/docs/development-guide/backend/menulevel/permission","title":"@Permission注解使用说明","date":"2017-02-01","language":"zh","body":"@Permission注解使用说明 功能简介 设置API访问权限。 属性说明 roles：设置可访问用户角色，此为数组，可以设置多个角色。 level：设置可访问层级资源。 取值范围： project：访问项目层级 resource：访问资源层级 organization：访问组织层级 permissionLogin：设置是否需要登录访问。 permissionPublic：设置任意访问（极少使用）。 使用方法 在Controller中的API上添加@Permission注解，按需求设置值： @Permission(permissionLogin = true) @ApiOperation(value = \"创建user\") @RequestMapping(value = \"/create\" method = RequestMethod.POST) public ResponseEntity create(@RequestBody @Valid TodoUser user) throws HapException { …… } "},"/zh/docs/development-guide/backend/mixing_env/":{"url":"zh/docs/development-guide/backend/mixing_env/","title":"混合开发模式","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/mixing_env/local_env":{"url":"zh/docs/development-guide/backend/mixing_env/local_env","title":"本地环境搭建","date":"2017-02-01","language":"zh","body":"本地环境搭建 OpenVPN 使用OpenVPN连接服务器，保证可以直接使用openshift服务域名访问对应服务。 OpenVPN下载 （网络原因，请自备梯子） 安装本地服务 本地需要安装，mysql 和 redis 与服务器数据隔离，按照本地开发方法进行数据初始化。 修改服务启动参数 本地只需要启动 hap-api-gateway 和开发者正在开发的服务，并添加启动参数，使其使用服务器上的服务，服务和对应参数如下： 注册服务: -Deureka.client.serviceUrl.defaultZone=http://hap-register-server.hapcloud-master.svc.cluster.local:8000/eureka/ Rabbit MQ: -Dspring.rabbitmq.host=rabbitmq.hapcloud-master.svc.cluster.local 服务名称: -Dspring.application.name=hap-api-gateway-yourname Gateway路由服务: -Dzuul.routes.dev.serviceId=hap-demo-service-todo-yourname 只要是 spring boot application.yml 中的参数都可以按照这种方法用命令行参数替换。 MySQL和Redis也可以同样方法直接使用服务器上的，但是要注意保护数据不被破坏。 需要注意的是本地启动的服务服务名称必须加后缀替换，不能与服务器上冲突。 访问API 通过参数 -Dzuul.routes.dev.serviceId=hap-demo-service-todo-yourname， API Gateway会将路由 /dev 转发到目标服务，用于开发使用。 若需多个路由，自行修改application-default.yml文件，但不要提交代码库。 查看服务是否注册成功：http://hap-register-server.hapcloud-master.svc.cluster.local:8000/ 访问swagger：http://localhost:8080/swagger-ui.html "},"/zh/docs/development-guide/backend/mixing_env/mixing_develop_structure":{"url":"zh/docs/development-guide/backend/mixing_env/mixing_develop_structure","title":"混合开发模式结构","date":"2017-02-01","language":"zh","body":"混合开发模式结构 由于微服务应用的特性，随着项目越来越复杂，服务数量会越来越多，在本地启动所有相关服务进行开发是不现实的，需要服务器运行整套环境，然后开发者只运行自己开发的服务。 混合开发模式结构 "},"/zh/docs/development-guide/backend/mixing_env/server_env":{"url":"zh/docs/development-guide/backend/mixing_env/server_env","title":"服务器环境搭建","date":"2017-02-01","language":"zh","body":"服务器环境搭建 服务器环境需要安装openshift环境和openvpn服务，在此不做详谈。 "},"/zh/docs/development-guide/backend/pact/":{"url":"zh/docs/development-guide/backend/pact/","title":"契约测试","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/pact/pact_broker":{"url":"zh/docs/development-guide/backend/pact/pact_broker","title":"pact broker搭建","date":"2017-11-29","language":"zh","body":"docker-compose.yml version: '3' services: postgres: image: postgres healthcheck: test: psql postgres --command \"select 1\" ports: - \"5432:5432\" environment: POSTGRES_USER: postgres POSTGRES_PASSWORD: password POSTGRES_DB: postgres broker_app: image: dius/pact-broker ports: - \"80:80\" links: - postgres environment: PACT_BROKER_DATABASE_USERNAME: postgres PACT_BROKER_DATABASE_PASSWORD: password PACT_BROKER_DATABASE_HOST: postgres PACT_BROKER_DATABASE_NAME: postgres PACT_BROKER_BASIC_AUTH_USERNAME: pact PACT_BROKER_BASIC_AUTH_PASSWORD: pact 设置pact broker的用户名密码 修改PACT_BROKER_BASIC_AUTH_USERNAME和PACT_BROKER_BASIC_AUTH_PASSWORD的值 启动 docker compose up "},"/zh/docs/development-guide/backend/pact/pact_consumer":{"url":"zh/docs/development-guide/backend/pact/pact_consumer","title":"服务消费端","date":"2017-11-29","language":"zh","body":"添加依赖 au.com.dius pact-jvm-consumer-junit_2.11 3.5.10 契约和测试的编写 Step1. feign部分定义pact契约 同样调用feign的service也在这里测试 @RunWith(SpringRunner.class) @SpringBootTest(properties = { \"user-service.ribbon.listOfServers: localhost:10001\" }) public class UserLoginConsumerPactTest { /** * 此处起了一个server 用于模拟feign调用的服务 */ @Rule public PactProviderRuleMk2 stubProvider = new PactProviderRuleMk2(\"user_provider\" \"127.0.0.1\" 10001 this); @Autowired private UserLoginFeignClient userLoginFeignClient; @Autowired private OauthService oauthService; /** * 定义pact契约 */ @Pact(state = \"user login state\" provider = \"user_provider\" consumer = \"userLoginFeignClient\") public RequestResponsePact loginPact(PactDslWithProvider pactDslWithProvider) { return pactDslWithProvider .given(\"user login state\") .uponReceiving(\"user login by name and pass\") .path(\"/login\") .matchQuery(\"name\" \"alice\") .matchQuery(\"pass\" \"alice\") .method(\"GET\") .willRespondWith() .status(200) .body(\"{\\\"code\\\":1 \\\"message\\\":\\\"name pass valid\\\" \\\"data\\\":\\\"success\\\"}\" \"application/json; charset=UTF-8\") .toPact(); } /** * 验证一下定义pact契约的接口 */ @Test @PactVerification(fragment = \"loginPact\") public void verifyLoginPact() { Result result = userLoginFeignClient.login(\"alice\" \"alice\"); System.out.println(result); Assert.assertEquals(1 result.getCode()); } /** * 调用feign的service也在这里测试 */ @Test @PactVerification(fragment = \"loginPact\") public void checkOauthTest() { ResponseEntity> responseEntity = oauthService.checkOauth(\"alice\" \"alice\"); System.out.println(responseEntity.getBody()); Assert.assertEquals(1 responseEntity.getBody().getCode()); } /** * 调用feign的service也在这里测试 */ @Test @PactVerification(fragment = \"loginPact\") public void getOauthJwtTest() { ResponseEntity> responseEntity = oauthService.getOauthJwt(\"alice\" \"alice\"); System.out.println(responseEntity.getBody()); Assert.assertEquals(1 responseEntity.getBody().getCode()); } } Step2. 其他部分的测试可使用mock方式进行单元测试。 Step3. 运行测试类，会在target/pacts中生成契约json文件。 Step4. 上传契约文件到pact broker. maven添加插件 au.com.dius pact-jvm-provider-maven_2.12 3.5.10 http://localhost:80 pact pact 上传契约 mvn pact:publish "},"/zh/docs/development-guide/backend/pact/pact_introduce":{"url":"zh/docs/development-guide/backend/pact/pact_introduce","title":"pact介绍","date":"2017-11-29","language":"zh","body":"Pact是什么？ Pact是一个用于实现消费者驱动的契约测试的框架 它支持JVM Ruby .NET Javascript Go Python Swift等多种语言和平台。 Pact使用流程 Step 1： 服务消费者端编写单元测试，测试对服务提供者接口的客户端请求类。一运行测试，Pact框架便帮助自动生成json形式的pact文件(java中位于target/pacts中)。pact文件中含有交互的路径、方法、请求参数、请求头与期望响应等信息。 Step 2： 将契约文件上传到pact broker(也可以放于某个提供者可拿到的文件夹中) Step 3： 服务提供者完成相关接口。 Step 4: 服务提供者通过pact broker等方式获取契约文件，利用Pact框架提供的验证命令进行契约验证 直到对服务提供者的接口发送请求并验证实际响应是否与期望响应相符。 "},"/zh/docs/development-guide/backend/pact/pact_producer":{"url":"zh/docs/development-guide/backend/pact/pact_producer","title":"服务提供端","date":"2017-11-29","language":"zh","body":"添加依赖 au.com.dius pact-jvm-consumer-junit_2.11 3.5.10 au.com.dius pact-jvm-provider-spring_2.12 3.5.10 验证pact契约 因为pact已经验证了controller和service，此部分的单元测试可以不用写，但是如下的UserMapper因为使用了mock，并没有测试是否可用，此部分的单元测试要写。 @RunWith(SpringRestPactRunner.class) @Provider(\"user_provider\") @PactBroker(host = \"localhost\" port = \"80\" authentication = @PactBrokerAuth(username = \"pact\" password = \"pact\")) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT properties = { \"server.port=10001\" }) public class UserLoginControllerProviderTest { @MockBean private UserMapper userMapper; @InjectMocks private UserService userService = new UserServiceImpl(userMapper); @InjectMocks private UserLoginController userLoginController = new UserLoginController(userService); @TestTarget public final Target target = new HttpTarget(10001); /** * 测试时，会从pact broker下载契约，验证state为user login state的契约 * 验证时，conrtoller调用service再调用mapper * 此时数据库不一定有此数据，可使用mock，如下： */ @State(\"user login state\") public void toCreateCheckOauthState() { when(userMapper.select(any(User.class))) .thenReturn(Collections.singletonList(new User(10L \"alice\" \"alice\"))); } } "},"/zh/docs/development-guide/backend/pact/pact_skill":{"url":"zh/docs/development-guide/backend/pact/pact_skill","title":"pact使用优化","date":"2017-11-29","language":"zh","body":"动态配置pact broker pact验证时的broker配置 @PactBroker(host = \"${pactbroker.hostname}\" port = \"${pactbroker.port}\" authentication = @PactBrokerAuth(username = \"${pactbroker.auth.username}\" password = \"${pactbroker.auth.password}\")) maven的pom配置 localhost 80 pact pact au.com.dius pact-jvm-provider-maven_2.12 3.5.10 http://${pact.hostname}:${pact.port} ${pact.auth.username} ${pact.auth.password} org.apache.maven.plugins maven-surefire-plugin 2.16 ${pact.hostname} ${pact.port} ${pact.auth.username} ${pact.auth.password} false 在ci中替换变量 mvn clean package -DskipTests=false -Dpact.hostname=192.165.18.4 "},"/zh/docs/development-guide/backend/problems/":{"url":"zh/docs/development-guide/backend/problems/","title":"常见问题","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/problems/redis":{"url":"zh/docs/development-guide/backend/problems/redis","title":"Redis 连接失败","date":"2017-02-01","language":"zh","body":"Redis 连接失败 确定redis是否正常启动于本机6379端口，运行 telnet localhost 6379 没有出错说明成功启动，否则检查redis安装 确定对应服务的 spring.redis.host 属性和 spring.redis.port 属性为 localhost 和 6379 client设置重定向地址 在oauth2.0中一个client对应一个redirect_url，在hapcloud后端client表中有如下关键字段，name字段是客户端的名字，前端项目会设置客户端的name。所以当client表中web_server_redirct_url字段非空时必须与前端项目的地址相匹配。 "},"/zh/docs/development-guide/backend/technology/":{"url":"zh/docs/development-guide/backend/technology/","title":"自开发mybatis扩展框架","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/technology/mybatis":{"url":"zh/docs/development-guide/backend/technology/mybatis","title":"hap-mybatis-mapper-stater 开发文档","date":"2017-02-01","language":"zh","body":"hap-mybatis-mapper-stater 开发文档 功能特点 通用mapper功能 数据多语言支持 多种数据源物理分页 自动审计功能 选择性插入和更新 使用方法 集成 在spring boot项目依赖中添加如下依赖 com.hand.hap.cloud hap-mybatis-mapper-starter 1.1-SNAPSHOT 通用mapper使用方法 使实体类T的mapper接口继承于BaseMapper 如下所示： 继承于BaseMapper的接口不能再用@Mapper注解标注 public interface UserRoleMapper extends BaseMapper { } BaseMapper已包含基本的增删改查 如不需要自定义新的查询 则不需建立Mapper.xml文件。service集成之后将可以通过service直接调用基本增删该查方法 继承方式如下: //接口 public interface RoleService extends BaseService { } //实现类 @Service public class RoleServiceImpl extends BaseServiceImpl implements RoleService { } 多语言使用 使用多语言功能是 首先应在数据库添加对应多语言表 多语言表的命名为原表明再加上后缀_tl即可. 在原表的实体类加上@MultiLanguage注解 如people姓名为多语言字段拥有中文名和英文名 配置如下: @MultiLanguage public class People { @MultiLanguageField private string name； } 当语言改变时 多语言字段查询到的将是对应的语言. 当对有多语言字段的表进行单个记录的删除时 会级联删除多语言表的相应记录. 分页使用 对单个表的全部记录进行分页 BaseService中已带有分页方法 使用方式及其简单. //service层接口 public interface RoleService extends BaseService { } //service层实现类 @Service public class RoleServiceImpl extends BaseServiceImpl implements RoleService { } //controller @Controller public class RoleController{ ... @Autowired private RoleService service; @RequestMapping(\"/v1/roles\") @RequestMapping(method = RequestMethod.GET) public Page select(@RequestParam Integer page @RequestParam Integer size){ return service.pageAll(page size)); } } 对单个表中特定记录分页查询 //service接口 public interface ClientService extends BaseService { //在service接口中建立方法 参数中带上查询限制 //如对特定组织的所有的客户端进行分页查询. Page selectClientAll(Long organizationId Integer page Integer size); } ... //service实现类 @Service public class ClientServiceImpl extends BaseServiceImpl implements ClientService { //根据传入的组织id构建查询对象 @Override public Page selectClientAll(Long organizationId Integer page Integer size) { Client client = new Client(); client.setOrganizationId(organizationId); return this.page(client page size); } } 对多个表集联查询时分页 新建集联查询结果的pojo类，在mapper接口中新建自定义查询接口 并在mapper.xml中编写对应的查询语句。 //接口形式如下 List CustomSelect(T var1 T var2); 在service接口中，建立对应分页查询方法。接口的参数对应查询集联查询的参数和分页参数。 Page CustomPage(T var1 T var2 int start int size); 在service实现类中override此方法.具体如下: public Page CustomPage(T var1 T var2 int start int size){ return PageHelper.doPage(page size () -> { return mapper.CustomSelect(var1 var2); }); } 审计功能使用 实体类继承AuditDomain类之后便拥有各个审计字段 其中还有对继承了AuditDomain类用@ModifyAudit注解后增删改查操作会自动对”creationDate” ”createdBy” ”lastUpdateDate” ”lastUpdatedBy”这四个字段进行维护.用@VersionAudit注解后会自动对”objectVersionNumber”进行维护 但更新时必须传回原版本号 否则抛出异常。 使用了@VersionAudit注解后更新是必须返回原版本号 选择行插入更新 BaseService中有两个方法 int insertOptional(T record String... optionals); 和 int updateOptional(T record String... optionals);.以满足用户的特定需求. insertOptional方法使用场景 当用户插入时只需要插入指定的字段 且对于不指定字段初始为null而不是数据库中的指定的默认值.当然当数据库中未设置默认值时 不用此方法也可初始化为null. updateOptional方法使用场景 当用户对记录进行更新时如果只想更新指定的几个字段 对未指定的其余字段则保持原值则可使用此方法. "},"/zh/docs/development-guide/backend/upgrade/":{"url":"zh/docs/development-guide/backend/upgrade/","title":"升级注意事项","description":"","language":"zh","body":""},"/zh/docs/development-guide/backend/upgrade/upgrade_1":{"url":"zh/docs/development-guide/backend/upgrade/upgrade_1","title":"2017-11-20","date":"2017-11-20","language":"zh","body":"2017-11-20 后端新功能特性 全局层(global)权限 在原本的三层权限结构中新增加一层独立于三层结构之外的全局层权限，全局层权限的管辖范围包括不属于特定组织或组织下相应项目资源的一些的一些权限。例如新建组织、删除组织、角色管理、菜单管理等相关操作权限就属于全局层。 新菜单模式 菜单分为三个入口，组织层、项目层、全局层。未配置时菜单，根据系统原有菜单表的顺序返回默认菜单。管理员可以自定义自己的菜单结构。并可以恢复默认菜单 角色可定义 管理员可以自己创建角色并自定义角色之下的权限。系统原有的角色将不能修改。 注意事项 初始化数据库 升级后初始化数据库时，如果开发人员想保留原有数据库数据，在初始化数据库相关job或shell脚本，将参数data.drop设置成false。可能会出现报错等情况，由于开发人员未正确使用groovy脚本。当出现这种情况自己不能解决是，又想保留原有数据时，联系我们。 角色管理 由代码初始化的角色为系统内置角色，内置角色不能进行修改，只有在界面上自定义的角色才能进行修改。角色还有一个启用和是否启用的配置。未启用的角色将不能分配。 菜单管理 可以在平台界面上创建菜单目录，自定义菜单结构。新的菜单返回将与用户所具有权限无关，由前端判断该菜单是否有权限显示。 "},"/zh/docs/development-guide/backend-environment-deployment":{"url":"zh/docs/development-guide/backend-environment-deployment","title":"后端环境部署","date":"2017-10-30","language":"zh","body":"HAPCloud 后端demo环境部署 前置条件kubernetes环境 本教程旨在于k8s中通过现有的部署文件轻松部署一个HAPCloud环境，所有部署文件的在hapcloud-deploy。 部署DB以及相关基础依赖 部署mysql 在k8s管理节点上通过执行kubectl create -f pv.yml新建在k8s控制台界面上或者在节点终端建立mysql所对应的PersistentVolumeClaim(简称pv)即持久卷，因为mysql容器中'/var/lib/mysql目录需挂载出去。并在nfs上建立pv.yml中所设设置的挂载目录。建立好之后执行kubectl get pv所建pv的状态为Available。 在k8s控制台界面上或者在节点终端建立mysql所对应的PersistentVolumeClaim(简称pvc)、Service、deploymentConfigConfigMap。pvc建立好之后如果与先前建立的pv绑定成功，此时再查看pv的状态则为Bound`。 部署rabbitmq和redis rabbitmq和redis无需挂载卷所以只需在k8s上执行对应的部署文件即可。 首次初始化数据库 可以通过phpmyadmin或者通过连接openvpn在mysql容器中建立用户和数据库并赋予权限。脚本如下： CREATE USER 'hapcloud'@'%' IDENTIFIED BY \"handhand\"; CREATE DATABASE hap_user_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_framework_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_scheduler_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_zipkin_ui DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON hap_user_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_framework_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_scheduler_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_zipkin_ui.* TO hapcloud@'%'; FLUSH PRIVILEGES; 建立配置文件git仓库 可以从我们的git仓库fork出一份自己的仓库，以便添加一些额外的配置。此时hap-config-server.yml文件中把注释部分取消并换成自己的仓库地址。 部署HAPCloud核心服务 1. 注册服务hap-register-server 直接执行。 2. 配置服务hap-config-server 在注释处替换自己的配置文件仓库，直接运行即可。 3. 认证服务hap-oauth-server 直接执行 4. 网关hap-api-gateway hap-api-gateway的SWAGGER认证地址需要根据所配置的路由地址来确认。 5. 用户服务hap-user-service 首次需先执行数据库的初始化。在hap-user-service项目的根目录下执行`sh init-local-database.sh`，需连上openvpn并把脚本中的mysql地址替换为k8s上mysql pod地址。现在也可直接执行hap-user-service.yml中的job即可初始化话数据库。 现在也 6. 用户管理服务hap-user-admin-service 用户管理服务也是依赖`hap_user_service`数据库的初始化，与hap-user-service所依赖数据库相同。 7. 框架服务hap-framework-service 框架服务的数据库初始化需在用户服务的数据库初始化之后，同样可以通过执行yml文件的job初始化和远程执行`sh init-local-database.sh`进行初始化数据。 hap-user-service先执行数据库初始化。 部署HAPCloud其他服务 1. 调度服务hap-scheduler-service 确保`hap_user_service`数据初始化后，进入项目目录，执行`sh init-local-database.sh`初始化项目数据库，初始化结束后即可启动应用。 "},"/zh/docs/development-guide/front/":{"url":"zh/docs/development-guide/front/","title":"前端开发","description":"","language":"zh","body":""},"/zh/docs/development-guide/front/component/":{"url":"zh/docs/development-guide/front/component/","title":"通用组件和封装函数","description":"","language":"zh","body":""},"/zh/docs/development-guide/front/component/commoncomponent/":{"url":"zh/docs/development-guide/front/component/commoncomponent/","title":"通用组件","description":"","language":"zh","body":""},"/zh/docs/development-guide/front/component/commoncomponent/action":{"url":"zh/docs/development-guide/front/component/commoncomponent/action","title":"Action","date":"2017-02-01","language":"zh","body":"Action 操作组件 用途 Action组件为封装的框架统一Table表操作一栏功能组件。 用法 在组件头部引用后直接调用 ... import Action from 'Action'; ... return ( ... ... ) 参数 说明 service 该按钮具有的permision字段， 如果没有权限则不显示该按钮 icon 图标 text 按钮文字 action 点击之后的事件 "},"/zh/docs/development-guide/front/component/commoncomponent/antd":{"url":"zh/docs/development-guide/front/component/commoncomponent/antd","title":"ANTD","language":"zh","body":"ANTD HAP Cloud 大量运用ANTD UI框架 可以通过链接 进行系统学习。 "},"/zh/docs/development-guide/front/component/commoncomponent/clientsearch":{"url":"zh/docs/development-guide/front/component/commoncomponent/clientsearch","title":"ClientSearch","language":"zh","body":"ClientSearch 搜索框 用途 ClientSearch搜索框组件是为实现页面table表过滤搜索功能。 用法 在组件头部引用后直接调用 ... import ClientSearch from ClientSearch ... handleSearch = (result) => { this.setState({ search: result }); } ... return ( ) 参数 说明 options 搜索框下拉列表的数据 name代表一行的文字 code代表该行对应的字段 onSearch 搜索的点击事件 默认带一个对象参数 该对象参数有两个key为code和input 分别对应下拉框选中的字段和input框输入的内容 "},"/zh/docs/development-guide/front/component/commoncomponent/isauthspin":{"url":"zh/docs/development-guide/front/component/commoncomponent/isauthspin","title":"开放master之IsAuthSpin组件","language":"zh","body":"开放master之IsAuthSpin组件 自定义master HAP Cloud 默认首页进入iam模块container目录下的master.js文件 如需自定义master，可在根目录config.js中配置 const config = { ... \"master\": JSON.stringify('devops') ... } module.exports = config; 此处配置将页面根路由配置于'devops'模块 /src/containers/Master.js IsAuthSpin 组件 IsAuthSpin组件用于判断用户是否登录，登录成功会显示IsAuthSpin包裹的内部组件，没有登录不会展示内容。 使用方法： 在Master.js头部引入IsAuthSpin import IsAuthSpin from 'IsAuthSpin'; 在组件return根标签中引入组件，并在组件内部包裹首页内容 ... return ( style: '' } { component: style: '' } { component: style: '' } { component: style: { float: 'right' paddingTop: '6px' paddingRight: '0px' } }]} /> ); ... "},"/zh/docs/development-guide/front/component/commoncomponent/mainmenu":{"url":"zh/docs/development-guide/front/component/commoncomponent/mainmenu","title":"开放master之CommonMenu组件","date":"2017-09-29","language":"zh","body":"开放master之CommonMenu组件 用途 CommonMenu组件集成了所有菜单资源，用于用户选择查看当前菜单，通过管理设置里的菜单配置层级，可动态显示自定义菜单层级。 用法 通过组件头部引入，直接调用 ... import CommonMenu from 'CommonMenu' ... return( ) "},"/zh/docs/development-guide/front/component/commoncomponent/masterheader":{"url":"zh/docs/development-guide/front/component/commoncomponent/masterheader","title":"开放master之MasterHeader组件","language":"zh","body":"开放master之MasterHeader组件 头部标题栏展示 MasterHeader组件用于自定义头部标题栏 如上图头部蓝色部分 使用方法 在组件头部引入MasterHeader ... import MasterHeader from 'MasterHeader'; ... 在组件return中引入该组件 ... return( ... ... ) ... 组件参数 MasterHeader默认携带一个menuChild参数，该参数是一个对象数组 用于给菜单栏添加多个菜单列表 例子： ... style: { padding: '0' } } { component: style: { marginLeft: '14px' padding: '4px 10px 4px 10px' } hoverIf: true } { component: style: { marginLeft: 'calc(2rem - 10px)' marginRight: '-20px' padding: '4px 10px 4px 10px' } hoverIf: true } { component: style: { flex: 1 display: 'block' visibility: 'hidden' } hoverIf: false } { component: hoverIf: false } { component: style: { paddingRight: '2rem' } hoverIf: false }]} /> ... 参数 说明 component 封装的组件，用于按次序放入头部 style 组件的样式 hoverIf 鼠标悬停组件是否出发hover事件 "},"/zh/docs/development-guide/front/component/commoncomponent/menutype":{"url":"zh/docs/development-guide/front/component/commoncomponent/menutype","title":"开放master之MenuType组件","date":"2017-09-29","language":"zh","body":"开放master之MenuType组件 用途 MenuType组件用于选择当前所处的组织或项目 点击不同组织或项目将不同组织项目的服务和选项存储到menuStore里的menu字段中 使用方法 通过组件头部引用后，直接调用 ... import MenuType from 'MenuType'; ... return( ) ... "},"/zh/docs/development-guide/front/component/commoncomponent/newbutton":{"url":"zh/docs/development-guide/front/component/commoncomponent/newbutton","title":"NewButton 按钮组件","date":"2017-02-01","language":"zh","body":"NewButton 按钮组件 用途 NewButton组件为封装的框架统一按钮组件，通过一系列参数配置可实现按钮基础功能效果。 用法 在组件头部引用后直接调用 ... import NewButton from 'NewButton' ... return ( ... ... ) 参数 说明 text 按钮的文字内容 htmlType 按钮的类型 submit/button/reset width 按钮的宽度 height 按钮的高度 className 按钮的class名 默认有三种 color2/color3/color4 style 按钮的样式 onClick 按钮的点击事件 icon 按钮内部的图标 disabled 按钮是否不可点击 loading 按钮是否是加载中 loadingRender 自定义按钮加载样式，不填为默认 "},"/zh/docs/development-guide/front/component/commoncomponent/pageheader":{"url":"zh/docs/development-guide/front/component/commoncomponent/pageheader","title":"Pageheader","date":"2017-02-01","language":"zh","body":"Pageheader 框架目前界面的头部都是统一使用 PageHeader 渲染。 查询展示界面 import PageHeader { PageHeadStyle UnderPageHeadStyle } from 'PageHeader' ... {HAP.getMessage('创建' 'create')} { this.loadRoles(this.state.page) }} style={PageHeadStyle.leftBtn2} > {HAP.getMessage('刷新' 'flush')} ... 编辑新增界面 API 参数 说明 类型 默认值 title 页面的title（必须） Object 无 backPath 返回的页面的路径 String 无 "},"/zh/docs/development-guide/front/component/commoncomponent/remove":{"url":"zh/docs/development-guide/front/component/commoncomponent/remove","title":"Remove 删除弹窗","date":"2017-02-01","language":"zh","body":"Remove 删除弹窗 界面中会大量用到 table 的删除操作 ，此时可以使用 框架中的 Remove 组件。 import Remove from '../../components/Remove'; class App extends React.Component { handleOpen = (id) => { this.setState({ open: true id: id }); }; handleClose = (event) => { this.setState({ open: false }); }; handleDelete = (event) => { this.setState({ open: false }); }; render() { return ( Open a modal dialog ); } } ReactDOM.render( mountNode); API 参数 说明 类型 默认值 open 对话框是否可见 boolean 无 handleCancel 点击取消按钮的回调 function 无 handleConfirm 点击确定按钮的回调 function 无 "},"/zh/docs/development-guide/front/component/commoncomponent/repagination":{"url":"zh/docs/development-guide/front/component/commoncomponent/repagination","title":"RePagination","date":"2017-02-01","language":"zh","body":"RePagination 分页组件 用途 RePagination分页组件为框架统一分页组件，为解决单页面数据量过多，提升用户体验的功能。 用法 在组件头部引用后直接调用 ... import RePagination from 'RePagination'; ... return ( ... { this.setState({ page: page }) this.loadClient(page this.state.params) }} /> ... ) 参数 说明 total 要分页数据的总数 pageSize 一页显示的个数 current 当前选中的页数 onChange 点击页数的回调事件 "},"/zh/docs/development-guide/front/component/commoncomponent/select":{"url":"zh/docs/development-guide/front/component/commoncomponent/select","title":"Select","date":"2017-02-01","language":"zh","body":"Select 下拉选择组件 用途 Select组件为封装的框架统一下拉选择组件，通过统一，简便的配置完成下拉选择功能。 用法 在组件头部引用后直接调用 ... import Select from 'Select' ... handleSelectChange = (value) => { this.setState({ value }) } ... return ( ) ... 参数 说明 data 下拉菜单的数据，code为对应的字段 name为对应的文字 onChange 下拉列表选中事件 回调函数默认带一个参数为选中的code type 可选长下拉框 typ2 可选短下拉框 width 可选下拉框长度 default 默认显示文字 "},"/zh/docs/development-guide/front/component/commoncomponent/userpreferences":{"url":"zh/docs/development-guide/front/component/commoncomponent/userpreferences","title":"开放master之UserPreferences组件","date":"2017-09-29","language":"zh","body":"开放master之UserPreferences组件 用途 UserPreferences组件用于登出用户和设置用户首选项 用法 在组件头部引入后直接调用 ... import UserPreferences from 'UserPreferences'; ... return( ) 参数 说明 imgUrl 传入对应后端返回的头像字段(注意将字段保存在前端store中，避免在个人中心成功上传头像，页面不会动态刷新的问题) "},"/zh/docs/development-guide/front/component/commonfunc/":{"url":"zh/docs/development-guide/front/component/commonfunc/","title":"通用函数","description":"","language":"zh","body":""},"/zh/docs/development-guide/front/component/commonfunc/hap":{"url":"zh/docs/development-guide/front/component/commonfunc/hap","title":"HAP封装函数","language":"zh","body":"HAP封装函数 HAP文件为框架全局注入的封装函数类，项目内部可以直接调用HAP函数算法进行计算操作 function getAccessToken(hash) { if (hash) { const ai = hash.indexOf(ACCESS_TOKEN); if (ai !== -1) { const accessToken = hash.split('&')[0].split('=')[1]; return accessToken; } } return null; } function setAccessToken(token expiresion) { const expires = expiresion * 1000; const expirationDate = new Date(Date.now() + expires); setCookie(ACCESS_TOKEN token { path: '/' expires: expirationDate }); } function removeAccessToken() { removeCookie(ACCESS_TOKEN { path: '/' }); } function languageChange(id) { return ; } function logout() { removeAccessToken(); AppState.setAuthenticated(false); window.location = `${process.env.AUTH_HOST}/logout`; } function getMessage(zh en) { const language = AppState.currentLanguage; if (language === 'zh') { return zh; } else if (language === 'en') { return en; } return false; } function prompt(type content) { switch (type) { case 'success': message.success(content); break; case 'error': message.error(content); break; default: break; } } function handleResponseError(error) { const response = error.response; if (response) { const status = response.status; switch (status) { case 400: { const mess = response.data.message; message.error(mess); break; } default: break; } } } function unauthorized() { HAP.removeAccessToken(); AppState.setAuthenticated(false); window.location = `${HAP.AUTH_URL}`; } // 生成指定长度的随机字符串 function randomString(len = 32) { let code = ''; const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; const maxPos = chars.length; for (let i = 0; i { if (type === 'organization') { permission = { \"name\": `${data}.${value}` \"resourceId\": organid \"resourceType\": type \"organizationId\": organid }; } else if (type === 'project') { permission = { \"name\": `${data}.${value}` \"resourceId\": proid \"resourceType\": type \"organizationId\": organid }; } MenuCode.push(permission); }) const uniqMenuCode = _.uniqBy(MenuCode 'name'); return uniqMenuCode; } function getPermission(data type) { let approve; data[0] && data[0].map(value => { if(value.name) { if (value.name === type) { approve = value.approve; } } }) return approve; } 函数名 说明 getAccessToken 获取url token值 setAccessToken 前端存储cookie token值 removeAccessToken 移除token值 languageChange 多语言 logout 登出系统 getMessage 返回多语言字符串 prompt 提示错误信息 handleResponseError 处理错误响应 unauthorized 没有权限 页面跳转 randomString 生成制定长度的随机字符串 setTheme 获取主题配置 getConfig 获取主配置 使用方法 在页面直接调用HAP.函数名 "},"/zh/docs/development-guide/front/develop_env":{"url":"zh/docs/development-guide/front/develop_env","title":"开发环境配置","description":"","language":"zh","body":"Mac下软件安装 安装工具 NVM VScode或其他代码编辑器安装 Git NVM 安装 打开终端 输入 curl -o- https:/raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 如果没有curl命令，可以通过wget\b命令: wget -qO- https:/raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 在~/.nvm ~/.bash_profile ~/.zshrc ~/.profile ~/.bashrc 其中任意一个文件中加入 export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm 这里修改~/.profile vim ~/.profile 如果没有vim \bapt-get install vim或者直接编辑文件 然后输入source ~/.profile 通过nvm -v\b便可以看到nvm\b版本和相关操作 通过nvm install 6.11.4安装node的6.11.4版本 其他版本相似 详细\bNVM安装使用和系统权限等问题可看文档（通过其他方式\b进行安装） NVM的githubgit 安装 \b安装brew/usr/bin/ruby -e \"$(curl -fsSL https:/raw.githubusercontent.com/Homebrew/install/master/install)\" \b打开终端 输入 brew install git 安装\b\b\bgit命令 VScode或其他代码编辑器安装 在 VScode官网 下载安装 在 WebStorm官网 下载安装 全局安装 Webpack 我们希望能够在系统的任何文件夹中使用 Webpack，使用的方式是通过 Webpack 命令来完成的，这需要我们全局安装 Webpack。这也只需要安装一次，以后每个项目就不需要重新全局安装了。 $ npm install webpack -g 成功安装之后，你应该能够在任何目录中执行 webpack 命令，如果你还没有项目的配置文件的话，应该会看到当前的 Webpack 版本和一个命令的帮助列表。 全局安装 Gulp 在项目中，gulp 用于监视各模块文件的变化和同步相应的文件到boot目录中。 $ npm install gulp -g 安装成功后，在终端里运行 gulp -v 应该可以看到gulp的版本信息。 全局安装 yeoman 在项目中，yeoman 用于自动生成与boot同级的模块目录和文件。 $ npm -g install yo 安装成功后，在终端里运行 yo --version 应该可以看到yeoman的相关信息。 全局安装python 安装python mac系统其实自带了一个python的执行执行环境，用来运行python还行，但是开发可能就不够了，因此我们需要重新安装python。这里有两种方案安装： homebrew brew install python 这个方案比较简单 如果出错的话可以给前面加sudo试试 这个安装的python可能不是最新版. 官网下载安装 大家可以从https:/www.python.org/download下载安装最新版的python 安装比较无脑 一路按下去就OK 缺点是以后升级 卸载都得自己维护. 这两个方法安装的python的位置是不一样的 大家可以用: which python 来查看安装位置.安装完成后在终端中键入python来验证安装是否成功 安装pip brew install pip 源代码安装pip wget https:/bootstrap.pypa.io/get-pip.py sudo python get-pip.py 用python执行刚才获取的脚本 这里sudo可以选择使用 若遇到类似这个报错则必须加sudo: Exception: Traceback (most recent call last): ... OSError: [Errno 13] Permission denied: 'XXX/pip-0.7.2-py2.7.egg/EGG-INFO/dependency_links.txt' Storing debug log for failure in /Users/bilt/.pip/pip.log 安装成功后可以在终端中键入pip来检测 如果不行重启终端后尝试. 克隆代码 可以新建一个 hap-cloud-front 的目录，进入到该目录下，在终端执行 git clone release-1.2.0 https:/xxxx@rdc.hand-china.com/gitlab/HAPCloud/HAPCloudFront.git --recursive 其中 xxxx 是你的工号。 (确保克隆之前设置了 git config --global user.name git config --global user.email ) git submodule 子模块操作 git config 配置操作 运行代码 进入到项目根目录，打开终端，键入bash boot\\structure\\npm.sh boot iam。 安装依赖完成后，执行node_modules/.bin/gulp 如果已全局安装gulp 则可直接执行gulp 不要关闭该终端(在iam等其他模块项目中源文件发生修改时，gulp会自动检测修改并同步)，新开一个git bash同样在该目录下执行 npm start 启动项目，看到如图所示效果说明启动成功 提示: (可以通过 gulp clean 删除所有自动生成的文件 再通过 gulp 来重新生成，再重新启动 npm start ，这样可以解决有时页面未更新的状态) 查看效果 在浏览器中键入 localhost:9090/ Windows下软件安装 安装工具 Node.js 6.3及以上版本 Webstorm 或其他代码编辑器 Git node 安装 在 Node.js官网下载用于Windows平台的安装包 Window 上安装Node.js，你可以采用以下两种方式来安装 Windows 安装包(.msi) 本文实例以v0.10.26版本为例，其他版本类似，安装步骤： 步骤1 :双击下载后的安装包 v0.10.26，如下所示： 步骤2 :点击以上的Run(运行)，将出现如下界面： 步骤3 :勾选接受协议选项，点击next（下一步）按钮: 步骤4 : Node.js默认安装目录为“C:\\Program Files\\nodejs” 你可以修改目录，并点击next（下一步）： 步骤5 :点击树形图标来选择你需要的安装模式 然后点击下一步next（下一步） 步骤6 :点击Install（安装）开始安装Node.js。你也可以点击Back（返回）来修改先前的配置。然后并点击next（下一步）： 安装过程： 点击Finish（完成）按钮退出安装向导。 检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入“cmd” =>输入命令“path”，输出如下结果： PATH=C:\\oraclexe\\app\\oracle\\product\\10.2.0\\server\\bin;C:\\Windows\\system32; C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\; c:\\python32\\python;C:\\MinGW\\bin;C:\\ProgramFiles\\GTK2-Runtime\\lib; C:\\ProgramFiles\\MySQL\\MySQLServer5.5\\bin;C:\\ProgramFiles\\nodejs\\; C:\\Users\\rg\\AppData\\Roaming\\npm 我们可以看到环境变量中已经包含了C:\\Program Files\\nodejs\\ 检查Node.js版本 Windows 二进制文件 (.exe)安装 步骤1 :双击下载的安装包Node.exe，将出现如下界面: 点击Run（运行）按钮将出现命令行窗口： 版本测试 进入node.exe所在的目录，如下所示： 如果你获得以上输出结果，说明你已经成功安装了Node.js。 git 安装 在Git 官网下载对应平台的 Git。 本地执行安装文件， 安装 Git 环境。 Win 在环境变量中系统变量的 path 配置 Git 的环境变量指向 Git安装目录下的/bin。 配置完成后打开 cmd 执行git，有提示则说明环境安装成功。 对于 Windows，安装 Git 以后，你可以在任意目录 右键，Git Bash Here 打开的 MINGW 命令窗口可以执行兼容 linux 系统的命令，如rm，ls等 WebStorm或其他代码编辑器安装 在 WebStorm官网 下载安装 本地执行.exe文件，自行安装 开发准备 npm是Node.js的包管理工具（package manager）。npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。 npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入 npm -v，应该看到类似的输出： C:\\>npm -v 4.1.2 如果直接输入 npm ，你会看到类似下面的输出： C:\\>npm Usage: npm where is one of: 提示 npm 需要跟上命令。这样确保npm正确安装了，能运行就行。 全局安装 Webpack 我们希望能够在系统的任何文件夹中使用 Webpack，使用的方式是通过 Webpack 命令来完成的，这需要我们全局安装 Webpack。这也只需要安装一次，以后每个项目就不需要重新全局安装了。 $ npm install webpack -g 成功安装之后，你应该能够在任何目录中执行 webpack 命令，如果你还没有项目的配置文件的话，应该会看到当前的 Webpack 版本和一个命令的帮助列表。 全局安装 Gulp 在项目中，gulp 用于监视各模块文件的变化和同步相应的文件到boot目录中。 $ npm install gulp -g 安装成功后，在终端里运行 gulp -v 应该可以看到gulp的版本信息。 全局安装 yeoman 在项目中，yeoman 用于自动生成与boot同级的模块目录和文件。 $ npm install yeoman -g 若windows系统中安装失败. 可尝试运行。 $ npm -g install yo 安装成功后，在终端里运行 yo --version 应该可以看到yeoman的相关信息。 全局安装 python 在项目中，python用于执行功能性脚本。 在Windows上安装python 首先 从python的官方网站python.org下载最新的2.7版本 网速慢的请移步国内镜像。 然后，运行下载的MSI安装包，在选择安装组件的一步时，勾上所有的组件: 特别要注意选上pip和Add python.exe to Path 然后一路点\"Next\"即可完成安装。 默认会安装到C:\\Python27目录下，然后打开命令提示符窗口，敲入python后，会出现两种情况: 情况一： 看到上面的画面，就说明python安装成功！ 情况二： 得到一个错误: ‘python’不是内部或外部命令，也不是可运行的程序或批处理文件。 这是因为windows会根据一个path的环境变量设定的路径去查找python.org，如果没找到，就会报错。如果在安装时漏掉了勾选Add python.exe to Path 那就要手动把python.exe所在的路径添加到Path中。 克隆代码 可以新建一个 hap-cloud-front 的目录，进入到该目录下，在终端执行 git clone -b release-1.2.0 https:/xxxx@rdc.hand-china.com/gitlab/HAPCloud/HAPCloudFront.git --recursive 其中 xxxx 是你的工号。 (确保克隆之前设置了 git config --global user.name git config --global user.email ) git submodule 子模块操作 git config 配置操作 运行代码 进入到项目根目录，打开终端，键入bash boot\\structure\\npm.sh boot iam。 安装依赖完成后，执行node_modules/.bin/gulp 如果已全局安装gulp 则可直接执行gulp 不要关闭该终端(在iam等其他模块项目中源文件发生修改时，gulp会自动检测修改并同步)，新开一个git bash同样在该目录下执行 npm run dev 启动项目，看到如图所示效果说明启动成功 提示: (可以通过 gulp clean 删除所有自动生成的文件 再通过 gulp 来重新生成，再重新启动 npm start ，这样可以解决有时页面未更新的状态) 查看效果 在浏览器中键入 localhost:9090/ Lunix下软件安装 安装工具 NVM VScode或其他代码编辑器安装 Git NVM 安装 打开终端 输入 curl -o- https:/raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 如果没有curl命令，可以通过wget\b命令: wget -qO- https:/raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 在~/.nvm ~/.bash_profile ~/.zshrc ~/.profile ~/.bashrc 其中任意一个文件中加入 export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm 这里修改~/.profile vim ~/.profile 如果没有vim \bapt-get install vim或者直接编辑文件 然后输入source ~/.profile 通过nvm -v\b便可以看到nvm\b版本和相关操作 通过nvm install 6.11.4安装node的6.11.4版本 其他版本相似 详细\bNVM安装使用和系统权限等问题可看文档（通过其他方式\b进行安装） NVM的github git 安装 \b打开终端 输入 apt-get install git 安装\b\b\bgit命令 VScode或其他代码编辑器安装 在 VScode官网 下载安装 在 WebStorm官网 下载安装 全局安装 Webpack 我们希望能够在系统的任何文件夹中使用 Webpack，使用的方式是通过 Webpack 命令来完成的，这需要我们全局安装 Webpack。这也只需要安装一次，以后每个项目就不需要重新全局安装了。 $ npm install webpack -g 成功安装之后，你应该能够在任何目录中执行 webpack 命令，如果你还没有项目的配置文件的话，应该会看到当前的 Webpack 版本和一个命令的帮助列表。 全局安装 Gulp 在项目中，gulp 用于监视各模块文件的变化和同步相应的文件到boot目录中。 $ npm install gulp -g 安装成功后，在终端里运行 gulp -v 应该可以看到gulp的版本信息。 全局安装 yeoman 在项目中，yeoman 用于自动生成与boot同级的模块目录和文件。 $ npm -g install yo 安装成功后，在终端里运行 yo --version 应该可以看到yeoman的相关信息。 在linux上安装python 直接使用apt-get进行安装 apt-get install python && python-pip 源代码进行安装 准备编译环境 yum groupinstall 'Development Tools' yum install zlib-devel bzip2-devel openssl-devel ncurses-devel 下载python2.7代码包 wget https:/www.python.org/ftp/python/2.7.14/Python-2.7.14.tar.xz 在安装包中有一个README的文件，里面有写如何安装 tar Jxvf Python-2.7.14.tar.xz cd Python-2.7.14 ./configure --prefix=/usr/local/python make && make install 做软链接 ln -s /usr/local/python3/bin/python2.7 /usr/local/bin/python 安装成功后，如果提示：Ignoring ensurepip failure:pip 7.1.2 requires SSL/TLS 这是由于没有安装或升级oenssl yum install openssl-devel 再次重复编译方案python2.7 提示同时成功安装pip-7.12与setuptools 做软链接 ln -s /usr/local/python3/bin/pip /usr/local/bin/pip 升级pip到最新版本 pip install --upgrade pip 克隆代码 可以新建一个 hap-cloud-front 的目录，进入到该目录下，在终端执行 git clone -b release-1.2.0 https:/xxxx@rdc.hand-china.com/gitlab/HAPCloud/HAPCloudFront.git --recursive 其中 xxxx 是你的工号。 (确保克隆之前设置了 git config --global user.name git config --global user.email ) git submodule 子模块操作 git config 配置操作 运行代码 进入到项目根目录，打开终端，键入bash boot\\structure\\npm.sh boot iam。 安装依赖完成后，执行node_modules/.bin/gulp 如果已全局安装gulp 则可直接执行gulp 不要关闭该终端(在iam等其他模块项目中源文件发生修改时，gulp会自动检测修改并同步)，新开一个git bash同样在该目录下执行 npm start 启动项目，看到如图所示效果说明启动成功 提示: (可以通过 gulp clean 删除所有自动生成的文件 再通过 gulp 来重新生成，再重新启动 npm start ，这样可以解决有时页面未更新的状态) 查看效果 在浏览器中键入 localhost:9090/ 前端开发手册 目录划分 开发仿照iam项目结构（推荐通过yo命令自动生成目录结构，节省自动建立目录时间），源文件目录在 iam/src/app/iam ，主要目录结构如下： . ├── package-lock.json ├── package.json ├── src │ └── app │ └── iam │ ├── assets │ │ ├── css │ │ │ ├── Codemirror.less │ │ │ ├── logView.less │ │ │ └── search.less │ │ └── images │ │ ├── gulp.png │ │ ├── react.png │ │ └── webpack.png │ ├── common │ │ ├── IconAntd.js │ │ ├── IconMaterial.js │ │ ├── Icons.js │ │ ├── Permission.js │ │ └── RouteMap.js │ ├── components │ │ ├── ClientSearch.js │ │ ├── Codemirror.js │ │ ├── FullButton.js │ │ ├── MasterHeaderCopys.js │ │ ├── SearchField.js │ │ ├── memberRole │ │ │ ├── PoReRoleCas.js │ │ │ ├── ReRoleCas.js │ │ │ ├── RoleCas.js │ │ │ ├── RoleCasPro.js │ │ │ ├── RoleList.js │ │ │ ├── RolePanels.js │ │ │ └── globalRoleCas.js │ │ ├── menuOld │ │ │ ├── CommonMenu.js │ │ │ ├── LeftIconButton.js │ │ │ ├── MainMenuOne.js │ │ │ ├── MainMenuold.js │ │ │ ├── MenuTitle.js │ │ │ ├── MenuType.js │ │ │ ├── MutilMenu.js │ │ │ ├── ResourceMenu.js │ │ │ ├── RightIconButton.js │ │ │ ├── headerOrg.js │ │ │ └── menu.css │ │ ├── menuType │ │ │ ├── menuType.js │ │ │ └── menuType.less │ │ ├── organization │ │ │ ├── DeploymentTable.js │ │ │ ├── Label.js │ │ │ ├── LabelList.js │ │ │ ├── LabelTable.js │ │ │ ├── OrganizationList.js │ │ │ ├── ServiceDeployment.js │ │ │ ├── ServiceTable.js │ │ │ ├── labelOrganizationList.js │ │ │ ├── reLabel.js │ │ │ └── reLabelTable.js │ │ └── rightTabs │ │ ├── RightTab.js │ │ └── rightTab.less │ ├── config │ │ ├── Menu.yml │ │ └── language │ │ ├── en.yml │ │ └── zh.yml │ ├── containers │ │ ├── Home.js │ │ ├── IAMIndex.js │ │ ├── MasterOld2.js │ │ ├── Masters.js │ │ ├── MastersNew.js │ │ ├── MatersOld.js │ │ ├── global │ │ │ ├── MemberRole │ │ │ │ ├── GlobalIndex.js │ │ │ │ ├── GlobalMemberRole.css │ │ │ │ └── GlobalMemberRole.js │ │ │ ├── Menu │ │ │ │ ├── GlobalMenuPermission.js │ │ │ │ └── MenuIndex.js │ │ │ ├── MenuPermission │ │ │ │ ├── EditRole.js │ │ │ │ ├── MenuPermission.js │ │ │ │ ├── MenuPermissionIndex.js │ │ │ │ └── role.css │ │ │ ├── MenuTree │ │ │ │ ├── InputIcon.js │ │ │ │ ├── MenuDetail.js │ │ │ │ ├── MenuTree.js │ │ │ │ ├── MenuTreeIndex.js │ │ │ │ ├── MenuTreeOld.js │ │ │ │ ├── node.js │ │ │ │ ├── react-ui-tree.js │ │ │ │ ├── theme.less │ │ │ │ └── tree.js │ │ │ ├── adminOrganization │ │ │ │ ├── AdminOrganization.js │ │ │ │ ├── AdminOrganizationIndex.js │ │ │ │ ├── AdminOrganizationLabel.js │ │ │ │ ├── CreateAdminOrganization.js │ │ │ │ ├── EditAdminOrganization.js │ │ │ │ └── LabelOrganization.js │ │ │ ├── excel │ │ │ │ ├── Excel.js │ │ │ │ └── ExcelIndex.js │ │ │ ├── permission │ │ │ │ ├── permission.js │ │ │ │ └── permissionIndex.js │ │ │ ├── role │ │ │ │ ├── CreateRole.js │ │ │ │ ├── EditRole.js │ │ │ │ ├── Role.js │ │ │ │ ├── RoleIndex.js │ │ │ │ └── role.css │ │ │ ├── service │ │ │ │ ├── Service.js │ │ │ │ └── ServiceIndex.js │ │ │ └── token │ │ │ ├── CreateSaasToken.js │ │ │ ├── SaasToken.js │ │ │ └── TokenIndex.js │ │ ├── master.css │ │ ├── organization │ │ │ ├── adminClient │ │ │ │ ├── Client.js │ │ │ │ ├── ClientIndex.js │ │ │ │ ├── CreateClient.js │ │ │ │ └── EditClient.js │ │ │ ├── adminDeploymentLabel │ │ │ │ ├── AdminLabel.js │ │ │ │ ├── AdminLabelIndex.js │ │ │ │ └── AdminLabels.js │ │ │ ├── client │ │ │ │ ├── ClientDetail.js │ │ │ │ ├── ClientIndex.js │ │ │ │ ├── Clients.js │ │ │ │ ├── CreateClient.js │ │ │ │ └── EditClient.js │ │ │ ├── language │ │ │ │ ├── EditLanguage.js │ │ │ │ ├── Language.js │ │ │ │ └── LanguageIndex.js │ │ │ ├── ldap │ │ │ │ ├── EditLDAP.js │ │ │ │ └── LDAPIndex.js │ │ │ ├── lookup │ │ │ │ ├── CreateLookup.js │ │ │ │ ├── EditLookup.js │ │ │ │ ├── Lookup.js │ │ │ │ └── LookupIndex.js │ │ │ ├── memberRole │ │ │ │ ├── MemberRole.js │ │ │ │ ├── MemberRoleIndex.js │ │ │ │ ├── ReMemberRole.css │ │ │ │ ├── ReMemberRole.js │ │ │ │ └── all.css │ │ │ ├── organization │ │ │ │ ├── Organization.js │ │ │ │ └── OrganizationIndex.js │ │ │ ├── passwordPolicy │ │ │ │ ├── PasswordPolicy.js │ │ │ │ ├── PasswordPolicyIndex.js │ │ │ │ └── UpdatePasswordPolicy.js │ │ │ ├── project │ │ │ │ ├── CreateProject.js │ │ │ │ ├── EditProject.js │ │ │ │ ├── Project.js │ │ │ │ └── ProjectIndex.js │ │ │ ├── reProject │ │ │ │ ├── Project.js │ │ │ │ └── project.less │ │ │ ├── user │ │ │ │ ├── CreateUser.js │ │ │ │ ├── EditUser.js │ │ │ │ ├── ModifyPassword.js │ │ │ │ ├── User.js │ │ │ │ ├── UserDetail.js │ │ │ │ ├── UserIndex.js │ │ │ │ └── UserInfo.js │ │ │ └── userGroup │ │ │ ├── CreateUserGroup.js │ │ │ ├── UserGroup.js │ │ │ ├── UserGroupIndex.js │ │ │ └── userGroup.css │ │ └── project │ │ ├── language │ │ │ ├── EditLanguage.js │ │ │ ├── Language.js │ │ │ └── LanguageIndex.js │ │ └── memberRole │ │ ├── MemberRole.js │ │ ├── MemberRoleIndex.js │ │ ├── ReMemberRole.css │ │ ├── ReMemberRole.js │ │ └── all.css │ ├── locale │ │ ├── en.js │ │ └── zh.js │ ├── stores │ │ ├── globalStores │ │ │ ├── GlobalMenuStore.js │ │ │ ├── MemberRoleStore.js │ │ │ ├── MenuTreeStore.js │ │ │ ├── role │ │ │ │ └── RoleStore.js │ │ │ ├── service │ │ │ │ └── ServiceStore.js │ │ │ └── token │ │ │ └── SaasTokenStore.js │ │ ├── organization │ │ │ ├── adminClient │ │ │ │ └── AdminClientStore.js │ │ │ ├── adminOrganization │ │ │ │ ├── AdminOrganizationStore.js │ │ │ │ └── LabelStore.js │ │ │ ├── client │ │ │ │ └── ClientStore.js │ │ │ ├── excel │ │ │ │ └── ExcelStore.js │ │ │ ├── language │ │ │ │ └── LanguageStore.js │ │ │ ├── ldap │ │ │ │ └── LDAPStore.js │ │ │ ├── lookup │ │ │ │ └── LookupStore.js │ │ │ ├── memberRole │ │ │ │ └── MemberRoleStore.js │ │ │ ├── organization │ │ │ │ └── OrganizationStore.js │ │ │ ├── passwordPolicy │ │ │ │ └── PasswordPolicyStore.js │ │ │ ├── project │ │ │ │ └── ProjectStore.js │ │ │ ├── reProject │ │ │ │ └── ProjectStore.js │ │ │ ├── user │ │ │ │ ├── CreateUserStore.js │ │ │ │ └── UserStore.js │ │ │ └── userGroup │ │ │ └── UserGroupStore.js │ │ └── project │ │ └── memberRole │ │ └── MemberRoleStore.js │ └── test │ └── index.test.js ├── tsconfig.json └── yarn.lock containers 存放前端的页面 stores 存放前端页面所需的数据 assets 存放样式表和图片资源 common 存放公共的配置文件 components 存放的是公共的组件 local 存放多语言文件 config 存放yml配置文件 test 存放测试文件 文件命名方式 文件夹命名 统一小写，比如模块 user。同一个模块的组件都放在同一个目录下，比如与 user 相关的 UserIndex EditUser 等文件。 组件命名 采用帕斯卡命名规范，单个单词首字母大写，比如 User 多个单词仅首字母大写，比如 CreatUser "},"/zh/docs/development-guide/front/new":{"url":"zh/docs/development-guide/front/new","title":"开发新功能","description":"","language":"zh","body":"开发新页面 新建文件夹 在 \\iam\\src\\app\\iam\\containers\\organization目录下新建一个新的功能文件夹\\demo及其相关的JS文件： // Demo.js文件 import React { Component } from 'react'; import { withRouter } from 'react-router-dom'; class Demo extends Component { render() { return ( {'Hello it\\'s a demo!'} ); } } export default withRouter(Demo); // DemoIndex.js文件 import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../../util/asyncRouter'; const Demo = asyncRouter(()=>import('./Demo')); const DemoIndex = ({ match }) => ( ); export default DemoIndex; 配置路由 在\\iam\\src\\app\\iam\\containers\\IAMIndex.js文件中配置新建文件的访问路径： ... //异步路由 const DemoIndex = asyncRouter(()=>import('./organization/demo/DemoIndex')); ... ... 注意： 本次demo的访问路径应该为： /iam/demo ，因为在gulp自动生成路由配置时，IAMIndex的路由被映射为iam 配置完路由信息后就可以使用url访问刚刚新建的文件了。 获取后台数据 文件可以被访问后，接下来就是完善界面信息，从后台获取数据。获取数据的方法都写在和文件对应的store文件中。 axios()函数 axios()可以设置全局的配置，例如请求头信息，拦截器等，这样的好处是可以避免重复配置。 常用方法： axios.request(config) axios.get(url[ config]) axios.delete(url[ config]) axios.head(url[ config]) axios.post(url[ data[ config]]) axios.put(url[ data[ config]]) axios.patch(url[ data[ config]]) // store/organization/demo/DemoStore.js文件 import { observable action computed } from 'mobx'; // 该axios是封装过的，设置了请求头信息和响应拦截器 import axios from 'Axios'; import store from 'Store'; // store注解符令组件可以通过DemoStore来找到该store @store('DemoStore') class DemoStore { @observable roles = []; @computed get getRoles() { return this.roles.slice(); } @action setRoles(data) { this.roles = data; } loadRole() { axios.get('uaa/v1/roles?page=0&size=100').then((data) => { if (data) { this.setRoles(data.content); } }); } } const demoStore = new DemoStore(); export default demoStore; 更多关于axios()的相关信息可以参考：https://www.npmjs.com/package/axios 前端数据渲染 拿到后台数据后就可以将数据渲染到界面了，下面将介绍如何将数据渲染到前端界面： 加载DemoStore 修改\\iam\\src\\app\\iam\\containers\\organization\\demo\\DemoIndex.js，添加添加异步加载DemoStore： // DemoIndex.js文件 import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../../util/asyncRouter'; // DemoIndex.js文件中异步加载DemoStore const Demo = asyncRouter(() => import('./Demo') () => import('../../../stores/organization/demo/DemoStore')); const DemoIndex = ({ match }) => ( ); export default DemoIndex; 获取数据并渲染 在 react 的状态处理函数 componentDidMount() 中调用 loadRoles 函数获取数据，此时才真正拿到后台的数据。数据被存储在了组件的 props.DemoStore.roles 中。我们可以在 render() 中（或者在任何 componentDidMount() 函数之后执行的函数中）查看拿到的数据：console.log(this.props.DemoStore.getRoles())。 componentDidMount(){ this.props.DemoStore.loadRoles(); } 更多关于react的信息可以参考： https://hulufei.gitbooks.io/react-tutorial/content/introduction.html 最终的demo界面源码如下： import React { Component } from 'react'; import { Table } from 'antd'; import { observer } from 'mobx-react'; import { withRouter } from 'react-router-dom'; @observer class Demo extends Component { componentDidMount() { this.props.DemoStore.loadRole(); } render() { const columns = [{ title: HAP.languageChange('role.name') dataIndex: 'name' key: 'name' } { title: HAP.languageChange('role.level') dataIndex: 'roleLevel' key: 'roleLevel' } { title: HAP.languageChange('role.description') dataIndex: 'description' key: 'description' } { title: HAP.languageChange('role.serviceName') dataIndex: 'serviceName' key: 'serviceName' }]; return ( ); } } // withRouter添加history支持 export default withRouter(Demo); 开发新模块 新建模块 新建模块 切换到boot/generator-hap的目录下，运行 npm link 。 在项目根目录，运行 yo hap 则会出现需要输入和选择的信息. 注意: 在后面文档中 模块名默认输入的是demo 如果输入的其他的模块名 相应替换便可。 信息如图所示: 此时会自动构建模块的结构，目录结构如图所示: 然后进入到 boot 的目录下 运行 gulp 之后运行 npm start 启动项目 在 localhost:9090/#/demo 便可以查看页面. 其中 输入的模块名 + Index 文件是必须的，该文件的命名规则为 模块名的大写 + Index ，如若模块名为test，则该文件应命名为TESTIndex.js，这是在gulp的配置文件中规定的。 配置路由 在containers 目录中新建test\\Page1.js： import React from 'react'; const Page1 = () => ( This is page1! ); export default Page1; 在containers 目录中新建test\\Page1Index.js 配置Page1的访问路径： //Page1Index.js文件 import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../util/asyncRouter'; const Page1 = asyncRouter(()=>(import('./Page1'))); const Page1Index=({ match })=>( ); export default Page1Index; 在DEMOIndex.js文件 配置demo模块的路由： import React {Component} from 'react'; import { Route Switch } from 'react-router-dom' import asyncRouter from '../../../util/asyncRouter' class DEMOIndex extends Component { render() { const Home = asyncRouter(() => import('./Home')); const Page1Index = asyncRouter(() => import('./test/Page1Index')); const {match} = this.props; return ( ) } } export default DEMOIndex; 查看效果 在浏览器中键入 http://localhost:9090/#/demo 在浏览器中键入 http://localhost:9090/#/demo/page1 提示: 在新模块中开发新页面与前面在iam中开发新页面的规则和规范完全一致 可以参考iam中开发过程。 第三方文件包安装 如果开发模块需要其他的第三方安装包 可以直接添加在模块package.json文件 在部署集成时 通过执行boot目录下的 npm run preinstall 可以将各个子模块package.json文件合并到boot的package.json文件中 再执行npm install安装项目依赖。 权限组件 通过引入权限组件，可以动态判断用户是否具有此操作权限，并控制页面是否展示功能。 引用 通过组件头部引入权限组件 ... import Permission from 'PerComponent'; ... 调用 调用权限组件需要额外当前组织或项目类型和id参数 在组件头部引入inject组件 导入Appstate ... import { inject } from 'mobx-react' ... @inject('AppState') 在组件适当位置获取当前组织或项目类型type和id 如果当前组件在组织层 ... const { AppState } = this.props; const menuType = AppState.currentMenuType; const organizationId = menuType.id; let type; if (AppState.getType) { type = AppState.getType; } else if (sessionStorage.type) { type = sessionStorage.type; } else { type = menuType.type; } ... 如果当前组件在项目层 ... const { AppState } = this.props; const menuType = AppState.currentMenuType; const organizationId = menuType.organizationId; const projectId = menuType.id; let type; if (AppState.getType) { type = AppState.getType; } else if (sessionStorage.type) { type = sessionStorage.type; } else { type = menuType.type; } ... 在需要调用权限的地方用Permission包裹住要展示的组件，如果有权限则展示，没有则隐藏 ... that} > ... Permission组件的service参数是后台存储的权限code，可以通过不同服务的api接口获取。 项目配置项 配置项详解 为了应对不同开发环境和不同项目需求，可以对hap cloud框架多个配置进行个性化。 配置项文件在项目根目录的config.js文件中。看起来是这样的 const config = { local: false clientId: 'localhost' titlename: 'HAPCloud' favicon: 'a.png' theme: true mainCss: JSON.stringify('boot') Masters: JSON.stringify('boot') Home: JSON.stringify('iam') themeSetting: { antdTheme: { 'primary-color': '#3b78e7' } header: '#3F51B5' backgroundColor: 'white' } server: 'http://gateway.devops.saas.hand-china.com' }; module.exports = config; 参数 说明 local 是否本地开发，如果是true，点击本地开发没有的模块菜单，会跳转到404，否则会跳转已发布的线上域名 clientId 认证成功之后的回调参数，对应后端的回调地址 titlename 标签页名称 favicon 标签页图标 theme 是否开启主题色设定 mainCss 选择哪个模块的主css文件 Masters 选择哪个模块的master.js文件作为入口文件 Home 选择哪个模块的Home.js文件作为Home页 primary-color antd的主体颜色设定 header 头部主题色 backgroundColor 背景色 server 后端的api host地址 新建或覆盖全局配置 在项目根目录右键git bash here 输入yo hap:1.2.0 根据提示 键入各个配置项参数 完成后将会覆盖原有config文件 菜单配置 在Hap Cloud之前开发版本中，前端新加模块和页面，想在菜单中显示需要跟后端沟通各种事宜与配置，大大增加了开发效率与成本。在此版本中，只需要简单配置，菜单数据完全由前端控制。 以iam模块为例. 在模块内部创建config文件夹，目录结构为： ├── language | ├── en.yml | └── zh.yml | └── Menu.yml 文件 说明 language 菜单中英文配置文件夹 en.yml 英文菜单 zh.yml 中文菜单 Menu.yml 菜单配置项 Menu.yml文件内容看起来是这样的: \"iam\": # 此处为最外层的模块服务字段 icon: account_circle # 服务的图标 global: # global层的菜单 - \"role\": # 菜单字段 icon: assignment_ind # 菜单图标 Routes: /iam/role # 菜单对应路由 permission: # 菜单内容具有的权限 - 'hap-user-service.role.update' - 'hap-user-service.role.delete' - 'hap-user-service.role.select' - 'hap-user-service.role.updateRoleWithPermission' - 'hap-user-service.role.createRoleWithPermission' - \"permission\": icon: verified_user Routes: /iam/permission permission: - 'hap-user-service.permission.awesomeSelect' - \"menu-management\": icon: view_list Routes: /iam/menuTree permission: - 'hap-user-service.menu.menuOrganizations' - 'hap-user-service.menu.menuProjects' - 'hap-user-service.menu.menuGlobal' - \"menu-permission\": icon: security Routes: /iam/globalMenuPermission permission: - 'hap-user-service.menu.selectAll' - \"member-role-global\": icon: person_add Routes: /iam/globalMemberRole permission: - 'hap-user-service.member-role-global.delete' - 'hap-user-service.member-role-global.create' - 'hap-user-service.member-role-global.select' - 'hap-user-service.member-role-global.update' - \"service\": icon: next_week Routes: /iam/service permission: - 'hap-user-service.service.self' - 'hap-user-service.service.select' organization: # 组织层的菜单 - \"client\": icon: laptop_mac Routes: /iam/client permission: - 'hap-user-service.client.create' - 'hap-user-service.client.update' - 'hap-user-service.client.delete' - 'hap-user-service.client.select' - \"ldap\": icon: device_hub Routes: '/iam/ldap' permission: - 'hap-user-service.ldap.updateSelf' - 'hap-user-service.ldap.query' - \"password-policy\": icon: verified_user Routes: /iam/password-policy permission: - 'hap-user-service.password-policy.updateSelf' - 'hap-user-service.password-policy.queryOrganization' - \"user\": icon: person Routes: /iam/user permission: - 'hap-user-service.user.updateUser' - 'hap-user-service.user.create' - 'hap-user-service.user.delete' - 'hap-user-service.user.select' - 'hap-user-service.user.query' - \"project\": icon: widgets Routes: /iam/project permission: - 'hap-user-service.project.crete' - 'hap-user-service.project.update' - 'hap-user-service.project.delete' - 'hap-user-service.project.query' - 'hap-user-service.project.select' - \"member-role-organization\": icon: person_add Routes: /iam/origanizationMemberRole permission: - 'hap-user-service.member-role-organization.create' - 'hap-user-service.member-role-organization.delete' - 'hap-user-service.member-role-organization.update' - 'hap-user-service.member-role-organization.select' - \"user-groups\": icon: people Routes: /iam/userGroup permission: - 'hap-user-service.groups.update' - 'hap-user-service.user-groups.insertUserGroups' - 'hap-user-service.groups.delete' project: # 项目层的菜单 - \"member-role-project\": icon: person_add Routes: /iam/projectMemberRole permission: - 'hap-user-service.member-role-project.create' - 'hap-user-service.member-role-project.delete' - 'hap-user-service.member-role-project.select' - 'hap-user-service.member-role-project.update' user: # 个人中心层的菜单 - \"user-info\": icon: more Routes: /iam/user/info permission: - 'hap-user-service.user-info.querySelf' - 'hap-user-service.user-info.updateSelf' - \"password\": icon: grain Routes: /iam/user/modifyPwd permission: - 'hap-user-service.password-policy.queryOrganization' - 'hap-user-service.password-policy.updateSelf' - 'hap-user-service.password.updateSelf' - \"token\": icon: lock Routes: /iam/token permission: - 'hap-user-service.token.querySelf' - 'hap-user-service.token.create' - 'hap-user-service.token.deleteSelf' en.yml文件内容： \"iam\": IAM \"iam.client\": \"Client\" \"iam.ldap\": \"LDAP\" \"iam.member-role-global\": \"Role Assignment\" \"iam.member-role-organization\": \"Role Assignment\" \"iam.member-role-project\": \"Role Assignment\" \"iam.menu-management\": \"Menu Setting\" \"iam.organization\": \"Organization\" \"iam.password\": \"Password Modification\" \"iam.password-policy\": \"Password Policy\" \"iam.permission\": \"Permission\" \"iam.project\": \"Project\" \"iam.role\": \"Role\" \"iam.service\": \"Service\" \"iam.token\": \"Authorization\" \"iam.user\": \"User\" \"iam.user-groups\": \"User Group\" \"iam.user-info\": \"User Information Maintenance\" \"iam.menu-permission\": \"Menu Permission\" 模板为[服务字段].[菜单字段]: [菜单英文名] zh.yml文件内容： \"iam\": \"用户服务\" \"iam.client\": \"客户端\" \"iam.ldap\": \"LDAP\" \"iam.member-role-global\": \"角色分配\" \"iam.member-role-organization\": \"角色分配\" \"iam.member-role-project\": \"角色分配\" \"iam.menu-management\": \"菜单配置\" \"iam.organization\": \"组织\" \"iam.password\": \"密码修改\" \"iam.password-policy\": \"密码策略\" \"iam.permission\": \"权限\" \"iam.project\": \"项目\" \"iam.role\": \"角色\" \"iam.service\": \"服务\" \"iam.token\": \"授权\" \"iam.user\": \"用户\" \"iam.user-groups\": \"用户组\" \"iam.user-info\": \"用户信息维护\" \"iam.menu-permission\": \"菜单权限\" 模板为[服务字段].[菜单字段]: [菜单中文名] 在项目根目录下，执行python .\\boot\\structure\\configAuto.py iam(确保python版本为2.7.x 以及本地安装pyyaml包)脚本。 成功之后在项目根目录会生成config.yml文件。 然后再执行python ./boot/structure/pythonsql.py -i ip地址 -p 端口号 -u \b用户名 -s 密码 在部署时候也可通过环境变量进行传递参数 变量名 说明 DB_HOST 用户名 DB_PORT 端口 DB_USER 用户名 DB_PASS 密码 成功后，会将前端配置的菜单信息插入后端数据库中。 如果要\b显示插入的菜单，需要在全局层的菜单配置下，进行页面操作，将\b数据已有的菜单\b展示在菜单列。 "},"/zh/docs/development-guide/front/problems/":{"url":"zh/docs/development-guide/front/problems/","title":"常见问题","description":"","language":"zh","body":""},"/zh/docs/development-guide/front/problems/problems":{"url":"zh/docs/development-guide/front/problems/problems","title":"npm install失败","date":"2017-02-01","language":"zh","body":"npm install失败 情景 windows系统下由于node版本升级可能导致npm install出现如下图所示错误 解决办法 使用nvm node版本管理工具(推荐) 经过测试，node版本高于8.0.0会出现这个错误。 推荐使用nvm node版本管理工具动态切换node版本来解决这个问题 进入nvm安装链接 下载nvm-setup.zip 安装完毕后，控制台输入nvm -v出现 说明nvm安装成功 在控制台键入nvm install 6.11.0 安装完后键入nvm use 6.11.0 成功将node版本切换到6.11.0 之后再npm install 就不会出现报错信息了 "},"/zh/docs/development-guide/front/problems/undefined":{"url":"zh/docs/development-guide/front/problems/undefined","title":"项目运行出现打包文件未找到","language":"zh","body":"项目运行出现打包文件未找到 情景 由于webpack打包运用HardSourceWebpackPlugin缓存打包机制，在优化打包速度的过程中，同时带来一些不可比避免的问题 如果在拉取新代码，本地编译后，项目控制台显示无法找到打包文件时， 停止编译控制台，在boot目录下执行npm run dev，多数情况会解决这种问题 "},"/zh/docs/development-guide/front/style_specification/":{"url":"zh/docs/development-guide/front/style_specification/","title":"代码和样式编写规范","description":"","language":"zh","body":""},"/zh/docs/development-guide/front/style_specification/code":{"url":"zh/docs/development-guide/front/style_specification/code","title":"代码规范","language":"zh","body":"代码规范 代码规范 采用Alibnb规范 https://github.com/airbnb/javascript 代码注释 新建文件，头部进行注释。 /* author: xxx@hand-china.com time: 2017-2-17 feature: 模块功能 */ class User extends Component{ …… …… } 函数功能注释 //feature:输出变量的值 function inputDome(demo) { console.log(demo); }; eslint规范 项目eslint配置为 { \"root\": true \"parser\": \"babel-eslint\" \"env\": { \"browser\": true \"node\": true \"es6\": true // \"worker\": true } \"parserOptions\": { \"ecmaVersion\": 6 \"sourceType\": \"module\" \"ecmaFeatures\": { \"jsx\": true } } \"plugins\": [ \"react\" ] \"extends\": \"airbnb\" \"rules\": { \"react/jsx-no-bind\": [ \"error\" { \"ignoreRefs\": true \"allowArrowFunctions\": true \"allowBind\": true } ] \"react/prefer-stateless-function\": [\"off\" { \"ignorePureComponents\": true } ] \"jsx-a11y/interactive-supports-focus\": \"off\" \"no-trailing-spaces\": \"off\" \"class-methods-use-this\": \"off\" \"import/no-extraneous-dependencies\": \"off\" \"no-else-return\": \"off\" \"linebreak-style\": \"off\" \"import/extensions\": \"off\" \"import/no-unresolved\": \"off\" \"react/prop-types\": \"off\" \"react/jsx-filename-extension\": \"off\" \"jsx-a11y/href-no-hash\": \"off\" \"react/require-default-props\": \"off\" \"no-console\": \"warn\" \"no-debugger\": \"off\" \"jsx-a11y/anchor-is-valid\": [ \"warn\" { \"aspects\": [ \"invalidHref\" ] } ] } \"globals\": { \"HAP\": true } } "},"/zh/docs/development-guide/front/style_specification/style":{"url":"zh/docs/development-guide/front/style_specification/style","title":"样式规范","date":"2017-02-01","language":"zh","body":"样式规范 本项目相关样式主要参考谷歌云。暂定以下样式规范。 1.页面边距 页面内容内外边距默认制定为：“15px” 2.字体颜色 系统默认字体颜色为：“rgba(0 0 0 0.75)” 3.pageHeader pageHeader中button文内容最好控制在两位，例如：创建客户端修改为创建； 存在两个button情况下：“创建”离“客户端管理”30px，“刷新”离“创建”15px 4.提示 在需要对内容补充说明时使用“Popover”-气泡卡片组件；对图标icon的解释说明用“Tooltip”-提示组件 5.表格相关规范 “Table”组件默认大小使用size=“middle” 两张table之间间距“40px” 不使用table自带分页，分页组件table“15px” table如果可编辑（创建）的字段不超过3个时，使用模态框“Model”组件弹出编辑（创建）页；如果超过三个字段，则新建界面处理 "},"/zh/docs/development-guide/front/technology":{"url":"zh/docs/development-guide/front/technology","title":"技术栈","description":"","language":"zh","body":"Git简明教程 git 基本操作 git 基本操作 开发流程 获取仓库 添加至暂存区 代码commit 回撤到某个版本 分支操作 分支合并 远程分支 开发流程 Note. git commit 信息需注意分类 [FIX] 修复了功能 [MOD] 修改或重构 [ADD] 添加了功能 [DEL] 删除了功能 [IMP] 修改相关配置 获取仓库 git clone url --recursive git clone -b dev url Note: git clone -b 分支名 远程仓库地址 指定远程分支进行克隆 添加至暂存区 git add 文件名 将某文件从工作目录加入暂存区 git add . 添加工作区所有文件到暂存区 git reset HEAD 文件名 撤销某文件提交到暂存区的操作 Note: git reset 若加上--hard参数，将会把工作区的文件也进行改变 代码commit git commit -m \"commit信息\" 此命令将暂存区的文件载入至本地仓库 若commit后发现有文件未加入暂存区，故而没有commit，而不想生成两条commit信息，在没有对工作区修改的情况下可使用: git add 文件名 git commit --amend 这样便可以覆盖提交 回撤到某个版本 git checkout hash码 指定历史版本进行回撤，其效用等同于: git reset --hard hash码 s 若想在确保新文件不消失的情况下回撤到指定版本，则: git reset --soft hash码 分支操作 git branch 列出本地仓库的所有分支 git branch 分支名 新建分支 git checkout 分支名 切换到指定分支 git checkout -b 分支名 等价于 git branch 分支名 git checkout 分支名 分支合并 git merge 分支名 以当前分支合并其它分支 此操作建议在vscode或jetbrain的ide操作，以便于当代码冲突时直接在图形化界面中进行处理。若在命令行操作，则需手工查找冲突文件进行合并。 远程分支 git remote add 远程仓库别名 远程仓库url 添加远程仓库 git push -u origin [本地分支:]远程分支 推送本地分支到远程仓库的某分支 git pull 拉取远程仓库 git pull 等价于git fetch 紧跟 git merge Note. git pull 远程仓库别名 远程仓库分支 Note. git fetch 远程仓库别名 远程分支[:本地分支] Git简明教程 React 本项目使用React与Mobx作为前端框架，React 的核心思想是：封装组件。各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。我们不再需要查找某个 DOM 元素，然后操作 DOM 去更改 Mobx 是 JavaScript 状态容器，提供可预测化的状态管理。 import React { Component PropTypes } from 'react'; import { observer injext } from 'mobx-react'; @inject('AppState') @observer class Dashboard extends Component { constructor(props) { super(props); }; componentDidMount(){}; static propTypes = { }; static contextTypes = { router: PropTypes.object.isRequired }; render() { return ( ) } } function mapStateProps(state) { return { }; } module.exports = Dashboard; React Mobx mobx是一个react的状态管理库，相对于redux，它使用更加简便，可扩展性更强。 mobx 的核心理念是 简单、可扩展的状态管理库。 react 关注的状态(state)到视图(view)的问题。而 mobx 关注的是状态仓库（store）到的状态(state)的问题。 mobx有两个核心的概念 @observable 和 @observer ，它们分别对应的是被观察者和观察者。被观察者和一些操作函数共同组成了store，而观察者时刻观察着这些store的变化，当store内数据变化之后，观察者便会自动更新。 定义一个store class Store { // 被观察者 @observable todos = [{ title: \"完成 Mobx 翻译\" done: false }]; } 定义一个观察者 // 观察者 @observer class TodoBox extends Component { render() { return ( {this.props.store.todos.map(todo => {todo.title})} ) } 获取以及更新值 通常使用@computed get来获取值 使用@action对store内的数据进行修改 class Store { @observable todos = [{ title: \"todo标题\" done: false } { title: \"标题\" done: true }]; @action changeTodoTitle({index title}){ this.todos[index].title = title } @computed get finishedTodos () { return this.todos.filter((todo) => todo.done) } } Mobx相关资料:[http://eyehere.net/2016/mobx-getting-started/] Webpack 本项目选择Webpack作为脚手架 // webpack 配置文件 |-- packjson.js |-- webpack.config.js |-- webpack.dev.js |-- webpack.dev.production.js |-- webpack.dll.config.js |-- webpack.file.js |-- webpack.pro.config.js |-- webpack.production.js // npm相关命令 \"scripts\": { // 整合各个模块package.json \"adjustinstall\": \"node webpack/packjson.js\" //npm start 运行开发环境 \"start\": \"node bin/server\" //清除缓存 重新编译 \"dev\": \"rimraf .cache && npm start\" //npm run build 清除dist生成文件，并运行生产环境 \"build\": \"npm run clean && webpack --config ./webpack/webpack.production.js\" \"devbuild\": \"npm run clean && webpack --config ./webpack/webpack.dev.production.js\" //npm run clean 清除dist生成文件 \"clean\": \"rimraf dist\" //npm run test 运行测试文件 \"test:mocha\": \"./node_modules/.bin/mocha ./src/app/*/test/\" \"eslint\": \"eslint --ext .js src\" \"pre-push\": \"npm run eslint\" } webpack的基础配置 const HtmlWebpackPlugin = require('html-webpack-plugin'); const path = require('path'); const webpack = require('webpack'); const HappyPack = require('happypack'); const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin'); const config = require('./webpack.file'); const ExtractTextPlugin = require('extract-text-webpack-plugin'); const HardSourceWebpackPlugin = require('hard-source-webpack-plugin'); //处理 BashOnWindow 下的打包错误 try { require('os').networkInterfaces() } catch (e) { require('os').networkInterfaces = () => ({}) } module.exports = { entry: { // vendor: [\"react\" \"react-dom\" \"react-router-dom\" \"antd\" \"babel-polyfill\"] app: [ \"babel-polyfill\" 'react-hot-loader/patch' path.resolve(__dirname '../src/index.js') ] } output: { path: path.resolve(__dirname '../dist') filename: 'app/[name]_[hash:8].js' chunkFilename: 'app/chunks/[name].[chunkhash:5].chunk.js' } resolve: { modules: [path.resolve(__dirname '../src') path.resolve(__dirname '../node_modules') 'node_modules' ...config.pathModule] extensions: ['.js' '.json' '.jsx' '.ts' '.tsx' '.less'] alias: { Axios: path.resolve(__dirname '../src/containers/common/axios.js') Store: path.resolve(__dirname '../src/containers/common//store.js') RouteMap: path.resolve(__dirname '../src/app/generate/RouteMap.js') Icons: path.resolve(__dirname '../src/app/generate/Icons.js') Permission: path.resolve(__dirname '../src/app/generate/Permission.js') PerComponent: path.resolve(__dirname '../src/app/iam/components/permission.js') MainCss: path.resolve(__dirname `../src/app/${config.mainCss}/assets/css/main.less`) Masters: path.resolve(__dirname `../src/app/${config.Masters}/containers/Masters.js`) AutoRouter: path.resolve(__dirname '../src/app/generate/AutoRouter.js') MenuType: path.resolve(__dirname '../src/app/iam/components/menu/MenuType.js') MainMenu: path.resolve(__dirname '../src/app/iam/components/menu/MainMenu.js') ResourceMenu: path.resolve(__dirname '../src/app/iam/components/menu/ResourceMenu.js') UserPreferences: path.resolve(__dirname '../src/app/iam/containers/UserPreferences.js') IsAuthSpin: path.resolve(__dirname '../src/app/iam/components/IsAuthSpin.js') MasterHeader: path.resolve(__dirname '../src/app/iam/components/MasterHeader.js') LeftIconButton: path.resolve(__dirname '../src/app/iam/components/menu/LeftIconButton.js') MenuTitle: path.resolve(__dirname '../src/app/iam/components/menu/MenuTitle.js') Config: path.resolve(__dirname '../../config.js') } } module: { loaders: [{ loader: path.resolve(__dirname '../node_modules/happypack/loader.js') }] rules: [{ enforce: \"pre\" test: /\\.(js|jsx)$/ exclude: /node_modules/ loader: 'Happypack/loader?id=eslint' } { test: /\\.(js|jsx)$/ exclude: /node_modules/ loader: 'Happypack/loader?id=babel' } { test: /\\.(tsx?$)/ use: [{ loader: 'Happypack/loader?id=ts' }] exclude: /node_modules/ } { test: /\\.css$/ use: [{ loader: 'Happypack/loader?id=css' }] } { test: /\\.less$/ use: [{ loader: 'style-loader' } { loader: 'css-loader' } { loader: 'less-loader' options: { \"sourceMap\": true \"modifyVars\": config.themeSetting.antdTheme } }] } { test: /\\.(jpe?g|png|gif|svg|ico)/i use: [{ loader: 'file-loader' options: { name: 'img_[hash:8].[ext]' } }] } { test: /\\.(ttf|eot|svg|woff|woff2)/ use: [{ loader: 'file-loader' }] }] } plugins: [ new HappyPack({ id: 'eslint' threads: 1 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'eslint-loader' options: { emitError: true failOnWarning: true failOnError: true } }] }) new HappyPack({ id: 'babel' threads: 3 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'babel-loader' }] }) new HappyPack({ id: 'ts' threads: 1 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'ts-loader' }] }) new HappyPack({ id: 'ts' threads: 1 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'ts-loader' }] }) new HappyPack({ id: 'css' threads: 1 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'style-loader' } { path: 'css-loader' }] }) // new HappyPack({ // id: 'less' // threads: 1 // loaders: [{ // path: 'style-loader' // } { // path: 'css-loader' // } { // path: 'less-loader' // options: { // \"sourceMap\": true // \"modifyVars\": config.theme.antdTheme // } // }] // }) // new webpack.DllReferencePlugin({ // context: path.join(__dirname \"webpack\") // manifest: require(\"./dll/vendor-manifest.json\") // }) new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development') 'process.env.AUTH_HOST': JSON.stringify(`${process.env.SERVER}/oauth`) 'process.env.CLIENT_ID': JSON.stringify(`${config.clientid}`) 'process.env.API_HOST': JSON.stringify(`${process.env.SERVER}`) // 'process.env.API_HOST': JSON.stringify('http://gateway.hapcloud.stage.cloud.saas.hand-china.com') }) new HardSourceWebpackPlugin({ cacheDirectory: path.resolve('.cache' 'hard-source/[confighash]') recordsPath: path.resolve('.cache' 'hard-source/[confighash]/records.json') environmentHash: { root: process.cwd() directories: ['node_modules'] files: ['package.json'] } environmentHash: function() { return new Promise(function(resolve reject) { require('fs').readFile(path.resolve(__dirname '../yarn.lock') function(err src) { if (err) {return reject(err);} resolve( require('crypto').createHash('md5').update(src).digest('hex') ); }); }); } }) new HtmlWebpackPlugin({ title: config.titlename template: path.resolve(__dirname '../src/index.template.html') inject: true favicon: path.resolve(__dirname `../../${config.favicon}`) minify: { html5: true collapseWhitespace: true removeComments: true removeTagWhitespace: true removeEmptyAttributes: true removeStyleLinkTypeAttributes: true } }) // new AddAssetHtmlPlugin({ // filepath: path.resolve(__dirname 'dist/dll/dll.vendor.js') // }) ] }; Webpack的相关手册：https://webpack.js.org/ "},"/zh/docs/development-guide/front-environment-deployment":{"url":"zh/docs/development-guide/front-environment-deployment","title":"前端环境部署","date":"2017-10-30","language":"zh","body":"环境安装 HAP Cloud项目具有持续集成，持续部署功能。在项目根目录的.gitlab-ci.yml文件中，写明了项目提交到gitlab之后 gitlab ci执行的一系列打包编译工作，并且使用docker打包新项目镜像到远程地址。然后登录openshift，拉取远程镜像实现持续部署。 这一套流程是不需要本地安装部署环境的，但如果本地开发想要npm run build生成打包文件，并在本地docker build & push一个新的镜像，并自定义deployment.yml文件部署openshift的话，需要在本地进行如下环境安装。 docker安装 Ubuntu安装Docker Docker 支持以下版本的Ubuntu操作系统 Zesty 17.04 Xenial 16.04(LTS) Trusty 14.04(LTS) 使用APT镜像源安装 由于官方源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添 加使用 HTTPS 传输的软件包以及 CA 证书。 $ sudo apt-get update $ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 鉴于国内网络问题，强烈建议使用国内源，下面先介绍国内源的使用。 国内源 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 $ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 然后，我们需要向 source.list 中添加 Docker 软件源 $ sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。 官方源 $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 安装Docker 更新apt软件包缓存，并安装docker-ce: $ sudo apt-get update $ sudo apt-get install docker-ce 使用脚本自动安装 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚 本，Ubuntu 系统上可以使用这套脚本安装： $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 安装在系 统中。 启动Docker $ sudo systemctl enable docker $ sudo systemctl start docker Ubuntu 14.04请使用以下命令启动： $ sudo service docker start 建立docker用户组 默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于 安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将 需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： $ sudo groupadd docker 将当前用户加入 docker 组： $ sudo usermod -aG docker $USER macOS 安装Docker 系统要求 Docker for Mac 要求系统最低为 macOS 10.10.3 Yosemite，或者 2010 年以后的 Mac 机型，准确说是带 Intel MMU 虚拟化的，最低 4GB 内存。 如果系统不满足需求，可以安装 Docker Toolbox。 安装 使用 Homebrew 安装 Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装： brew cask install docker 手动下载安装 如果需要手动下载，可以通过这个链接下 载：https://download.docker.com/mac/stable/Docker.dmg 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将 那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间可能会询问系 统密码）。 运行 从应用中找到 Docker 图标并点击运行。 运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的 运行状态。 第一次点击图标，可能会看到这个安装成功的界面，点击 \"Got it!\" 可以关闭这个窗 口。 以后每次点击鲸鱼图标会弹出操作菜单。 启动终端后，通过命令可以检查安装后的 Docker 版本。 $ docker --version Docker version 1.12.3 build 6b644ec $ docker-compose --version docker-compose version 1.8.1 build 878cff1 $ docker-machine --version docker-machine version 0.8.2 build e18a919 如果 docker version 、 docker info 都正常的话，可以运行一个 Nginx 服务 器： $ docker run -d -p 80:80 --name webserver nginx 服务运行后，可以访问 http://localhost，如果看到了 \"Welcome to nginx!\"，就说明 Docker for Mac 安装成功了。 Windows 安装Docker 系统要求 Docker CE 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V。 安装 点击以下链接下载 stable 或 edge 版本的 Docker CE。 下载好之后双击 Docker for Windows Installer.exe 开始安装。 运行 在 Windows 搜索栏 输入 Docker 点击 Docker for Windows 开始运行。 Docker CE 启动之后会在 Windows 任务栏出现鲸鱼图标。 等待片刻，点击 Got it 开始使用 Docker CE。 docker使用教程 本地项目打包编译 HAP Cloud项目默认打包编译在boot目录下，查看boot目录下的package.json文件 在build脚本中定义了本地打包编译的步骤。 先删除本地dist文件夹 执行webpack.production.js文件 在终端进入boot目录下执行命令 npm run build 成功之后会在boot目录下生成dist文件夹 docker镜像打包发布 docker镜像仓库登录 在终端键入 docker login -u $REGISTRY_USER -p $REGISTRY_PWD $registry $REGISTRY_USER 为镜像仓库的登录用户名 $REGISTRY_PWD 为镜像仓库的登录密码 $registry 为镜像仓库地址 镜像构建 在上一步构建dist文件夹的目录下 新建一个Dockerfile文件 ### nginx镜像根据实际项目替换 FROM registry.saas.hand-china.com/tools/nginx:stable ### 后端api地址 根据实际项目替换 ENV PRO_API_HOST gateway.hapcloud.test.code.saas.hand-china.com ENV PRO_CLIENT_ID hapcloudfront ### 将dist文件夹添加到nginx镜像html目录下 ADD dist /usr/share/nginx/html ### 将boot/structure/enterpoint.sh 文件放入nginx/html目录下 COPY ./boot/structure/enterpoint.sh /usr/share/nginx/html ### 运行该enterpoint脚本文件 RUN chmod 777 /usr/share/nginx/html/enterpoint.sh ENTRYPOINT [\"/usr/share/nginx/html/enterpoint.sh\"] CMD [\"nginx\" \"-g\" \"daemon off;\"] ### 暴露80端口 EXPOSE 80 boot/structure/enterpoint.sh文件看起来是这样的 #!/bin/bash set -e ### 替换PRO_API_HOST和PRO_CLIENT_ID环境变量 find /usr/share/nginx/html -name '*.js' | xargs sed -i \"s/localhost:8080/$PRO_API_HOST/g\" find /usr/share/nginx/html -name '*.js' | xargs sed -i \"s/localhost:clientId/$PRO_CLIENT_ID/g\" exec \"$@\" 在此目录终端下，运行 ### $docker_Name为镜像名称 根据实际需求更改 docker build -t $docker_Name . 生成$docker_Name命名的镜像 镜像发布 ### $registry为远程镜像地址 根据实际项目更改 docker push $registry "},"/zh/docs/installation-configuration/":{"url":"zh/docs/installation-configuration/","title":"安装与配置","description":"","language":"zh","body":"安装与配置 Choerodon 采用Spring Cloud作为微服务框架，运行在Docker上，以Kubernetes作为容器的编排工具。理论上讲只要服务器资源允许，只要可以运行Kubernetes，就可以在Kubernetes上运行Choerodon。由于Choerodon不是一个单体应用系统，而是一个包含多个微服务的分布式系统，所以安装相对比较复杂，目前，我们不提供基于源码的安装方式，仅提供基于Docker镜像的安装方式。 根据Choerodon的系统架构，Choerodon有两个类型的部署，即开发区和运行区。作为应用的开发平台，可以安装开发区；作为应用的运行平台，可以仅安装运行区； 部署 由于Choerodon存在开发区和运行区的概念，用户可以根据自身的情况来决定采用哪一种方式。为了能够更加清晰的说明Choerodon的部署方式，下面我们将这两种不同的部署方式分别说明。在这之前，我们先来看一下Choerodon的系统服务架构图。关于Choerodon的详细系统架构，请参考系统架构。 其中，运行管理是属于运行区相关的主要服务，敏捷看板、移动开发、开发管理属于开发相关的主要服务。也就是说，我们在选择安装开发区和运行区的时候，可以根据这几个服务来决定。日志服务用来\b用来统一的管理和存储日志并为日后基于的分析提供基础，日志存储在elasticsearch集群中，由fluent-bit收集每个节点上的日志通过fluentd缓存之后发给elasticseach集群，kibana用以查看日志和界面搜索。日志的数据流转和安装文档详见此处。监控服务监控Choerodon的各个服务，确保各个服务和基础组件处在正常的运行中，当其中某一组件运行异常时发送告警提醒。监控服务的核心是Prometheus，Prometheus主动收集各个服务提供的指标信息，经过加工汇总对比预警规则满足条件时发送预警信息给alertmanager，alertmanger可以配置人员邮箱接口等信息实现报警信息按条件发送给不同的人员。关于监控架构和安装文档详见此处。 部署开发区 开发区包含了与开发相关的服务，用户可以使用此作为应用程序的开发平台。整个开发区部署在一个Kubernetes集群上，用户可以使用敏捷看板、移动开发、开发管理属于开发相关服务。开发区最终提交的结果是存储在Gitlab上的代码，当然可以选择是否生成Harbor镜像和相关部署文件。 关于如何安装和配置开发区，请参考开发区安装文档。 部署运行区 运行区包含了与运行相关的服务，用户可以使用此作为应用程序的运行平台。整个开发区部署在一个Kubernetes集群上，用户可以手工的将生成的docker镜像和部署文件，部署到运行区。 关于如何安装和配置运行区，请参考运行区安装文档。 "},"/zh/docs/installation-configuration/components/Gitlab-Runner":{"url":"zh/docs/installation-configuration/components/Gitlab-Runner","title":"Gitlab Runner","description":"","language":"zh","body":"Gitlab-Runner 安装 介绍 Gitlab-Runner 的安装和部署，Gitlab-Runner 是 Gitlab CI 的运行环境。 搭建所需镜像及文件 镜像列表 registry.saas.hand-china.com/tools/gitlab-runner:alpine-v10.1.0 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs.git 前置准备 获取Runner注册Token 此教程注册的Runner属性为共享，若需注册私有Runner，请在Git项目仓库Settings -> CI/CD菜单中获取Token 注册Runner 方式1 docker run -it --rm --entrypoint=bash registry.saas.hand-china.com/tools/gitlab-runner:alpine-v10.1.0 gitlab-runner register # 注册成功后查看生成的token cat /etc/gitlab-runner/config.toml 方式2 docker run -it --rm registry.saas.hand-china.com/tools/gitlab-runner:alpine-v10.1.0 register 注册完成后在Gitlab管理界面获取Runner的token、name和url 修改部署配置 将上一步得到的token、name和url复制出来填写到gitlab-runner-config中的对应位置。 修改cache-pv.yml和maven-pv.yml中nfs服务器地址和路径，并且在nfs的机器上创建这些目录。 运行 # 创建namespace kubectl create ns tools # 部署Runner kubectl apply -f gitlab-runner/ -n tools "},"/zh/docs/installation-configuration/components/Gitlab":{"url":"zh/docs/installation-configuration/components/Gitlab","title":"Gitlab","description":"","language":"zh","body":"Gitlab 安装 介绍 Gitlab 的安装和部署，Gitlab 作为 Choerodon 的代码托管库和分支管理工具。 安装所需镜像及文件 镜像列表 registry.saas.hand-china.com/tools/gitlab-ce:10.2.0-hand 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs.git 前置准备 构建镜像 在使用mysql作为gitlab的数据库时，需要自行安装mysql的依赖和驱动包，使用postgresql则无需构建镜像。进入devops-install-docs/devops/gitlab-ce目录，下文我们将以此目录进行讲解。 # 在镜像仓库中已有也可直接pull docker build -t registry.saas.hand-china.com/tools/gitlab-ce:10.2.0-hand -f . 镜像构建完成后可以使用以下环境变量配置自动备份 参数 | 描述 ---|--- GITLAB_BACKUP_SCHEDULE | 设置自动备份。选项有：disable daily weekly monthly或者 advanced。 默认是disable即禁用；daily为 每天进行备份；weekly为每周星期天备份； monthly为每月1号进行备份；advanced为全自定义，备份时间格式与cron相同。 GITLAB_BACKUP_TIME | 若选择备份策略\b为daily weekly monthly，自动备份的时间格式为 HH:MM，默认是01:00；若选择备份策略\b为advanced，自 动备份的时间格式为 ，默认是00 01 即每天1点进行备份。 GITLAB_BACKUP_SKIP | 选项有：db uploads (attachments) repositories builds (CI build output logs) artifacts (CI build artifacts) lfs (LFS objects)，默认为 repositories GITLAB_BACKUP_EXPIRY | 备份的数据多久（单位：秒）后进行删除。不进行自动删除则设置为0 开启自动备 份功能，默认是7天后进行删除，即604800秒。 使用ConfigMap挂载gitlab.rb配置文件 通过ConfigMap将gitlab.rb文件挂载到/opt/hand/devops/etc/gitlab.rb，运行镜像时就会加载此配置 文件。 创建数据库 登录到数据库创建gitlab用户及数据库: # 创建用户 CREATE USER 'gitlab'@'%' IDENTIFIED BY '******'; # 创建数据库并给gitlab用户授权: CREATE DATABASE gitlabhq_production DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON gitlabhq_production.* TO gitlab@'%'; FLUSH PRIVILEGES; 资源调整 若集群各节点资源充足可跳过此步。 由于gitlab运行需要大量的资源并且要保证其稳定性，不受到其他pod的影响，这里专们调整一台节点部署，这里我们选择了node5(4c16g) 节点准备 # 首先给node5节点打上标签 kubectl label nodes node5 gitlab=\"true\" # 对选好的节点上的pod进行驱赶 kubectl taint nodes node5 gitlab=\"true\":NoSchedule 修改kube-flannel和kube-proxy的配置文件让其可以忍受所有的taint使其能够在node5上运行 # 查看kube-flannel和kube-proxy部署是否在此命名空间下 kubectl get daemonset -n kube-system # 进行修改kube-flannel配置 kubectl edit daemonset kube-flannel -n kube-system # 以下配置请配置在containers属性中，与containers的image属性平级 tolerations: - effect: NoSchedule key: node-role.kubernetes.io/master operator: Exists - effect: NoSchedule operator: Exists # 进行修改kube-flannel配置 kubectl edit daemonset kube-proxy -n kube-system # 以下配置请配置在containers属性中，与containers的image属性平级 tolerations: - effect: NoSchedule key: node-role.kubernetes.io/master operator: Exists - effect: NoSchedule operator: Exists 修改gitlab/deploy.yml文件 # 以下配置请配置在containers属性中，与containers的image属性平级 nodeSelector: gitlab: \"true\" tolerations: - effect: NoSchedule key: gitlab operator: Exists 修改gitlab/redis.yml文件 # 以下配置请配置在containers属性中，与containers的image属性平级 nodeSelector: gitlab: \"true\" tolerations: - effect: NoSchedule key: gitlab operator: Exists 安装 Redis 部署Redis# 首先创建namespaces gitlab: kubectl create ns gitlab kubectl apply -f redis/ -n gitlab gitlab 修改gitlab/ingress.yml文件中的host地址，ip地址访问请忽略： apiVersion: extensions/v1beta1 kind: Ingress metadata: name: gitlab-ingress spec: rules: - host: git.*****************.com http: paths: - backend: serviceName: gitlab servicePort: 80 修改gitlab/pv.yml文件中的nfs的地址和路径。 ... capacity: storage: 50Gi nfs: path: /gitlab/gitlab-data server: 36b864afe1-phv23.cn-shanghai.nas.aliyuncs.com ... 将部署gilab kubectl apply -f gitlab/ -n gitlab 重要： 当容器通过健康检查后，就可以通过域名进行访问了，第一次访问须设置root用户初始密码。若配合Devops平台使用，请进入管理界面创建用户名为SonarQube和Gitlab的两个用户并将其设置为admin用户，并生成私钥保存下来，后面的其他服务搭建会用到它。 配置Gitlab 重要： 此步须等待gitlab容器已运行成功健康检查通过且Hapcloud框架服务也可使用了才进行后续操作 进入容器编辑/etc/gitlab/gitlab.rb文件： # 执行命令进入容器 kubectl get po -n gitlab kubectl exec -it [gilab pod name] -n gitlab bash # 备份原配置文件 mv /etc/gitlab/gitlab.rb /etc/gitlab/gitlab.rb.bak # 编辑配置文件 vi /etc/gitlab/gitlab.rb 重要： 请认真阅读以下配置，修改参数后粘贴进/etc/gitlab/gitlab.rb文件中，若须其他配置请参考gitlab/gitlab.rb gitlab配置文件事例： # `external_url`的值为gitlab的域名地址 external_url 'http://git.digital.saas.carllhw.com' # 设置gitlab的时区为北京时间 gitlab_rails['time_zone'] = 'Beijing' # 设置gitlab邮件启用 和回复的邮箱 gitlab_rails['gitlab_email_enabled'] = true gitlab_rails['gitlab_email_from'] = 'gitlab@choerodon.com' gitlab_rails['gitlab_email_display_name'] = 'Gitlab' gitlab_rails['gitlab_email_reply_to'] = 'noreply@choerodon.com' # 设置用户可以创建组和修改密码 gitlab_rails['gitlab_default_can_create_group'] = true gitlab_rails['gitlab_username_changing_enabled'] = true # 设置默认主题 gitlab_rails['gitlab_default_theme'] = 1 # 启用oauth授权单点登录 gitlab_rails['omniauth_enabled'] = true gitlab_rails['omniauth_allow_single_sign_on'] = ['oauth2_generic'] gitlab_rails['omniauth_auto_sign_in_with_provider'] = 'oauth2_generic' gitlab_rails['omniauth_block_auto_created_users'] = false # oauth2配置 这里配置的是hapcloud的oauth授权，注意修改gateway的地址，回调地址和授权客户端的id(app_id)、secret、和字段映射关系 gitlab_rails['omniauth_providers'] = [ { 'name' => 'oauth2_generic' 'app_id' => 'digital_gitlab' 'app_secret' => 'secret' 'args' => { client_options: { 'site' => 'http://gateway.devops.digital.saas.carllhw.com/' 'user_info_url' => '/oauth/api/user' 'authorize_url'=> '/oauth/oauth/authorize' 'token_url'=> '/oauth/public/gitlab/token' } user_response_structure: { root_path: ['userAuthentication' 'principal'] id_path: ['userAuthentication' 'principal' 'userId'] attributes: { nickname: 'username' name: 'username' email: 'email' } } name: 'oauth2_generic' strategy_class: \"OmniAuth::Strategies::OAuth2Generic\" redirect_url: \"http://git.digital.saas.carllhw.com/users/auth/oauth2_generic/callback\" } } ] # 关闭自带的postgresql postgresql['enable'] = false # 配置mysql连接 gitlab_rails['db_adapter'] = \"mysql2\" gitlab_rails['db_encoding'] = \"utf8mb4\" gitlab_rails['db_collation'] = \"utf8mb4_unicode_ci\" gitlab_rails['db_database'] = \"gitlabhq_production\" gitlab_rails['db_pool'] = 20 gitlab_rails['db_username'] = \"gitlab\" gitlab_rails['db_password'] = \"handhand\" gitlab_rails['db_host'] = \"rds.aliyuncs.com\" gitlab_rails['db_port'] = 3306 # 关闭自带的redis redis['enable'] = false # 配置redis连接 gitlab_rails['redis_host'] = \"gitlab-redis-svc\" gitlab_rails['redis_port'] = 6379 # gitlab邮箱服务器设置 gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = \"smtp.mxhichina.com\" gitlab_rails['smtp_port'] = 465 gitlab_rails['smtp_user_name'] = \"git.sys@carllhw.com\" gitlab_rails['smtp_password'] = \"Rdchandhand123\" gitlab_rails['smtp_domain'] = \"smtp.mxhichina.com\" gitlab_rails['smtp_authentication'] = \"login\" gitlab_rails['gitlab_email_from'] = \"git.sys@carllhw.com\" gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['smtp_tls'] = true # 关闭监控相关功能 prometheus['enable'] = false node_exporter['enable'] = false # 解密您的加密CI变量的秘钥 gitlab_rails['otp_key_base'] = \"long-and-random-alphanumeric-string\" gitlab_rails['db_key_base'] = \"long-and-random-alphanumeric-string\" gitlab_rails['secret_key_base'] = \"long-and-random-alphanumeric-string\" 使配置生效 # 停止启动的服务 gitlab-ctl stop # 生效配置 gitlab-ctl reconfigure # 启动服务 gitlab-ctl start 创建oauth客户端 通过gateway的swagger界面，选择用户服务client的API创建: # 回调地址为gitlab将要访问的地址 { \"name\": \"digital_gitlab\" \"resourceIds\": \"default\" \"secret\": \"secret\" \"scope\": \"default\" \"authorizedGrantTypes\": \"password implicit client_credentials authorization_code refresh_token\" \"webServerRedirectUri\": \"http://git.************.com\" \"autoApprove\": \"default\" } 优化 如果在gitlab中需要使用emoji图标(比如在issue、comment、merge request区域) 那么需要做以下配置: 首先，需要对数据库表编码和行类型进行转换，如果一开始创建表时就使用utf8mb4格式，会造成初始化时列的长度超出限制的错误(767/4)。所以先使用utf8初始化完成后，再用sql进行转换。 修改数据库参数 # Aliyun RDS通过界面控制台修改: innodb_large_prefix = ON # 自建Mysql执行以下sql set global innodb_file_format = `BARRACUDA`; set global innodb_large_prefix = `ON`; 执行下边sql 并复制返回结果执行，然后就会将表的行格式设置为动态类型: SELECT CONCAT( 'ALTER TABLE `' TABLE_NAME '` ROW_FORMAT=DYNAMIC;' ) AS 'Copy & run these SQL statements:' FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \"gitlabhq_production\" AND TABLE_TYPE = \"BASE TABLE\" AND ROW_FORMAT != \"Dynamic\"; 继续执行sql，并复制返回结果执行，把表的编码进行转换: SELECT CONCAT( 'ALTER TABLE `' TABLE_NAME '` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;' ) AS 'Copy & run these SQL statements:' FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \"gitlabhq_production\" AND TABLE_COLLATION != \"utf8mb4_general_ci\" AND TABLE_TYPE = \"BASE TABLE\"; 这样在gitlab里就可以使用emoji图标了。对于postgresql是可以直接使用utf8mb4编码的。而在mysql5.7中可以将ROW_FORMAT = \"Dynamic\"这一值设置为默认属性，因此可能不会遇到这个问题。 "},"/zh/docs/installation-configuration/components/Harbor":{"url":"zh/docs/installation-configuration/components/Harbor","title":"Harbor","description":"","language":"zh","body":"Harbor 安装 介绍 Harbor 的安装和配置，Choerodon 使用 Harbor 作为私有镜像库。 安装所需镜像及文件 镜像列表 registry.saas.hand-china.com/harbor/harbor-adminserver:v1.2.0 registry.saas.hand-china.com/harbor/harbor-jobservice:v1.2.0 registry.saas.hand-china.com/harbor/harbor-db:v1.2.0 registry.saas.hand-china.com/harbor/registry:2.6.2-photon registry.saas.hand-china.com/harbor/harbor-ui:v1.2.0 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs.git 使用外部数据库 如果使用自带数据库请忽略此步骤。 创建一个harbor用户，创建registry数据库，并授予harbor用户权限 # 创建用户 CREATE USER 'harbor'@'%' IDENTIFIED BY 'handhand'; # 请注意数据库名称一定不能改变 CREATE DATABASE registry DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON registry.* TO harbor@'%'; FLUSH PRIVILEGES; 将devops-install-docs/devops/harbor/registry.sql文件内容放到数据库执行初始化表结构。 安装Harbor 生成配置 进入devops-install-docs/devops/harbor目录，下文我们将以此目录进行讲解。搭建后若使用https进行访问，请先阅读访问。 修改harbor.cfg的参数配置，主要包括harbor的访问地址 (hostname)，harbor的管理员密码(harbor_admin_password)和其他配置，参考配置如下: 其他参数如果不清楚其用法请不要修改。 hostname = register.choerodon.com harbor_admin_password = Harbor12345 # 如果你使用的是外部数据库还需要修改以下参数为自己数据库实例相对于的值 db_host = mysql db_port = 3306 db_user = root 根据配置文件生成每个服务对应的configMap文件 生成的configMap文件位于每个service对应的文件夹下，并且会在kubernetes目录下生成一个 ingress.yaml文件。 python kubernetes/k8s-prepare 修改持久存储的地址 在kubernetes/pv文件加下有对应三个服务的pv和pvc的yaml文件。请根据各自的需求修改对应*.pv.yaml 文件的配置。 # 三对pv和pvc文件分别对应的服务是： log.pv.yaml log.pvc.yaml ===》 jobservice 存储日志文件 registry.pv.yaml registry.pvc.yaml ===》 registry 存储镜像文件 storage.pv.yaml storage.pvc.yaml ===》 mysql mysql数据库的存储文件 注意: 如果使用已有数据库实例，则不需要修改storage.pv.yaml的配置，并且在后面的部署操作中，有关mysql的部署操作请全部忽略。 开始安装 创建命名空间harbor： kubectl create ns harbor 部署： # 创建jobservice的存储 kubectl apply -f kubernetes/pv/log.pv.yaml kubectl apply -f kubernetes/pv/log.pvc.yaml -n harbor # 创建registry的存储 kubectl apply -f kubernetes/pv/registry.pv.yaml kubectl apply -f kubernetes/pv/registry.pvc.yaml -n harbor # 创建mysql存储【使用已有数据库实例请略过】 kubectl apply -f kubernetes/pv/storage.pv.yaml kubectl apply -f kubernetes/pv/storage.pvc.yaml -n harbor # 部署mysql【使用已有数据库实例请略过】 kubectl apply -f kubernetes/mysql -n harbor # 部署镜像服务(registry) kubectl apply -f kubernetes/registry -n harbor # 部署harbor管理服务(adminserver) kubectl apply -f kubernetes/adminserver -n harbor # 部署日志服务(jobservice) kubectl apply -f kubernetes/jobservice -n harbor # 部署前端(ui) kubectl apply -f kubernetes/ui -n harbor 查看所有pod的运行状态： kubectl get po -n harbor 访问 使用HTTP进行访问 请直接部署ingress kubectl apply -f kubernetes/ingress.yaml -n harbor 待所有pod的状态都为Running并且全部READY，表示已部署成功。可以使用在第一步中配置的hostname在浏览器中进行访问。 在需要对harbor使用docker命令进行pull和push操作时需要在相应的机器docker配置中添加 insecure-registries参数，该值为harbor.cfg文件中配置的hostname的值。 可以根据操作系统和docker版本不同在对应位置的配置添加参数(请自行查阅)，比如:在centos7.X上配置，只需要在/etc/docker/daemon.json文件中添加以下参数: # 示例(仅供参考) { \"exec-opts\": [\"native.cgroupdriver=systemd\"] \"storage-driver\": \"overlay\" \"log-driver\": \"json-file\" \"log-opts\": { \"max-size\": \"10m\" } \"insecure-registries\": [\"register.jaywoods.com\"] } 注意： 修改之后需要重启docker才能生效。 systemctl daemon-reload && systemctl restart docker 使用HTTPS进行访问 使用kube-lego申请证书 如果集群中部署了kube-lego申请证书，请编辑 ingress.yaml，添加secretName属性到spce.tls.hosts中。[kube-lego] (https://github.com/jetstack/kube-lego)会自动申请证书，部署成功后就可使用https进行访问了。 \b1.为ingress添加注解kubernetes.io/tls-acme: \"true\" metadata: annotations: kubernetes.io/tls-acme: \"true\" 2.为ingress添加添加spec.tls属性及其值 ` spec: tls: hosts: register.jaywoods.com secretName: harbor-cert ` 注意： 这里的secretName值在当前命名空间是唯一的，且secretName值是必需的（即使这个secret对象不存在，它将由kube-lego创建） 编辑完成后进行部署 kubectl apply -f kubernetes/ingress.yaml -n harbor 手动申请证书 如果单纯的在ingress这里配置一个可信任证书的secret是不行的。在docker的操作时registry会进行证书校验， 也就是说ingress这配置的证书要与registry.cm.yaml里配置的能够匹配，否则就会报错。 第一步：通过certbot生成证书(此方法每次更新只有3个月有效时间，若直接购买请跳过此步)。 使用certbot生成证书需要注意几点: 1.将域名解析到需要执行生成证书命令的机器上 2.确保该机器上的80和443端口不能被占用 3.该机器上已装有docker环境 # 执行以下命令，注意更换域名地址 docker run --rm -ti \\ --network host \\ -v /etc/letsencrypt:/etc/letsencrypt \\ -v /var/lib/letsencrypt:/var/lib/letsencrypt \\ certbot/certbot:v0.19.0 \\ certonly --standalone \\ -d example.choerodon.com # 过程中提示输入邮箱，完成之后证书在/etc/letsencrypt目录下 第二步：修改harbor参数配置，并生成configmap 这里需要修改除了生成配置中的变量还有以下参数: ui_url_protocol = https # 配置证书路径(修改为自己的证书路径) ssl_cert = /root/example.choerodon.com/fullchain.pem ssl_cert_key = /root/example.choerodon.com/privkey.pem 然后就使用命令生成configmap文件: python kubernetes/k8s-prepare 更新部署 # 部署镜像服务(registry) kubectl apply -f kubernetes/registry -n harbor # 部署harbor管理服务(adminserver) kubectl apply -f kubernetes/adminserver -n harbor # 部署日志服务(jobservice) kubectl apply -f kubernetes/jobservice -n harbor # 部署前端(ui) kubectl apply -f kubernetes/ui -n harbor 最后根据证书的内容生成一个secret: # 参数 --key 后指定证书私钥的路径 # 参数 --cert 后指定证书的路径 kubectl create secret tls harbor-cert --key privkey.pem --cert fullchain.pem -n harbor 修改ingress配置，添加secretName属性值: kubectl edit ingress harbor -n harbor # 参考示例如下 ... rules: - host: example.choerodon.com http: paths: - backend: serviceName: ui servicePort: 80 path: / - backend: serviceName: registry servicePort: repo path: /v2 - backend: serviceName: ui servicePort: 80 path: /service tls: - hosts: - example.choerodon.com secretName: harbor-cert "},"/zh/docs/installation-configuration/components/SonarQube":{"url":"zh/docs/installation-configuration/components/SonarQube","title":"SonarQube","description":"","language":"zh","body":"SonarQube 安装 介绍 SonarQube 的安装和配置，Choerodon 使用 SonarQube 作为代码质量的检查工具。 安装所需镜像及文件 镜像列表 registry.saas.hand-china.com/library/postgres:latest registry.saas.hand-china.com/library/sonarqube:6.5-alpine 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs.git 前置准备 进入devops-install-docs/devops/middleware/sonarqube目录，下文我们将以此目录进行讲解。 修改各目录下pv.yml的nfs地址和路径 安装 # pv修改后再自行以下命令 kubectl apply -f postgresql/ -n tools kubectl apply -f sonarqube/ -n tools 集成Gitlab 网络好 使用admin用户登录SonarQube，安装gitlab插件 网络不好 由于网络的原因，可能gitlab插件安装不了会提示错误。请使用以下方式安装。 下载此jar包 https://github.com/gabrie-allaigre/sonar-gitlab-plugin/releases/download/2.1.0/sonar-gitlab-plugin-2.1.0.jar 将jar包拷贝到SONARQUBE_HOME/extensions/plugins目录中。 重启SonarQube生效 接下来按照图片提示配置这两个选项 参考链接 "},"/zh/docs/installation-configuration/components/":{"url":"zh/docs/installation-configuration/components/","title":"组件","description":"","language":"zh","body":"安装其他组件 介绍Choerodon其他组件的安装。 Gitlab 是一个用于仓库管理系统的开源项目，Choerodon使用Gitlab作为代码托管仓库。 Gitlab Runner 是Gitlab提供的CI工具，作为Choerodon的持续集成工具使用。 Harbor 是开源镜像库，Choerodon通过其搭建私有企业镜像库。 SonarQube 是开源代码质量检查工具。 日志 主要用于服务器、系统和应用的日志收集和管理，Choerodon集成了多个系统日志工具集。 监控 主要用于主机、系统、应用等监控，Choerodon集成了多个系统监控工具集。 "},"/zh/docs/installation-configuration/components/日志":{"url":"zh/docs/installation-configuration/components/日志","title":"日志","date":"2018-03-09T14:14:43+08:00","description":"","language":"zh","body":"日志安装 日志服务聚集各个服务日志通过elasticsearch存储和提供高可用，高效率的日志查询和聚合服务，日志服务和监控服务相互补充构建一个完整的监控日志分析服务，对集群和服务的健康稳定运行，常规业务分析起着不可忽视的作用。 日志架构图 日志架构图如下 fluent-bit以daemonSet的方式运行在每一个节点上，并且绑定日志目录，fluent-bit收集日志同时调用kubernetesApi获取日志所属的容器信息随后加工压缩日志。经过加工后的日志发送到fluentd上，fluentd会进一步缓冲日志并发送到elasticsearch集群中。Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力。若要查看日志可以在kibana中查看。 为什么使用jsonfile存储日志： docker存储日志有多种形式，其中一种为fluentd可以直接发送给fluentd，看上去fluent-bit变得有点多余，但是我们考虑到了一点就是多行日志的处理问题，如果docker直接发送给fluentd则日志的顺序就会存在错乱的风险，处理多行日志就会变得异常\b复杂，而使用文件存储则可以安照顺序依次读取日志，判断处理多行日志。 安装 安装前准备 确认docker使用json-file作为日志存储方式 确认docker已经限制了日志文件的大小 确认docker限制的日志文件数量不小于2 使用我们的部署脚本部署kubernetes集群已默认配置了上述选项无需再次配置 下载安装脚本 $ wget https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs/raw/master/devops/monitoring/install_logging.sh 编辑参数 $ vim install_logging.sh 参数说明 参数 说明 默认值 NAMESPACE 日志服务所在的命名空间 logging REQUEST_MEMORY \b每个es\b节点请求的内存大小 4Gi LIMIT_MEMORY 每个es\b节点限制的内存大小 8Gi SCRAPE_INTERVAL prometheus\b收集指标间隔 10s SCRAPE_TIMEOUT prometheus\b收集指标超时 10s BASE_URL 服务的基础地址，如想要elasticsearch的地址为elasticsearch.example.com则BASE_URL的值应该设置为example.com NFS_SERVER 如果需要nfs存储日志数据则需要制定nfs服务器地址 运行前注意事项 脚本\b默认支持主机\b存储和nfs\b存储，如果需要使用glusterfs或者ceph请手动搜索create_pv_datalocaltion方法并\b将如下文本中关于nfs的内容替换成所需的存储方式 --- apiVersion: v1 kind: PersistentVolume metadata: labels: pv: ${name} name: ${name} spec: accessModes: - ReadWriteMany capacity: storage: ${storage_size}Gi nfs: path: ${dataPath} server: ${NFS-SERVER} 运行脚本 $ sh install_logging.sh 根据提示输入相关参数 - Do you want use pvc to storage elasticsearch/kibana data (default is no) yes/no： 是否使用pvc存储elasticsearch/kibana数据 - which node you run with elasticsearch/kibana 选择\b\b\belasticsearch/kibana可以运行的节点，根据提示的节点选择如`node1 node3` - what nfs size do you want assign to elasticsearch (unit Gi) 如果使用\bpvc，输入分配给prometheus的空间大小单位是Gi 查看服务 服务 地址 elasticsearch elasticsearch.example.com kibana kibana.example.com "},"/zh/docs/installation-configuration/components/监控":{"url":"zh/docs/installation-configuration/components/监控","title":"监控","description":"","language":"zh","body":"监控安装 提供全方位的监控服务，包括基础组件监控，各微服务运行情况监控，资源监控和智能预警。 监控架构图 架构图如下 监控以Google Prometheus为核心展开，Prometheus作为一个开源的监控和预警系统自2012年开始就被许多公司和机构使用，越来越多的项目也开始原生支持Prometheus收集性能指标。Prometheus主动收集性能指标压力集中在监控服务器上，而不会占用应用服务器过多的资源。在监控主机上，node-exporter为prometheus提供了主机的内存、CPU、网络和磁盘等相关信息，在容器监控上，kubernetes内置的cAdvisor提供了容器的各项指标，同样的内存、CPU、网络和磁盘的信息也一应俱全，kube-stat-metrics提供了集群中部署信息，如容器名称，容器标签等。在JAVA微服务的监控上，微服务使用micrometer为prometheus提供JAVA微服务的指标如线程数，消耗内存，请求数等。当微服务部署到集群后Prometheus能够自动发现并收集其提供的信息。其他各种服务也可以通过编写exporter为Prometheus提供指标。当配置报警规则之后Prometheus会将报警信息发送给alertmanager，alertmanager根据预先配置好的邮件地址或者短信接口发送报警信息。 安装 下载安装脚本 $ wget https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs/raw/master/devops/monitoring/install_monitoring.sh 编辑参数 $ vim install_monitoring.sh 参数说明 参数 说明 默认值 NAMESPACE 监控服务所在的命名空间 monitoring REQUEST_MEMORY prometheus请求的内存大小 4Gi LIMIT_MEMORY prometheus限制的内存大小 8Gi SCRAPE_INTERVAL prometheus收集指标间隔 10s SCRAPE_TIMEOUT prometheus收集指标超时 10s BASE_URL 服务的基础地址，如想要prometheus的地址为prometheus.example.com则BASE_URL的值应该设置为example.com NFS_SERVER 如果需要nfs存储监控数据则需要制定nfs服务器地址 运行前注意事项 脚本默认支持主机存储和nfs存储，如果需要使用glusterfs或者ceph请手动搜索create_pv_datalocaltion方法并将如下文本中关于nfs的内容替换成所需的存储方式。 --- apiVersion: v1 kind: PersistentVolume metadata: labels: pv: ${name} name: ${name} spec: accessModes: - ReadWriteMany capacity: storage: ${storage_size}Gi nfs: path: ${dataPath} server: ${NFS-SERVER} 运行脚本 $ sh install_monitoring.sh 根据提示输入相关参数： - Do you want use pvc to storage prometheus/grafana data (default is no) yes/no： 是否使用pvc存储prometheus/grafana数据 - which node you run with prometheus/grafana 选择prometheus/grafana可以运行的节点，根据提示的节点选择如`node1 node3` - what nfs size do you want assign to prometheus (unit Gi) 如果使用\bpvc，输入分配给prometheus的空间大小单位是Gi 查看服务 服务 地址 grafana grafana.example.com prometheus prometheus.example.com alertmanager alertmanager.example.com "},"/zh/docs/installation-configuration/deployment-install-guide":{"url":"zh/docs/installation-configuration/deployment-install-guide","title":"运行区安装","description":"","language":"zh","body":"运行区安装 本章节介绍运行区的安装。 运行区服务 当前Choerodon运行区各服务版本信息如下： 服务名 服务组 服务代码 版本号 注册服务 com.choerodon.choerodoncloud choerodon-register-server 1.2.0 管理服务 com.choerodon.choerodoncloud choerodon-manager-service 1.2.0 配置服务 com.choerodon.choerodoncloud choerodon-config-server 1.2.0 用户服务 com.choerodon.choerodoncloud choerodon-user-service 1.2.11 授权服务 com.choerodon.choerodoncloud choerodon-oauth-server 1.2.1 网关服务 com.choerodon.choerodoncloud choerodon-api-gateway 1.2.2 消息服务 com.choerodon.choerodoncloud choerodon-event-store-service 1.2.1 框架服务 com.choerodon.choerodoncloud choerodon-framework-service 1.2.1 用户管理服务 com.choerodon.choerodoncloud choerodon-user-admin-service 1.2.0 K8S消息收集 com.choerodon.devops k8s-informer V0.1.1 K8S服务 com.choerodon.devops devops-kubernetes-service 1.1.0 文件服务 com.choerodon.devops choerodon-file-service 1.1.0 部署服务 com.choerodon.devops devops-deploy-service 1.1.6 数据整合服务 com.choerodon.insight data-intergration-service 1.0.0 数据提供服务 com.choerodon.insight data-provide-service 1.0.1 数据操作服务 com.choerodon.insight data-operation-service 1.0.0 移动服务 com.choerodon.mobile mobile-cloud-service 1.0.0 框架前端 com.choerodon.choerodoncloud choerodoncloud-front 1.2.2 部署前端 com.choerodon.devops deploy-front 1.1.5 监控前端 com.choerodon.insight monitor-front 1.0.0 移动前端 com.choerodon.mobile mobile-front 1.0.0 硬件需求 存储 存储空间的大小主要取决于你将存储的docker image以及使用文件服务时上传的文件大小。但是你应该考虑多留一些空间用来存储备份。 除此之外你还可以挂在一个支持NFS的分卷，比如NAS、 SAN、AWS、EBS。 CPU 将所有服务运行起来，一定要注意当前集群内至少有8C可用。 内存 安装使用Choerodon运行区所有应用需要至少50GB可用内存(RAM + Swap)! 由于操作系统和其他正在运行的应用也会使用内存， 所以安装Choerodon运行区前一定要注意当前集群内至少有50GB的可用内存. 少于50GB内存会导致在部署后Pod一直处于等待状态或者在使用中出现各种不可预知的问题。 Kubernetes v1.8.5 搭建Devops平台时，默认已经搭建好K8S集群，若未搭建请移步K8S集群搭建 依赖组件 名称 版本 Harbor(可选) 1.1.1 监控 1.0.0 日志 1.0.0 安装所需软件及文件 在要执行ansible脚本的机器上安装ansible运行需要的环境以及git。 sudo yum install -y epel-release && \\ sudo yum install -y ansible git 克隆安装脚本 git clone https://rdc.choerodon-china.com/gitlab/rdc_hip/devops-ansible.git 使用NFS存储 若选择其他存储方式或已有NFS Server请跳过此步。 复制搭建K8S集群时所用到的inventory/hosts文件内容到本项目的inventory/hosts文件中。添加[nfs]分区，该分区只能添加一个节点，[nfs]分区节点即为提供nfs服务的节点。 修改inventory/vars.yml文件，将不需要部署的资源enable置为false，这里会自动创建所需目录；请设置nfs.ip属性，默认为指定节点ipv4地址；计算包含所有各节点的子网掩码将值赋予nfs.client_net，默认为\"*\"即所有主机都可以访问。 执行以下命令搭建nfs ansible-playbook -i inventory/hosts -e @inventory/vars.yml nfs-server.yml 执行安装步骤 修改inventory/hosts文件，其中[run]分区只能添加一个节点且该节点可以使用kubectl命令。 确认所要部署的资源(mysql、rabbitmq、redis、zookeeper、kafka，minio)，若资源已有不需要部署，请在inventory/vars.yml文件中将资源enable置为false。 执行以下命令搭建运行区所需资源。 ansible-playbook -i inventory/hosts -e @inventory/vars.yml dev-resource.yml 手动部署监控参考链接 手动部署日志参考链接 创建运行区所需数据库 若使用容器运行的mysql，可以参照以下命令进入容器创建数据库 查看pod名称，进入容器 kubectl get po -n devops kubectl exec -it [PodName] -n devops bash 进入mysql命令行 mysql -uroot -p${MYSQL_ROOT_PASSWORD} 创建choerodoncloud用户及数据库 CREATE USER 'choerodoncloud'@'%' IDENTIFIED BY 'choerodonchoerodon123'; CREATE DATABASE choerodon_user_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_manager_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_event_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_framework_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON choerodon_user_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_manager_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_event_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_framework_service.* TO choerodoncloud@'%'; CREATE DATABASE devops_deploy_service DEFAULT CHARACTER SET utf8; CREATE DATABASE mobile_cloud_service DEFAULT CHARACTER SET utf8; CREATE DATABASE devops_operation_portal DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON devops_deploy_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON mobile_cloud_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON devops_operation_portal.* TO choerodoncloud@'%'; FLUSH PRIVILEGES; 重要： 注释掉inventory/config.yml文件中第2109行到文件最后一行的配置，这些配置为开发区所需的，若未注释那么系统搭建完成后会将开发区的信息扫描进去，所以注释掉它。 修改inventory/config.yml文件中资源区域维护好相应参数。 运行脚本搭建部署端 ansible-playbook -i inventory/hosts -e @inventory/config.yml run.yml "},"/zh/docs/installation-configuration/development-install-guide":{"url":"zh/docs/installation-configuration/development-install-guide","title":"开发区安装","description":"","language":"zh","body":"开发区安装 由于开发区各服务也需要进行更新和管理，所以将部署开发区和运行区的所有服务。本文以CentOS为例进行讲解。 本章节介绍开发区的安装。 开发区服务 当前Choerodon开发区各服务版本信息如下： 服务名 服务组 服务代码 版本号 注册服务 com.choerodon.choerodoncloud choerodon-register-server 1.2.0 管理服务 com.choerodon.choerodoncloud choerodon-manager-service 1.2.0 配置服务 com.choerodon.choerodoncloud choerodon-config-server 1.2.0 用户服务 com.choerodon.choerodoncloud choerodon-user-service 1.2.11 授权服务 com.choerodon.choerodoncloud choerodon-oauth-server 1.2.1 网关服务 com.choerodon.choerodoncloud choerodon-api-gateway 1.2.2 消息服务 com.choerodon.choerodoncloud choerodon-event-store-service 1.2.1 框架服务 com.choerodon.choerodoncloud choerodon-framework-service 1.2.1 用户管理服务 com.choerodon.choerodoncloud choerodon-user-admin-service 1.2.0 K8S消息收集 com.choerodon.devops k8s-informer V0.1.1 Gitlab服务 com.choerodon.devops choerodon-gitlab-service 1.1.0 K8S服务 com.choerodon.devops devops-kubernetes-service 1.1.0 文件服务 com.choerodon.devops choerodon-file-service 1.1.0 开发服务 com.choerodon.devops choerodon-devops-service 1.1.0 部署服务 com.choerodon.devops devops-deploy-service 1.1.6 SonarQube服务 com.choerodon.insight data-sonar-service 1.0.1 数据整合服务 com.choerodon.insight data-intergration-service 1.0.0 数据提供服务 com.choerodon.insight data-provide-service 1.0.1 数据操作服务 com.choerodon.insight data-operation-service 1.0.0 看板服务 com.choerodon.kanban choerodon-kanban-service 1.1.0 移动服务 com.choerodon.mobile mobile-cloud-service 1.0.0 框架前端 com.choerodon.choerodoncloud choerodoncloud-front 1.2.2 开发前端 com.choerodon.devops devops-front 1.1.3 部署前端 com.choerodon.devops deploy-front 1.1.5 洞察前端 com.choerodon.insight analysis-insight-front 1.0.0 监控前端 com.choerodon.insight monitor-front 1.0.0 看板前端 com.choerodon.kanban choerodon-kanban-front 1.1.0 移动前端 com.choerodon.mobile mobile-front 1.0.0 硬件需求 存储 存储空间的大小主要取决于你将存储的docker image，Gitlab所存储的Git仓库以及使用文件服务时上传的文件大小。但是你应该考虑多留一些空间用来存储备份。 除此之外你还可以挂在一个支持NFS的分卷，比如NAS、 SAN、AWS、EBS。 CPU 将所有服务运行起来，一定要注意当前集群内至少有16C可用。 内存 安装使用Choerodon开发区所有应用需要至少50GB可用内存(RAM + Swap)! 由于操作系统和其他正在运行的应用也会使用内存， 所以安装Choerodon开发区前一定要注意当前集群内至少有70GB的可用内存. 少于70GB内存会导致在部署后Pod一直处于等待状态或者在使用中出现各种不可预知的问题。 Kubernetes v1.8.5 搭建Devops平台时，默认已经搭建好K8S集群，若未搭建请移步K8S集群搭建 依赖组件 名称 版本 Gitlab 10.2.0 Gitlab Runner 10.1.0 SonarQube 6.5 Harbor(可选) 1.1.1 监控 1.0.0 日志 1.0.0 安装所需软件及文件 在要执行ansible脚本的机器上安装ansible运行需要的环境以及git。 sudo yum install -y epel-release && \\ sudo yum install -y ansible git 克隆安装脚本 git clone https://rdc.choerodon-china.com/gitlab/rdc_hip/devops-ansible.git 使用NFS存储 若选择其他存储方式或已有NFS Server请跳过此步。 复制搭建K8S集群时所用到的inventory/hosts文件内容到本项目的inventory/hosts文件中。添加[nfs]分区，该分区只能添加一个节点，[nfs]分区节点即为提供nfs服务的节点。 修改inventory/vars.yml文件，将不需要部署的资源enable置为false，这里会自动创建所需目录；请设置nfs.ip属性，默认为指定节点ipv4地址；计算包含所有各节点的子网掩码将值赋予nfs.client_net，默认为\"*\"即所有主机都可以访问。 执行以下命令搭建nfs ansible-playbook -i inventory/hosts -e @inventory/vars.yml nfs-server.yml 执行安装步骤 修改inventory/hosts文件，其中[dev]分区只能添加一个节点且该节点可以使用kubectl命令。 确认所要部署的资源(mysql、rabbitmq、redis、zookeeper、kafka、sonarqube，minio)，若资源已有不需要部署，请在inventory/vars.yml文件中将资源enable置为false。 执行以下命令搭建开发区所需资源 ansible-playbook -i inventory/hosts -e @inventory/vars.yml dev-resource.yml 手动部署harbor(外部数据库要手工初始化)参考链接 手动部署Gitlab，等Devops所有服务部署后再配置oauth授权(Mysql 5.6需要转表)参考链接 搭建完成Gitlab完成后创建一个名为template的Public Group，将http://git.choerodon.com.cn/template库中所有的仓科克隆并推送到新搭建的Gitlab仓库中，注意这个git库也应是public的，这样开发服务才能正常使用。 手动部署Gitlab Runner参考链接 配置SonarQube参考链接 手动部署监控参考链接 手动部署日志参考链接 创建开发区所需数据库 若使用容器运行的mysql，可以参照以下命令进入容器创建数据库 查看pod名称，进入容器 kubectl get po -n devops kubectl exec -it [PodName] -n devops bash 进入mysql命令行 mysql -uroot -p${MYSQL_ROOT_PASSWORD} 创建choerodoncloud用户及数据库 CREATE USER 'choerodoncloud'@'%' IDENTIFIED BY 'choerodonchoerodon123'; CREATE DATABASE choerodon_user_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_manager_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_event_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_framework_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON choerodon_user_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_manager_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_event_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_framework_service.* TO choerodoncloud@'%'; CREATE DATABASE choerodon_devops_service DEFAULT CHARACTER SET utf8; CREATE DATABASE devops_portal DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_kanban_service DEFAULT CHARACTER SET utf8; CREATE DATABASE devops_operation_portal DEFAULT CHARACTER SET utf8; CREATE DATABASE devops_deploy_service DEFAULT CHARACTER SET utf8; CREATE DATABASE mobile_cloud_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON choerodon_devops_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON devops_portal.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_kanban_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON devops_operation_portal.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON devops_deploy_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON mobile_cloud_service.* TO choerodoncloud@'%'; FLUSH PRIVILEGES; 修改inventory/config.yml文件中资源区域维护好相应参数。 执行以下命令开始开发区 ansible-playbook -i inventory/hosts -e @inventory/config.yml dev.yml "},"/zh/docs/quick-start/":{"url":"zh/docs/quick-start/","title":"快速入门","description":"","language":"zh","body":"快速入门 介绍 Choerodon 的使用，主要从创建项目开始，并在项目中创建应用和使用敏捷管理工具等功能入手，详细地介绍如何使用 Choerodon 创建应用，并且结合用户故事地图、迭代和看板管理项目。 目前，Choerodon 支持5种类型应用的创建。Web前端应用、 微服务后端应用、普通Web应用、移动应用、Java 库。 创建一个项目 创建一个Web前端服务 创建一个微服务后端服务 创建一个普通Web服务 创建一个移动服务 开发Web前端服务 开发微服务后端服务 "},"/zh/docs/quick-start/develop-microservice-backend":{"url":"zh/docs/quick-start/develop-microservice-backend","title":"开发一个微服务后端","description":"","language":"zh","body":"正在更新，敬请期待... "},"/zh/docs/quick-start/develop-microservice-front":{"url":"zh/docs/quick-start/develop-microservice-front","title":"开发一个微服务前端","description":"","language":"zh","body":"正在更新，敬请期待... "},"/zh/docs/quick-start/microservice-backend":{"url":"zh/docs/quick-start/microservice-backend","title":"创建一个微服务后端服务","description":"","language":"zh","body":"创建一个微服务后端服务 目标 微服务后端(Microservice)的架构模式是将传统的单体应用拆分成多个小型服务，每个小型服务可以独立的编译和部署，服务之间的调用通过HTTP的restfull API方式进行通讯。它们彼此之间相互协作，作为一个整体对外开放。Choerodon 的微服务后端采用SpringBoot、SpringCloud 作为微服务的开发框架，利用丰富的文档、社区活跃和一套完整的微服务框架解决方案提供技术支持。 本章节将从创建微服务后端、开发微服务后端、生成版本、发布服务、部署服务、查看运行信息等方面介绍，让读者能够熟悉使用Choerodon创建微服务后端服务的步骤和流程，并且学会如何利用Choerodon发布版本和部署服务等。 前置条件 在操作之前保证系统配置已经配置完全。特别在本章节用到的角色、环境管理等配置。 完成创建项目操作。本章节使用在前面章节创建的DevOps项目。 创建微服务后端 使用项目所有者或者源代码管理员的角色登录Choerodon系统，选择新建的项目DevOps 点击菜单栏开发管理，选择服务，进入服务管理页面，在服务管理中创建服务。系统会弹出模态框，在框中输入服务编码、服务名称和服务组，选择服务类型，点击创建，即可创建一个微服务后端服务。 a. 服务编码：order-service b. 服务名称：订单服务 c. 服务组: io.choerodon.test > `服务编码`输入只能包含小写字母、数字、中划线(-)、英文句号(.)和反斜杠(\\)，``服务名称``输入最大64个字符，`服务组`输入不能包含中文或大写字母 不能以'.'开头或结尾。 当服务创建成功，可以在服务列表查看到新建的服务。 在创建服务的同时，系统还会在Gitlab中创建一个仓库，点击 仓库地址 ，链接到Gitlab新建的仓库。 http://git.saas.hand-china.com/devops/order-service.git Gitlab 仓库的名称是 order-service，是服务编码。 开发微服务后端 服务创建完成之后，开发微服务后端。具体的操作步骤如下： 创建Feature分支。 进入到服务管理界面，搜索服务编码order-service 选择这行记录，点击右侧详情，进入到服务详情界面，点击分支管理，点击创建Feature按钮，会弹出模态框，输入分支名称，例如1001。详情参考分支管理。 在存放代码的文件夹下，打开git bash 输入命令git clone [仓库地址]，拉取所需服务的代码仓库。 $ git clone http://git.saas.hand-china.com/devops/order-service.git 克隆成功之后，进入项目根目录，打开git bash 输入命令git checkout feature-1001 切换到新建分支feature-1001，并在此分支进行开发。 $ git checkout feature-1001 开发项目。 Gitlab仓库克隆下来的项目就是一个简单的微服务，开发人员可以根据具体的业务需求进行开发。这里主要讲述.gitlab-ci.yml和.deploy.yml文件。如果一个服务要部署在Choerodon系统，这2个文件必不可少。 GitLab提供可持续集成服务。只要在你的仓库根目录 创建一个.gitlab-ci.yml 文件， 并为该项目指派一个Runner，当有合并请求或者 push的时候就会触发build。.gitlab-ci.yml 文件定义GitLab runner要做哪些操作，默认有3个[stages(阶段)]: build、test、deploy，开发人员可以根据不同的情况进行自定义。以下面为例子。 #基础镜像，提供mvn、docker命令以及自定义的文件 image: registry.saas.hand-china.com/tools/devops-ci:1.0.1 #表示构建阶段，下面定义了3个阶段。所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始 #只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功 #如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败 stages: - maven-build - docker-build - web-hook unit-test-branches: #job的名字 允许你创建无限个jobs 每个job必须有一个独一无二的名字，而且不能是ci的关键字 stage: maven-build #执行阶段 script: #job执行的脚本 - unit_test #具体实现参考下面方法 only: #表示job触发条件，表示只有feature分支才能触发。 - /^feature-.*$/ maven-unit-test: stage: maven-build script: - update_pom_version - maven_build only: - develop - /^release-.*$/ - /^hotfix-.*$/ - tags docker-build: stage: docker-build script: - docker_build only: - develop - /^release-.*$/ - /^hotfix-.*$/ - tags notification: stage: web-hook script: - devops_ci_notification #自定义可执行的二进制文件，主要作用是将.deploy.yml文件里的数据转成json格式，调用API，生成一条服务版本。 only: - develop - /^release-.*$/ - /^hotfix-.*$/ - tags .auto_devops: &auto_devops | export CI_TAG_SUF=$(echo $CI_COMMIT_REF_NAME | awk -F '-' '{print $1}') export CI_TAG_PRE=$(echo $CI_COMMIT_REF_NAME | awk -F '-' '{print $2}') export CI_COMMIT_TIME=$(git log -1 --pretty=format:\"%ci\" | awk '{print $1$2}' | sed 's/[-:]//g') if [ ! $CI_TAG_PRE ]; then export CI_APPLICATION_TAG=$CI_TAG_SUF.$CI_COMMIT_TIME else export CI_APPLICATION_TAG=$CI_TAG_PRE-beta.$CI_COMMIT_TIME.$CI_TAG_SUF fi if [ ! $CI_COMMIT_TAG ]; then export CI_COMMIT_TAG=$CI_APPLICATION_TAG fi function update_pom_version(){ find . -name pom.xml | xargs xml ed \\ -L -N x=http://maven.apache.org/POM/4.0.0 -u '/x:project/x:version' -v \"${CI_COMMIT_TAG}\" find . -name pom.xml | grep -v \"\\./pom.xml\" | xargs xml ed \\ -L -N x=http://maven.apache.org/POM/4.0.0 -u '/x:project/x:parent/x:version' -v \"${CI_COMMIT_TAG}\" 2>/dev/null || true } function unit_test() { git config user.name $GITLAB_USER_NAME git config user.email $GITLAB_USER_EMAIL git checkout origin/develop git merge $CI_COMMIT_SHA --no-commit --no-ff mvn package -U -DskipTests=false mvn --batch-mode verify sonar:sonar \\ -Dsonar.host.url=$SONAR_URL \\ -Dsonar.analysis.mode=preview \\ -Dsonar.gitlab.commit_sha=$CI_COMMIT_SHA \\ -Dsonar.gitlab.ref_name=$CI_COMMIT_REF_NAME \\ -Dsonar.gitlab.project_id=$CI_PROJECT_ID \\ -Dsonar.gitlab.user_token=$SONAR_TOKEN || true } function maven_build() { mvn package -U -DskipTests=false cat target/site/jacoco/index.html || true mvn --batch-mode verify sonar:sonar \\ -Dsonar.host.url=$SONAR_URL \\ -Dsonar.analysis.serviceGroup=$SERVICE_GROUP \\ -Dsonar.analysis.commitId=$CI_COMMIT_SHA || true mkdir -p $HOME/.m2/$CI_COMMIT_SHA cp target/app.jar $HOME/.m2/$CI_COMMIT_SHA/app.jar } function docker_build() { cp $HOME/.m2/$CI_COMMIT_SHA/app.jar src/main/docker/app.jar # docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $REGISTRY_ADDRESS docker login -u $REGISTRY_USER -p $REGISTRY_PWD $REGISTRY_ADDRESS docker build --pull -t $REGISTRY_ADDRESS/$PROJECT_NAME/$APPLICATION_NAME:$CI_COMMIT_TAG src/main/docker docker push $REGISTRY_ADDRESS/$PROJECT_NAME/$APPLICATION_NAME:$CI_COMMIT_TAG rm -rf $HOME/.m2/$CI_COMMIT_SHA } #用来定义 所有的jobs开始之前执行的命令 before_script: - *auto_devops .deploy.yml文件介绍，通过下面事例进行简单讲解。 # Api服务版本 apiVersion: devops/v1alpha2 # 服务类型 kind: MicroService # 服务所属分组 group: io.choerodon.test # 服务代码 code: order-service # 服务名称 name: 订单服务 # 服务版本，该值不需要填写，在CI中会自动生成 version: ${VERSION} # 在构建镜像阶段生成的镜像地址，该值不需要填写，在CI中会自动生成 image: registry.digital.saas.carllhw.com/devops/order-service:${IMAEG_TAG} # Git Commit ID，该值不需要填写，在CI中会自动生成 commit: ${COMMIT} # 如要开放在网关进行访问，则添加该属性，如不需要删除即可 gatewayPath: \"/test/**\" # 依赖服务列表 services: # 依赖的服务类型 - kind: MicroService # 依赖的服务所属组 group: com.hand.hapcloud # 依赖的服务代码 code: hap-register-server # 是否必要 require: 1 - kind: MicroService group: com.hand.hapcloud code: hap-api-gateway require: 1 - kind: MicroService group: com.hand.hapcloud code: hap-config-server require: 1 - kind: MicroService group: com.hand.devops code: hap-gitlab-service require: 1 - kind: MicroService group: com.hand.hapcloud code: hap-user-service require: 1 # 定义环境变量列表，此处声明的环境变量可以在部署服务时在界面上进行重新赋值 vars: # 环境变量名称，该值对应下面stages列表中各需填充的属性 - name: SPRING_PROFILES_ACTIVE # 环境变量描述 description: springProfiels # 默认值，该值对应下面stages列表中各需填充的属性值 value: sit - name: SPRING_CLOUD_CONFIG_DISCOVERY_SERVICE_ID description: configServer value: hap-config-server - name: SPRING_CLOUD_CONFIG_DISCOVERY_ENABLED description: isConfigEnabled value: \"true\" # 依赖资源列表 resources: # 自定义资源名称，该值对应下面stages列表中各需填充的属性值 - name: db # 资源类型 type: mysql - name: userdb type: mysql - name: rabbitmq type: rabbitmq - name: configdb type: mysql - name: eureka type: url - name: kafka type: url # 部署阶段 stages: # 该阶段名称 - name: 初始化数据库 # 该阶段类型 type: PrepareDB # 该阶段描述 description: \"初始化当前服务数据库和用户服务数据库\" # 配置信息 config: # 数据库列表 db: # 自定义名称 - name: 初始化当前服务数据库 # 这里的db对应上面依赖资源列表中的db HOST则为db的属性 host: \"{{ db.HOST }}\" port: \"{{ db.PORT }}\" schema: \"{{ db.SCHEMA }}\" username: \"{{ db.USERNAME }}\" password: \"{{ db.PASSWORD }}\" # 指定数据源 dataJar: /app.jar - name: 初始化用户服务数据库 host: \"{{ userdb.HOST }}\" port: \"{{ userdb.PORT }}\" schema: \"{{ userdb.SCHEMA }}\" username: \"{{ userdb.USERNAME }}\" password: \"{{ userdb.PASSWORD }}\" # 指定数据源，这里与上面dataJar属性二选一 dataDir: /hap-user-service-db - name: 初始化配置 type: ConfigJob description: \"初始化配置信息\" config: # 数据库列表 db: # 自定义名称 - name: 初始化当前服务数据库 # 这里的db对应上面依赖资源列表中的configdb HOST则为configdb的属性 host: \"{{ configdb.HOST }}\" port: \"{{ configdb.PORT }}\" schema: \"{{ configdb.SCHEMA }}\" username: \"{{ configdb.USERNAME }}\" password: \"{{ configdb.PASSWORD }}\" # 指定数据源 configFile: application-deploy.yml - name: 部署 type: Deploy description: \"部署当前服务\" config: # 服务端口号 port: 8060 # 服务管理端口 managementPort: 8061 # 服务运行时会用到的环境变量列表，name为环境变量名 env: - name: SPRING_DATASOURCE_URL # 引用resources列表中资源值 value: \"jdbc:mysql://{{ db.HOST }}:{{ db.PORT }}/{{ db.SCHEMA }}?useUnicode=true&characterEncoding=utf-8&useSSL=false\" - name: SPRING_DATASOURCE_USERNAME value: \"{{ db.USERNAME }}\" - name: SPRING_DATASOURCE_PASSWORD value: \"{{ db.PASSWORD }}\" - name: SPRING_PROFILES_ACTIVE # 应用Vars列表中的环境变量 value: \"{{ vars.SPRING_PROFILES_ACTIVE }}\" - name: SPRING_CLOUD_CONFIG_DISCOVERY_SERVICE_ID value: \"{{ vars.SPRING_CLOUD_CONFIG_DISCOVERY_SERVICE_ID }}\" - name: SPRING_CLOUD_CONFIG_DISCOVERY_ENABLED value: \"{{ vars.SPRING_CLOUD_CONFIG_DISCOVERY_ENABLED }}\" - name: EUREKA_DEFAULT_ZONE value: \"{{eureka.HOST}}\" - name: SPRING_RABBITMQ_HOST value: \"{{rabbitmq.HOST}}\" - name: EVENT_CONSUMER_KAFKA_BOOTSTRAP_SERVERS value: \"{{kafka.HOST}}\" 单元测试。 进入项目根目录，打开命令窗口，输入mvn命令，检查单元测试是否通过。 $ mvn package -U -DskipTests=false 单元测试成功后，提交代码。 # 将本地代码变动提交到暂存区 $ git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1001:feature-1001 运行CI，基于feature分支，具体执行细节请看上面.gitlab-ci.yml文件。进入服务详情，点击流水线 查看 CI 执行情况。 进入服务详情页面，点击分支管理，在分支列表找到feature-1001，点击结束分支。 生成版本 服务版本是代码提交的历史记录，每提交一次修改后的代码，对应生成一个新的版本。具体的操作步骤如下： 结束分支之后，feature-1001分支的代码会合并到develop分支，并触发Gitlab CI。进入服务详情，点击流水线 查看CI执行情况。CI阶段具体执行细节参考.gitlab-ci.yml文件。 Choerodon 缺省的 CI 流程有三个阶段: 单元测试，编译打包，代码质量检查 构建docker镜像 创建服务版本 进入服务详情，点击服务版本，确定服务版本已经生成。 发布服务 服务版本成功生成后，使用项目所有者、源代码管理员和项目成员的任一角色就可以将服务发布到不同的环境。发布之前确定环境可以连接测试成功，关于环境的配置信息请参考环境配置。具体的操作步骤如下： 点击菜单栏开发管理，选择服务，进入服务管理页面，搜索服务编码order-service 选择这行记录，点击右侧详情，进入到服务详情界面，点击服务版本查看生成的服务版本。 点击菜单栏发布，进入到服务发布界面，查看到服务版本，点击右侧发布，系统会弹出模态框，输入你要发布到哪个环境，点击保存。发布成功后，右侧边栏会显示服务基本信息和发布环境。 在服务详情页面，设置服务自动发布，下一次CI执行完成后生成的服务版本会自动发布到已配置的环境。自动发布配置 部署服务 提供可视化、一键式部署服务，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。具体的操作步骤如下： 确认部署时需要使用的资源已配置完全。资源配置 使用部署管理员的角色登录Choerodon系统，选择运营组织 在菜单栏选择部署管理，在部署管理下面选择服务，进入服务管理页面，搜索order-service服务，点击右侧详情，进入到服务版本界面。 点击服务版本，选择要部署的服务版本，点击右侧部署服务，进入到部署界面，选择资源，点击部署。 注：服务第一次部署需要自己手动填写资源，再次部署页面会显示上一次部署选择的资源。选择资源一定要谨慎，选择错误严重会导致数据库数据丢失。 为所选的微服务将网关信息注册至微服务管理服务，注册后，该微服务才能正常访问。网关管理 查看运行信息 进入服务管理页面，搜索order-service服务，点击右侧详情，进入到服务版本界面，点击运行中，可以查看运行中的版本。 那么如何判断这个服务版本已经部署成功？当可用容器数量、当前容器数量、期望容器数量都为1时，代表该服务版本已经部署成功了。期望容器数量的加减实际是对kubernetes的pod数量的加减，例如期望容器数量为2，代表kubernetes启动了2个pod，如果其中一个故障了，还能保证程序正常使用，目前期望容器数量不可为0。 在服务版本界面，点击运行中，点击服务版本右侧的详情，进入到部署详情界面。点击部署阶段可以查看到阶段信息，点击日志可以查看到每个阶段的日志信息。点击详情可以查看到服务部署在kubernetes上的信息。 "},"/zh/docs/quick-start/microservice-front":{"url":"zh/docs/quick-start/microservice-front","title":"创建一个Web前端服务","description":"","language":"zh","body":"概述 Web前端服务主要是指微服务的前端服务。Choerodon 使用 React 和 MobX 作为前端的UI应用框架，并且对前端的展示做了一定的封装和处理，能够让用户方便快捷的进行前端服务的开发、发布和部署。 React 和 MobX都提供了最优和独特的解决方案。React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。 目标 本章节将从创建Web前端服务、开发前端、创建分支、提交代码、发布版本、部署等方面介绍，让读者能够熟悉使用Choerodon创建Web前端服务的步骤和流程，并且学会如何利用Choerodon发布版本和部署服务等。 前置条件 在操作之前保证系统配置已经配置完全。 创建一个项目，Web前端服务必须在项目中创建。 新建服务 菜单层次：项目层 菜单路径：开发管理 > 服务 默认角色：项目所有者、源代码管理员 点击创建按钮。 输入 “服务编码” 、 “服务名称” 、以及 “服务组” ，并选择相应服务类型，点击 创建 按钮。 a. 服务编码只能包含字母、数字、_、.、破折号和空格并且不能包含大写字母 b. 服务组输入不能包含中文或大写字母 不能以'.'开头或结尾 新建服务 “front0307” 已在服务管理列表中。 gitlab已自动创建好对应服务类型的代码库 “front0307” 。点击 仓库地址 ，可以查看该服务在gitlab的代码仓库。 注：新建服务的演示使用的是模板 服务版本 服务版本是代码提交的历史记录，每提交一次修改后的代码，对应生成一个新的版本。 菜单层次：项目层 菜单路径：开发管理 > 服务> 服务详情 > 服务版本 默认角色：项目所有者、源代码管理员、项目成员 进入服务详情后， 查看服务CI pipeline的完成情况，只有CI各个阶段跑成功了才会生成一条服务版本信息。 查看服务版本信息。 服务发布 该模块提供将服务发布至不同环境的功能，向目标环境传输部署文件，同时附带服务版本信息以便追踪。 菜单层次：项目层 菜单路径：开发管理 > 发布 默认角色：项目所有者、源代码管理员、项目成员 点击 发布 。 关键字搜索或直接从从下拉列表中选择部署文件发布的环境，已发布的环境不能重新发布。发布的环境需要先在组织层配置。 注：环境配置 该服务部署文件已成功发布在某个环境。 设置服务 “自动发布”，下一次生成的服务版本会自动发布到已配置的环境。自动发布配置 新建资源 定义部署时需要使用的资源。资源配置 域名管理 目前Web前端及Web应用需配置域名，若不配置域名，不能进行外网访问该前端，只能查看系统提供的pod ip。域名配置 服务部署 提供可视化、一键式部署服务，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 菜单层次：组织层 菜单路径：部署管理 > 服务 默认角色：部署管理员 点击 部署管理 ，点击 服务 ，查看服务列表。 点击详情。 查看该服务版本信息。 在服务列表中找到要部署的服务，点击详情，例如\"front0307\"。 选择发布的版本，点击部署服务。 进行资源选择，点击部署。 注：服务第一次部署需要自己手动填写资源，再次部署页面会显示上一次部署选择的资源。选择资源一定要谨慎，选择错误严重会导致数据库数据丢失。 点击详情，可在运行中查看正在部署/运行的版本，以及对容器数量进行调整。 注：可用容器数量、当前容器数量、期望容器数量都为1时，代表该服务已经部署好了。期望容器数量的加减实际是对kubernetes的pod数量的加减，例如期望容器数量为2，代表kubernetes启动了2个pod，其中一个挂了，还能保证程序正常使用，目前期望容器数量不可为0。 点击详情，查看服务部署阶段，点击部署阶段，点击域名地址访问。 注：如果没有配置域名，此处显示的是IP地址。 灰度部署用于保障系统稳定，验证某服务版本是否正常使用，验证正常后再转为正式部署。 设置了自动部署，服务版本发布不再需要手动部署。 "},"/zh/docs/quick-start/mobile-application":{"url":"zh/docs/quick-start/mobile-application","title":"创建一个移动服务","description":"","language":"zh","body":"移动应用 本页面演示了移动应用从新建到从手机上访问应用等流程操作。使用本页面，你可以了解： 新建应用 菜单层次：项目层 菜单路径：开发管理 > 服务 默认角色：项目所有者、项目成员 点击创建按钮。 输入 “服务编码” 、 “服务名称” 、以及 “服务组” ，并选择相应服务类型为移动，点击 创建 按钮。 a. 服务编码只能包含字母、数字、_、.、破折号和空格并且不能包含大写字母 b. 服务组输入不能包含中文或大写字母 不能以'.'开头或结尾 c. 服务名称不是移动端展示的模块名称 新建服务 choerodon 已在服务管理列表中。 gitlab已自动创建好对应服务类型的代码库 choerodon 。点击 仓库地址 ，可以查看该服务在gitlab的代码仓库。 注：新建应用的演示使用的是模板 开发应用 拉取代码后，在develop分支上进行开发，开发完成后修改output/bundleManagement.json文件，推送代码。 a. bundle下的description是该应用的描述 b. iconName为该应用在移动端显示时，名字前的图标 c. isMain判断是否为主模块，0为非主模块 b. nameCn为展示的中文名，该名字会显示在移动端 e. description为应用版本升级时的升级信息 f. type指定平台，Android和iOS g. appCoreVersion为最低核心版本，即低于该版本的APP无法启用该模块 h. status为自动启用选项，0为不自动启用 { \"bundle\": { \"description\": \"模块描述\" \"iconName\": \"md-log-in\" \"isMain\": \"0\" \"nameCn\": \"Choerodon\" } \"description\": \"更新描述\" \"type\": \"Android\" \"appCoreVersion\": \"1.0.0\" \"status\": \"0\" } 进入服务详情后， 查看服务CI pipeline的完成情况，只有CI各个阶段跑成功了才会生成一条服务版本信息，CI完成后将会自动发布到环境。 发布应用 移动应用模块均为自动发布，在CI pipeline完成后稍等片刻即可。 应用配置 该模块提供APP配置模块功能，可以通过该模块实现多APP多不同应用配置的个性化设置。 菜单层次：组织层 菜单路径：APP 默认角色：项目所有者、源代码管理员、项目成员 新建一个名为 DigitalPlatform 的APP。 点击DigitalPlatform的 版本管理 ，新建iOS和Android的类型。 返回上一级目录，点击对应APP的 模块配置 。 关键字搜索或直接找到目标模块，勾选要在该APP中可以使用的模块，点击保存。 版本管理 菜单层次：组织层 菜单路径：模块 默认角色：项目所有者、源代码管理员、项目成员 在部署成功中选中进行启用 最终结果 最后，就可以在移动端应用模块菜单中看到刚刚发布的模块，点击进行下载即可。 现在你已经懂得如何开发一个模块了。 "},"/zh/docs/quick-start/project":{"url":"zh/docs/quick-start/project","title":"创建一个项目","description":"","language":"zh","body":"创建一个项目 目标 项目是 Choerodon 的组织开发的基本形式，项目位于组织下面，一个项目包含与开发相关的资源、环境、敏捷管理，以及用户权限控制等。项目是进行应用创建与开发，敏捷管理，持续交付和持续部署的基础，必须先创建项目，才能够进行进一步的工作。 本章节将从创建项目、以及定义环境、资源等方面介绍 Choerodon 的项目。让读者能够了解项目的基本概念，学会创建项目的基本操作和注意事项等，以及学会为项目分配权限，为项目创建环境信息等。 前置条件 在操作之前保证系统配置已经配置完全。 创建项目 使用项目创建者的角色登录Choerodon系统，选择运营组织 在组织层的用户服务，在用户服务下面选择项目，进入项目管理页面，在项目管理中创建项目。系统会弹出侧边栏，在侧边栏中输入项目编码和项目名称点击创建，即可创建新的项目。 项目编码：devops 项目名称：DevOps 项目编码 必须输入且不能包含中文或大写字母， 项目名称 必须输入且名称字符必须在4~30之间。 当项目创建成功，Choerodon同时会在Gitlab中创建一个Group和ISSUE库。我们可以登录到gitlab检查创建。 Gitlab Group 的名称是 devops，是项目编码。 设置权限 项目创建完成之后，需要为相关人员分配权限。具体的操作步骤如下： 同样使用项目创建者的角色登录系统，并切换到已经创建的项目下，例如DevOps。 进入到用户服务，然后选择角色分配，进入角色分配操作界面。 与项目相关的角色权限如下表： 角色 | 权限 | 层级 --- | --- | --- 项目所有者 | 角色分配（所在项目下）服务创建、服务详情查看、分支管理、服务版本、代码质量查看、服务发布、设置自动发布 | 项目层 源代码管理员 | 服务创建、服务详情查看、分支管理、服务版本、代码质量查看、服务发布 | 项目层 项目成员 | 服务详情查看、分支管理、服务版本、代码质量查看、服务发布 | 项目层 看板项目所有者 | 故事管理、冲刺管理、任务和缺陷 | 项目层 看板项目成员 | 故事管理、冲刺管理、任务和缺陷 | 项目层 开发监控查看者 | 全流程信息监控查看 | 项目层 用户可以根据具体情况分配相关权限。例如，项目成员。 选择添加按钮，在如下的弹框中输入用户账号，并且选择相关权限，例如，用户2199，权限项目成员。 用户可以选择删除用户的权限和用户信息。 创建环境 环境主要是开发区向运行区发布服务的通道。由于开发区和运行区都是部署Kubernetes集群上的微服务框架，所以，环境本质上就是目标运行区的gateway地址。开发区的服务会使用到这个环境地址，将新产生的版本，发布到对应的运行区。例如，项目A经过一个冲刺产生了服务B的最新版本1.0.1，此时在项目A下面定义了两个环境，即测试环境和正式环境，项目A按照既定的项目管理流程现将服务B的最新版本1.0.1发布到测试环境，并部署，以供测试人员测试；当测试通过，再将1.0.1版本发布到正式环境，并部署。 具体的创建步骤如下： 使用项目创建者角色登录系统，选择项目，例如DevOps，然后选择开发管理，点击进入环境功能模块。 在环境模块，点击创建，系统会弹出一个侧边栏，请在侧边栏中输入相应的环境信息，有环境名称、环境描述、环境地址和环境密钥等。 环境名称：`development` 环境描述：`开发环境` 环境地址：`http://gateway.devops.saas.choerodon.com` 环境密钥：`******` 根据用途配置不同的环境，常见的有开发环境，集成测试环境，用户访问测试环境及正式环境。请输入正确的环境地址和环境密钥，建议测试是否配置正确。 最后，可以测试连接是否正确。 总结 项目是Choerodon最重要的概念，它是开发区组织资源的基本形式。通过本章节简单的学习，我们可以在Choerodon系统中创建自己的项目以及设置相关环境和权限等。用户可以根据自己具体的情况来创建项目，根据DevOps和敏捷管理的思想，Choerodon 建议按照一个Scrum中Develop团队的规模（6-9个人）来划分项目，例如，我们可能要开发3个微服务和前端，那么我们可以分成3个项目组，每个项目组负责一个微服务和一个前端。那么就需要创建3个项目。 "},"/zh/docs/quick-start/story-kanban":{"url":"zh/docs/quick-start/story-kanban","title":"使用敏捷管理工具","description":"","language":"zh","body":"正在更新，敬请期待... "},"/zh/docs/quick-start/web-application":{"url":"zh/docs/quick-start/web-application","title":"创建一个普通Web服务","description":"","language":"zh","body":"Web应用 本页面介绍了以DevOps平台为基础，演示了Web应用从新建到部署等流程操作。 在操作之前保证系统配置已经配置完全。 新建服务 菜单层次：项目层 菜单路径：开发管理 > 服务 默认角色：项目所有者、源代码管理员 点击创建按钮。 输入 “服务编码” 、 “服务名称” 、以及 “服务组” ，并选择相应服务类型，点击 创建 按钮。 a. 服务编码只能包含字母、数字、_、.、破折号和空格并且不能包含大写字母 b. 服务组输入不能包含中文或大写字母 不能以'.'开头或结尾 新建服务 “application0307” 已在服务管理列表中。 gitlab已自动创建好对应服务类型的代码库 “application0307” 。点击 仓库地址 ，可以查看该服务在gitlab的代码仓库。 上传Web应用代码到新建的gitlab仓库。 服务版本 服务版本是代码提交的历史记录，每提交一次修改后的代码，对应生成一个新的版本。 菜单层次：项目层 菜单路径：开发管理 > 服务> 服务详情 > 服务版本 默认角色：项目所有者、源代码管理员、项目成员 查看流水线信息。进入服务详情后， 查看服务CI pipeline的完成情况，只有CI各个阶段跑成功了才会生成一条服务版本信息。 查看服务版本信息。 服务发布 该模块提供将服务发布至不同环境的功能，向目标环境传输部署文件，同时附带服务版本信息以便追踪。 菜单层次：项目层 菜单路径：开发管理 > 发布 默认角色：项目所有者、源代码管理员、项目成员 点击 发布 。 关键字搜索或直接从从下拉列表中选择部署文件发布的环境，已发布的环境不能重新发布。发布的环境需要先在组织层配置。 注：环境配置 该服务部署文件已成功发布在某个环境。 设置服务 “自动发布”，下一次生成的服务版本会自动发布到已配置的环境。自动发布配置 新建资源 定义部署时需要使用的资源。资源配置 域名管理 目前Web前端及Web应用需配置域名，若不配置域名，不能进行外网访问该前端，只能查看系统提供的pod ip。域名配置 服务部署 提供可视化、一键式部署服务，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 菜单层次：组织层 菜单路径：部署管理 > 服务 默认角色：部署管理员 点击 部署管理 ，点击 服务 ，查看服务列表。 点击详情。 查看该服务版本信息。 在服务列表中找到要部署的服务，点击详情，例如\"yshap180306\"。 选择发布的版本，点击部署服务。 进行资源选择，点击部署。 注：服务第一次部署需要自己手动填写资源，再次部署页面会显示上一次部署选择的资源。选择资源一定要谨慎，选择错误严重会导致数据库数据丢失。 点击详情，可在运行中查看正在部署/运行的版本，以及对容器数量进行调整。 注：可用容器数量、当前容器数量、期望容器数量都为1时，代表该服务已经部署好了。期望容器数量的加减实际是对kubernetes的pod数量的加减，例如期望容器数量为2，代表kubernetes启动了2个pod，其中一个挂了，还能保证程序正常使用，目前期望容器数量不可为0。 点击详情，查看服务部署阶段，点击部署阶段，点击域名地址访问。 注：如果没有配置域名，此处显示的是IP地址。 灰度部署用于保障系统稳定，验证某服务版本是否正常使用，验证正常后再转为正式部署。 设置了自动部署，服务版本发布不再需要手动部署。 "},"/zh/docs/reference/API":{"url":"zh/docs/reference/API","title":"API","description":"","language":"zh","body":"正在更新，敬请期待... "},"/zh/docs/reference/":{"url":"zh/docs/reference/","title":"参考","description":"","language":"zh","body":"参考 "},"/zh/docs/reference/markdown":{"url":"zh/docs/reference/markdown","title":"Markdown 编写规范","description":"","language":"zh","body":"在App Engine灵活环境中快速启动Go 本快速入门介绍如何创建一个显示简短消息的小型App Engine应用程序。 在你开始之前 在运行和部署此示例之前，请执行以下步骤： 使用GCP控制台创建新的GCP项目，创建App Engine应用程序并启用计费： 提示时，选择的区域 ，你希望你的App Engine应用程序所在，然后启用计费。 在本地安装以下先决条件： a. 下载并安装git。 b. 下载并安装Google Cloud SDK，然后初始化该 gcloud工具： 或者：您可以使用 已安装git和Cloud SDK的Google Cloud Shell以及 许多其他功能，如语言支持和代码编辑器。 在Google云端Shell启动后，您可以继续本教程的其余部分，并在云端Shell中执行您的命令。 本快速入门假设您熟悉Go编程语言，并且已安装Go。 下载Hello World应用程序 我们为Go创建了一个简单的Hello World应用程序，因此您可以快速了解将应用程序部署到App Engine灵活环境的感受。从命令行执行这些步骤以将Hello World下载到本地计算机。 下载示例应用程序并导航到应用程序目录： 获取Hello World示例应用程序及其依赖项： go get -u -d github.com/GoogleCloudPlatform/golang-samples/appengine_flexible/helloworld 切换到包含示例代码的目录： cd $GOPATH/src/github.com/GoogleCloudPlatform/golang-samples/appengine_flexible/helloworld 在本地机器上运行Hello World 在本地计算机上运行Hello World应用程序： 启动本地Web服务器： go run *.go 在您的网络浏览器中，输入以下地址： http://localhost:8080 注意：如果您正在使用云端Shell，请在工具栏中单击 Web预览，然后选择端口8080上的预览。 如果您正在使用云端Shell，请在工具栏中单击 Web预览，然后选择端口8080上的预览。 如果您正在使用云端Shell，请在工具栏中单击 Web预览，然后选择端口8080上的预览。 如果您使用的是现有项目，则还会删除您在项目中完成的其他任何工作。 您不能重复使用已删除项目的项目ID。如果您创建了您计划在将来使用的自定义项目ID，则应该删除项目内部的资源。这可确保使用项目ID的appspot.comURL（例如URL）保持可用。 在App Engine上部署并运行 Hello World 要将您的应用部署到App Engine灵活环境： 通过从helloworld目录运行以下命令部署Hello World应用程序： gcloud应用程序部署 了解可选标志。 通过运行以下命令 启动浏览器并查看应用程序 ：http://YOUR_PROJECT_ID.appspot.com gcloud应用程序浏览 这一次，显示Hello World消息的页面由运行在App Engine实例上的Web服务器提供。 恭喜！您已将第一个Go应用程序部署到App Engine灵活环境！ 请参阅以下各节以获取有关清理的信息以及可以采取的下一步可能的链接。 清理 为避免收费，您可以删除您的GCP项目，以停止对该项目中使用的所有资源进行结算。 警告：删除项目会导致以下后果：如果您使用的是现有项目，则还会删除您在项目中完成的其他任何工作。 您不能重复使用已删除项目的项目ID。如果您创建了您计划在将来使用的自定义项目ID，则应该删除项目内部的资源。这可确保使用项目ID的appspot.comURL（例如URL）保持可用。 在云平台控制台中，转到“项目”页面。 在项目列表中，选择要删除的项目并单击删除项目。 在对话框中输入项目ID，然后单击关闭以删除该项目。 下一步是什么 现在您已经完成了Hello World，您可以开始探索您的下一个示例应用程序：Bookshelf应用程序。Bookshelf应用程序是一个更完整但仍然基本的Go Web应用程序，它使用多个Cloud Platform功能，如数据存储，身份验证，日志记录，发布/订阅等等。 有关App Engine灵活环境的更多信息，请参阅App Engine概述。 Hello World代码审查 Hello World是最简单的App Engine应用程序，因为它只包含一个服务，只有一个版本，所有代码都位于应用程序的根目录中。本节详细介绍每个应用程序文件。 helloworld.go 该helloworld.go文件注册一个侦听请求的处理程序/，并用'Hello world！'进行响应。信息。 package main import ( \"fmt\" \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\" handle) http.HandleFunc(\"/_ah/health\" healthCheckHandler) log.Print(\"Listening on port 8080\") log.Fatal(http.ListenAndServe(\":8080\" nil)) } func handle(w http.ResponseWriter r *http.Request) { if r.URL.Path != \"/\" { http.NotFound(w r) return } fmt.Fprint(w \"Hello world!\") } func healthCheckHandler(w http.ResponseWriter r *http.Request) { fmt.Fprint(w \"ok\") } app.yaml ``` runtime: go env: flex # This sample incurs costs to run on the App Engine flexible environment. # The settings below are to reduce costs during testing and are not appropriate # for production use. For more information see: # https://cloud.google.com/appengine/docs/flexible/python/configuring-your-app-with-app-yaml manual_scaling: instances: 1 resources: cpu: 1 memory_gb: 0.5 disk_size_gb: 10 ``` 在这里， app.yaml指定应用程序使用的运行时和设置env: flex，指定应用程序使用灵活的环境。 有关Go运行时如何工作的更多信息，请参阅 Go运行时。 有关如何设计应用以利用版本和服务的更多详细信息，请参阅 App Engine概述。 有关App Engine配置设置的更多详细信息，请参阅 使用app.yaml配置您的应用程序。 "},"/zh/docs/user-guide/":{"url":"zh/docs/user-guide/","title":"用户手册","description":"","language":"zh","body":"用户手册 本用户手册介绍了Choerodon各环节的操作步骤。Choerodon的用户可以通过此章节了解每个环节的概念定义、主要功能流程及其他注意事项。使用本教程，你可以了解： 系统配置 是为了让Choerodon的用户更便捷、科学地使用平台，需在用户使用前进行的系统配置，包括角色、用户、项目、环境等。 敏捷管理 介绍了团队在需求从产生到确定的过程中需要进行绘制用户故事地图、计划产品发布、设立冲刺计划、使用看板管理需求等功能，融合敏捷开发、精益IT、DevOps思想，满足团队管理需求及计划。 持续集成 描述了用户在进行产品开发时可以使用Choerodon进行管理服务、使用Git-Flow模型进行分支管理、查看持续集成流水线、管理服务版本、了解代码质量，以及开发完成将服务版本发布至运行区。 持续部署 介绍了用户可以在Choerodon运行区进行服务部署，及与服务部署紧密相关的资源管理、网关管理、域名管理。 "},"/zh/docs/user-guide/api/Site6_instance":{"url":"zh/docs/user-guide/api/Site6_instance","title":"实例管理","language":"zh","body":"实例管理 实例管理界面只显示平台已有实例，用户只能进行查询实例、查看实例详情和更改实例配置的操作。 实例与微服务的关系：微服务与实例为一对多的从属关系。一个微服务可以有多个实例，一个实例只能属于一个微服务。 实例与配置的关系：配置与实例为一对多的应用关系。同一个微服务下，一个配置可以被多个实例应用，一个实例只能应用一个配置。 功能： 实例列表 实例查询 实例详情 应用配置 实例列表 列表字段： 实例ID：实例ID具有唯一性，是实例的标识。实例ID的展示形式为::。 实例状态：一般为UP、DOWN特定字段值。 所属微服务：为微服务名称，因为微服务名称是微服务的标识。一个实例只能属于一个微服务，一个微服务可以有多个实例。 实例查询 必填项： 可查询字段： 实例ID：选中实例ID字段，搜索框下方出现所有实例ID的列表。可以继续输入目标实例ID进行过滤，下方实例ID列表随输入值实时更新，输入值最好为::形式。最后可以选中实例ID列表的列表项，或输入正确的实例ID按回车键进行提交。 实例状态：选中实例状态字段，搜索框下方出现所有实例状态的列表，一般为UP、DOWN两个列表项。 所属微服务：选中所属微服务字段，搜索框下方出现所有实例所属微服务的列表。选中一个微服务名称，则实例列表列出所有属于该微服务的实例。 实例详情 详情字段： 实例ID：实例ID的展示形式为::。实例ID具有唯一性，是实例的标识。 主机名：分配给实例的地址。 IP：实例的实际地址。 所属微服务：实例属于的微服务的微服务名称。 端口号：实例的端口号。 上次注册时间：实例上一层注册的时间。 元数据：可以有多条数据项。每条数据项为名字-值的组合。 应用配置 即实例应用配置。一个实例只能应用一个配置。 配置列表字段为配置ID，因为配置ID是配置的标识。列表为实例所属服务下的所有配置。 下图为同一个微服务下，实例应用配置的关系图。 "},"/zh/docs/user-guide/api/Site7_config":{"url":"zh/docs/user-guide/api/Site7_config","title":"配置管理","language":"zh","body":"配置管理 配置管理界面可以自己创建配置 配置一旦创建，不可以修改，只能基于这个配置创建一个新的配置。 配置与微服务的关系：微服务与配置为一对多的从属关系。一个微服务可以有多个配置，一个配置只能属于一个微服务。 配置与实例的关系：配置与实例为一对多的应用关系。同一个微服务下，一个配置可以被多个实例应用，一个实例只能应用一个配置。 功能： 配置列表 配置查询 配置详情 创建配置 基于一个已有配置创建配置 默认配置 应用配置 删除配置 配置列表 列表字段： 配置ID：配置ID具有唯一性，是配置的标识。配置ID根据所属服务系统自动生成，系统生成规则为所属服务名加上配置ID生成时间戳，用户也可以自己编辑。配置ID不能为空，不能包含汉字和特殊字符。 配置版本：配置版本是用户自定义的，可以和常见版本命名一样，如1.2.0。 所属微服务：配置属于的微服务的微服务名称。微服务名称是微服务的标识。 是否为默认：是否为默认配置。布尔类型的字段。如果不为默认配置，列表中该字段的值为空，如果为默认配置，界面上该字段的值为“是”。一个微服务只能有一个默认配置，如果设置当前配置为默认配置，那么上一个默认配置失效。默认配置的作用是，如果在该配置所属的微服务下新建实例，那么这个新建的实例自动应用默认配置。 应用实例数：应用该配置的实例的个数。 配置查询 可查询字段： 配置ID：配置ID是配置的标识，可以根据配置ID查询配置。 所属微服务：所属微服务的字段值为微服务名称。输入微服务名称，显示该微服务下的所有配置。 配置详情 详情字段： 配置ID：配置ID具有唯一性，是配置的标识。配置ID根据所属服务系统自动生成，系统生成规则为所属服务名加上配置ID生成时间戳，用户也可以自己编辑。配置ID不能为空，不能包含汉字和特殊字符。 配置版本：配置版本是用户自定义的，可以和常见版本命名一样，如1.2.0。 所属微服务：配置属于的微服务的微服务名称。微服务名称是微服务的标识。 是否为默认：若值为是，则为默认配置；若值为否，则为非默认配置。一个微服务只能有一个默认配置，如果设置当前配置为默认配置，则上一个默认配置失效。默认配置的作用是，如果在该配置所属的微服务下新建实例，则这个新建的实例自动应用默认配置。 应用实例数：应用该配置的实例的个数。 创建日期：配置创建成功的日期。格式为年-月-日 时:分:秒。 来源：分为工具生成和页面创建两种。如果是用户在界面创建的配置，则来源为页面创建。否则为工具生成。 配置项：可以是大于等于零条配置项。 创建配置 必填字段： 所属微服务：配置属于的微服务的微服务名称。微服务名称是微服务的标识。只有先选择所属微服务，才能编辑配置ID，否则不能编辑。 配置ID：配置ID具有唯一性，是配置的标识。配置ID根据所属服务系统自动生成，系统生成规则为所属服务名加上配置ID生成时间戳，用户也可以自己编辑。配置ID不能为空，不能包含汉字和特殊字符。 配置版本：配置版本是用户自定义的，可以和常见版本命名一样，如1.2.0。 选填字段： 是否为默认：如果没有勾选，则不为默认配置；如果勾选，则为默认配置，并使上一个默认配置变为非默认配置。一个微服务只能有一个默认配置，如果设置当前配置为默认配置，则上一个默认配置失效。默认配置的作用是，如果在该配置所属的微服务下新建实例，则这个新建的实例自动应用默认配置。 配置项：可以是大于等于零条配置项。允许踹西安名字非空、值为空的配置项，不允许出先名字为空、值非空的配置项。 基于一个已有配置创建配置 必填字段： 所属微服务：继承了已有配置的所属微服务，新配置将不可更改该字段的值 配置ID：配置ID具有唯一性，是配置的标识。配置ID根据所属服务系统自动生成，系统生成规则为所属服务名加上配置ID生成时间戳，用户也可以自己编辑。配置ID不能为空，不能包含汉字和特殊字符。 配置版本：配置版本是用户自定义的，可以和常见版本命名一样，如1.2.0。 选填字段： 是否为默认：如果没有勾选，则不为默认配置；如果勾选，则为默认配置，并使上一个默认配置变为非默认配置。一个微服务只能有一个默认配置，如果设置当前配置为默认配置，则上一个默认配置失效。默认配置的作用是，如果在该配置所属的微服务下新建实例，则这个新建的实例自动应用默认配置。 配置项：继承了已有配置的配置项，并可对这些配置项删除可修改，也可以增加新的配置项。可以是大于等于零条配置项。允许出现名字非空、值为空的配置项，不允许出现名字为空、值非空的配置项。 默认配置 一个微服务只能有一个默认配置，如果设置当前配置为默认配置，则上一个默认配置失效。默认配置的作用是，如果在该配置所属的微服务下新建实例，则这个新建的实例自动应用默认配置。 应用配置 即实例应用配置。一个配置可被多个实例应用。 下图为同一个微服务下，配置被实例应用的关系图。 删除配置 如果一个配置下应用该配置的实例个数为零，则可以删除该配置，否则，不可以删除该配置。 "},"/zh/docs/user-guide/api/Site8_microservice":{"url":"zh/docs/user-guide/api/Site8_microservice","title":"微服务管理","language":"zh","body":"微服务管理 微服务管理界面只显示平台已有微服务，用户只能查询微服务，无法进行其他操作。 服务、实例、配置的关系如下图所示： 一个实例只能属于一个微服务，一个微服务可以有多个实例； 一个配置只能属于一个微服务，一个微服务可以有多个配置； 同一个微服务下，一个实例只能应用一个配置，一个配置可以被多个实例应用。 功能： 微服务列表 微服务查询 实例详情 微服务列表 列表字段： 微服务名称：微服务名称具有唯一性，是微服务的标识。一般为大小写字母、数字、下划线“_”、中划线“-”、的组合。 实例数：属于微服务的实例的个数。具体实例信息可在实例管理中，通过搜索微服务名称进行查看。 微服务查询 可查询字段： 微服务名称：选择微服务名称字段，搜索框下方出现所有微服务名称的列表。可以继续输入目标微服务名称进行过滤，搜索框下方微服务名称列表随输入值实时更新，搜索不区分大小写。最后可以选中微服务名称列表的列表项，或输入正确的微服务名称按回车键进行提交。 实例详情 只有微服务的实例数大于零时，才可以查看微服务的实例详情。 详情字段： 实例ID：实例详情展示的内容为属于该微服务的实例列表。实例列表字段为实例ID，因为实例ID为实例的标识。 "},"/zh/docs/user-guide/api/Site9_route":{"url":"zh/docs/user-guide/api/Site9_route","title":"路由管理","language":"zh","body":"路由管理 路由发送请求到网关，由网关处理发送到微服务。路由管理是对路由名称、路径以及路由其他配置信息的管理。一个路由只能有一条路径，对应一个微服务。一个微服务可以被多个路径对应到。 功能： 路由列表 路由查询 创建路由 编辑路由 删除路由 路由列表 列表字段： 路由名称：路由名称具有唯一性，是路由的标识。 路径：路由的路径是路由的重要信息。路由由路径对应到微服务。 对应为微服务：路径指向的微服务。 路由查询 可查询字段： 路由名称：路由名称具有唯一性，是路由的标识。 路径：路由的路径是路由的重要信息。路由由路径对应到微服务。 对应为微服务：路径指向的微服务。 创建路由 必填字段： 路由名称：路由名称具有唯一性，是路由的标识。 路径：路由的路径是路由的重要信息。路由由路径对应到微服务。格式一般为/devops/**。 选填字段： 对应为微服务：路径指向的微服务。只能选择一个系统已有的微服务。 URL：填写时要符合URL编码。 是否有前缀：勾选表示有前缀，未勾选表示无前缀。如果路径为/iam/ 。有前缀时，会路由到iam-service/iam/ ，无前缀时，会路由到iam-service/**。 是否重试：勾选表示重试，即网关发送给服务的请求失败时，继续重试。未勾选表示不重试。 是否有敏感头信息：勾选表示有敏感头信息，未勾选表示无敏感头信息。有敏感头信息时，需要填写敏感头信息。 敏感头信息：勾选了是否有敏感头信息后，需要填写该字段。敏感头即为key，多个敏感头之间用逗号“ ”分隔开。 Helper服务名：如果为空，则网关走平台的GatewayHelper；否则，走用户所填的Helper服务。 编辑路由 必填字段： 路由名称：路由名称具有唯一性，是路由的标识。 路径：路由的路径是路由的重要信息。路由由路径对应到微服务。格式一般为/devops/**。 选填字段： 对应为微服务：路径指向的微服务。只能选择一个系统已有的微服务。 URL：填写时要符合URL编码。 是否有前缀：勾选表示有前缀，未勾选表示无前缀。如果路径为/iam/ 。有前缀时，会路由到iam-service/iam/ ，无前缀时，会路由到iam-service/**。 是否重试：勾选表示重试，即网关发送给服务的请求失败时，继续重试。未勾选表示不重试。 是否有敏感头信息：勾选表示有敏感头信息，未勾选表示无敏感头信息。有敏感头信息时，需要填写敏感头信息。 敏感头信息：勾选了是否有敏感头信息后，需要填写该字段。敏感头即为key，多个敏感头之间用逗号“ ”分隔开。 Helper服务名：如果为空，则网关走平台的GatewayHelper；否则，走用户所填的Helper服务。 删除路由 点击操作栏的删除图标，界面弹出删除确认提示，点击取消可以取消删除操作，点击确定彻底删除一个路由。 "},"/zh/docs/user-guide/api/":{"url":"zh/docs/user-guide/api/","title":"API和服务","description":"","language":"zh","body":""},"/zh/docs/user-guide/continuous-deployment":{"url":"zh/docs/user-guide/continuous-deployment","title":"持续部署","description":"","language":"zh","body":"持续部署 持续部署（Continuous Deployment，简称CD）是指不断将研发的代码应用至对应的系统上，开发/测试环境的每次部署都可以通过自动化操作来实现，因此也为部署人员节省大量的时间。 本页面介绍了研发团队在完成敏捷管理、持续集成后将服务版本发布至运行区，则运行区的部署管理员需按实际情况进行服务部署。与此同时，还包括如何管理服务部署所需的资源、网关、域名。部署是在各个运行区独立进行的，即各个运行区只管理本运行区的服务部署。只能部署管理员拥有操作权限。 若您遇到无法访问对应功能，请联系对应负责人进行系统配置，特别是角色分配。 资源管理 资源是指程序运行时所依赖的硬件设施。部署管理员可以再该模块定义部署时需要使用的资源。目前支持六种类型的资源：mysql、redis、rebbitmq、kafka、url、oracle。 菜单层次：组织层 菜单路径：部署服务 > 资源管理 默认角色：部署管理员 新建资源 点击 创建 ，输入 “名称” 、 “描述” 以及选择资源类型，例如mysql。 输入资源相关信息，点击 创建 。新建资源 “hap-devops-test” 就在资源管理列表中。 查看资源详情 点击 “资源名称” ，查看资源详情。 编辑资源 点击 编辑 ，修改资源信息，点击 保存 。 删除资源 点击 删除 。 再次确认，点击 删除 ，即可删除不再需要的资源。 网关管理 网关管理是将所选的微服务的网关信息注册至微服务管理服务，注册后，该微服务才能正常访问。且支持删除网关的注册信息。 菜单层次：组织层 菜单路径：部署服务 > 资源管理 默认角色：部署管理员 注：服务可以访问的两个必要条件：网关注册、服务部署。 新建网关 点击 创建 ，选择需要配置网关的服务，如 “webservice0131” ，点击 创建 。 服务 “webservice0131” 的网关已在网关管理列表中。 删除网关 点击 删除 。 再次确认，点击 删除 。 域名管理 域名管理是为相应的服务创建可访问域名并可对其进行修改。域名后缀为运行区域名后缀，如运行区域名。 注：目前Web前端及普通应用需配置域名，若不配置域名，不能进行外网访问该前端，只能查看系统提供的pod ip。 菜单层次：组织层 菜单路径：部署服务 > 资源管理 默认角色：部署管理员 新建域名 点击 创建 ，选择需要配置域名的服务，并输入 “域名” ，点击 创建 。 服务 “webfront0131” 的域名已在域名管理列表中。 编辑域名信息 点击 编辑 。修改域名信息，点击保存 ，域名修改完成。 删除域名 点击删除。 再次确认，点击删除。 服务部署 提供可视化、一键式部署服务，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 菜单层次：组织层 菜单路径：部署管理 > 服务 默认角色：部署管理员 查看服务列表 点击 部署管理 ，点击 服务 ，查看服务列表。 查看服务版本列表 点击详情。 查看该服务历史版本信息。 查看部署文件 点击查看部署文件，查看部署文件信息。 服务部署 在服务列表中找到要部署的服务，点击详情，例如webservice0131。 选择要发布的版本，点击部署服务。 进行资源选择和变量填写，点击部署。 查看运行中的服务 点击详情。 可在运行中查看正在部署/运行的版本，以及对容器数量进行调整。 点击详情，查看服务部署阶段和详情信息。 注：不同服务类型，部署阶段不同。 查看容器组列表 点击容器组页签，查看容器组列表。 查看容器组日志 点击容器组日志进行相关日志查看。 灰度部署 灰度部署是用于保障系统稳定，验证某服务版本是否正常使用的保险措施。验证正常后再转为正式部署。 注：目前支持Web前端、普通应用类型的服务使用自动生成域名的方式进行灰度部署；支持微服务类型的服务使用选择不同用户组的方式进行灰度部署。 在服务列表中找到要部署的服务，点击 详情 ，例如webservice0131。 选择要灰度部署的版本，点击 部署服务 。 进行资源选择和变量填写，勾选灰度发布，选择用户组，如devops，点击 部署 。 可在运行中查看该版本正在进行灰度部署。 自动部署 开发/测试环境通常为了保证系统部署的版本是最新的，会设置自动部署，即一旦有新的服务版本发布到本环境，则系统帮助我们自动部署新的服务版本。 部署管理员可以设置“自动部署”。 版本发布到运行区将会自动部署。 注：自动部署仅针对于正式部署。 查看服务运行历史 点击 运行历史 ，查看部署失败或部署停止的服务版本。 "},"/zh/docs/user-guide/continuous-integration":{"url":"zh/docs/user-guide/continuous-integration","title":"持续集成","description":"","language":"zh","body":"持续集成 持续集成（Continuous Integration，简称CI）是指开发过程中不断集成团队成员的代码，每次集成都可以通过自动化构建来实现，因此为开发人员节省大量的时间，让他们能更专注于实现业务逻辑。 本页面介绍了研发团队在完成敏捷管理后进行产品开发时，如何管理服务、如何使用Git-Flow模型进行分支管理、如何查看持续集成流水线、如何管理服务版本、如何了解代码质量及如何进行服务发布。 持续集成基本由敏捷开发团队所有成员完成，包括项目所有者、源代码管理员、项目成员。每个模块都包含其概念定义、主要功能及其他注意事项。 若您遇到无法访问对应功能，请联系对应负责人进行系统配置，特别是角色分配。 若您完成代码开发及发布，可继续了解如何进行持续部署。 服务管理 服务是一部分功能的集合。一个系统可以被解耦成很多服务。每一个微服务都可以独立部署，每一个微服务仅关注于完成一部分任务，每部分任务代表一个小的业务模块，因此各服务之间关系是松耦合的。另外，每创建一个服务，系统会自动在gitlab创建好对应的group、默认分支及issue代码库。 只有该项目的项目所有者和源代码管理员才能创建服务，项目成员仅能查看服务。 菜单层次：项目层 菜单路径：开发管理 > 服务 默认角色：项目所有者、源代码管理员、项目成员 服务类型 微服务：微服务后端，可以定义依赖的资源和服务，部署时需配置网关。 Web前端：微服务前端，部署时需配置域名。 移动：移动端应用开发使用，部署流程与其他类型不同。 普通应用：非微服务架构的服务类型，如HAP、HBI等，一个系统一个服务。 Java库：管理Java工具包。 服务组 服务组是用于区分服务的开发来源，因此创建服务时比填写此标识。 可参考如下设置。 项目名称 项目编码 服务组 HAPCloud hapcloud com.hand.hapcloud DevOps devops com.hand.devops 智能洞察 insight com.hand.insight 敏捷看板 kanban com.hand.kanban 移动应用 mobile com.hand.mobile 应用框架 hap com.hand.hap 云维开发 cloopm com.hand.cloopm 新建服务 点击 创建 按钮。 输入 “服务编码” 、 “服务名称” 、以及 “服务组” ，并选择相应服务类型，点击 创建 按钮。 新建服务 “微服务0201” 已在服务管理列表中。 gitlab已自动创建好对应服务类型的代码库 “webservice” 。点击 仓库地址 ，可以查看该服务在gitlab的代码仓库。 停用/启用服务 点击 停用，如： “微服务0201” 已停用，服务详情不可查看。 点击 启用 ，如： “微服务0201” 已启用，可对该服务进行相关操作。 分支管理 Choerodonc采用 git-flow 工作流模式，有master和develop两个默认分支。在持续交付过程中对 feature、release、hotfix 等分支进行管理。结束分支可自动触发分支合并和持续集成，可在流水线查看代码集成情况。 菜单层次：项目层 菜单路径：开发管理 > 服务 > 服务详情 默认角色：项目所有者、源代码管理员、项目成员 分支类型 Master：默认分支，版本发布分支。 Develop：默认分支，日常开发分支。 Feature：适用于日常开发、bug修复，基于开发分支生成，完成时合并至开发分支。 Release：适用于产品发布、产品迭代，基于开发分支生成，完成时合并至主分支和开发分支，并打上标签。 Hotfix：适用于产品发布后修复bug，基于主分支生成，完成时先合并至主分支和开发分支，并打上标签。 分支使用流程 分支使用流程包括四个部分：新建分支、拉下分支至本地开发、开发完提交代码/解决冲突、结束分支。 新建分支 点击创建Feature/创建Release/创建Hotfix按钮，创建对应分支。 输入Issue编码或版本号。点击保存按钮。 Feature/Hotfix 分支创建时输入Issue编码作为分支名。 Release 分支创建时会自动生成下一个版本号，也可以手动输入需要的版本号。（版本号由三个数字组成，中间以小数点间隔。如：1.1.0。Release 版本号默认为末位清零，中间一位进一）。 结束分支 feature 分支在结束时会合并生成对应的服务版本，版本号与创建时填写一致。 Release 分支在结束时会生成对应的服务版本，版本号与创建时填写一致。 Hotfix 分支在结束时会提示以最新版本的第三位加一作为版本号。如最新版本为1.1.5，则hotfix分支结束时生成新版本为1.1.6。 注：无提交时点击结束分支，将不创建合并请求，直接删除。 另外，新建分支及结束分支只能在平台界面进行操作，请勿随意在gitlab界面创建合并请求和删除分支。 示例：分支管理操作步骤 克隆代码到本地 # 在存放代码的文件夹下执行以下命令，拉取所需服务的代码仓库 git clone http://git.saas.hand-china.com/devops/hap-devops-service.git # 拉取远程仓库成功后进入仓库 cd hap-devops-service 拉取最新代码和新建的分支 git pull 切换到分支 # 切换到新建分支，以 feature-2 为例 git checkout feature-2 开发 根据分支对应的 Issue 需求修改代码。完成后详细检查本地代码改动。 提交代码 # 将本地代码变动提交到暂存区 git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-2:feature-2 界面操作结束分支 解决分支冲突 Feature 分支冲突 常见两种解决冲突的方式如下 本地修改代码解决： # 确保当前正在 Feature 分支上，以 feature-2 为例 git checkout feature-2 # 拉取最新远程仓库 develop 分支代码 git fetch origin develop:develop # 将 Feature 分支重新设立起点于最新的 develop 代码 git rebase develop 执行完 rebase 操作后，会产生对应的冲突，解决冲突后执行如下代码。 git add . git rebase --continue 根据本次 Feature 分支上提交次数的不同，解决冲突可能会重复多次，只需要重复执行上述解决冲突操作。 完成后强制提交至远程仓库。 git push -f origin feature-2:feature-2 界面解决冲突（不建议）： 在gitLab对应的合并请求界面点击 Solve conficts 按钮。 Release&Hotfix 分支冲突 当分支对于 develop 和 master 分支中任意一个或以上存在冲突时，会提示当前存在冲突及建议做法。 若此时继续点击确定按钮，并且没有解决冲突，那么会提示分支冲突，无法继续操作。 解决冲突具体步骤可查看界面提示，说明如下： 只有对应 develop 的合并请求存在冲突，按界面提示解决冲突会导致分支对应 develop 分支的合并请求被合并。此时再进行结束分支操作，会处理分支对 master 的合并请求，然后生成对应版本号的 Tag 并删除分支。 只有对应 master 的合并请求存在冲突，按界面提示解决冲突会导致分支对应 master 分支的合并请求被合并。此时再进行结束分支操作，会处理分支对 develop 的合并请求，然后生成对应版本号的 Tag 并删除分支。 若分支对应 develop 和 master 分支的合并请求都存在冲突，按界面提示解决冲突会导致分支对应 develop 和 master 分支的合并请求依次都被合并。此时再进行结束分支操作，会生成对应版本号的 Tag 并删除分支。 流水线 流水线是持续集成过程中完成情况，包括状态、标识、创建者、提交、分支、提交者、阶段、时长及创建时间。 菜单层次：项目层 菜单路径：开发管理 > 服务> 服务详情 > 流水线 默认角色：项目所有者、源代码管理员、项目成员 查看流水线信息 进入服务详情后，点击 流水线 页签。 查看服务CI pipeline的完成情况。 注：版本命名方式：合并至develop：develop. + 年月日时分秒。 Tag生成：版本号（三位号码，如：1.1.0。release修改前两位，hotfix修改第三位）。 提交：每次提交代码的操作，自动生成Commit ID，由于字数多，平时多取前八位。 服务版本 服务版本是代码提交的历史记录，每提交一次修改后的代码，对应生成一个新的版本。 菜单层次：项目层 菜单路径：开发管理 > 服务> 服务详情 > 服务版本 默认角色：项目所有者、源代码管理员、项目成员 查看服务版本信息 进入服务详情后，点击 服务版本 页签。 查看服务版本信息。 代码质量 代码质量是直观地向用户反馈代码质量信息。按照相应的代码规范及标准在线进行代码静态检查、代码安全检查、质量评分、代码缺陷改进趋势分析，辅助管控代码质量。 菜单层次：项目层 菜单路径：开发管理 > 服务 > 服务详情 > 代码质量 默认角色：项目所有者、源代码管理员、项目成员 注：在此只看该服务下经单元测试后的代码质量情况。可从开发监控了解项目整体及DevOps全链路各个环节进展情况，包括所有服务的代码质量。 服务发布 该模块提供将服务发布至不同环境的功能，向目标环境传输部署文件，同时附带服务版本信息以便追踪。 菜单层次：项目层 菜单路径：开发管理 > 发布 默认角色：项目所有者、源代码管理员、项目成员 服务发布 点击 发布 。 关键字搜索或直接从从下拉列表中选择部署文件发布的环境。 点击 保存 。 该服务部署文件已成功发布在开发或正式环境。 自动发布 自动发布是提供便捷的发布功能。尤其对于开发/测试环境，需频繁的发布服务版本，则建议项目所有者对这些环境配置自动发布。若该服务设置自动发布后，每当持续集成生成新的服务版本后将会自动发布至对应的环境。 菜单层次：项目层 菜单路径：开发管理 > 服务 > 服务详情 默认角色：项目所有者 项目所有者可以勾选“是否自动发布” 。 在弹框中选择一个或多个环境。 点击 保存 ，版本生成会自动发布部署文件至所选环境。 注：建议自动发布仅配置使用于开发/测试环境，而正式环境建议在UAT环境测试通过后进行手动发布。 "},"/zh/docs/user-guide/iam/Site2_organization":{"url":"zh/docs/user-guide/iam/Site2_organization","title":"组织管理","language":"zh","body":"组织 组织是项目的集合。组织管理是对组织信息和启用状态的管理。组织下的项目、用户、客户端的管理需进入到一个特定的组织进行组织层的操作。一个项目只能属于一个组织，一个组织下可以有多个项目。一个用户只能属于一个组织。 功能： 组织列表 组织查询 创建组织 编辑组织 启用/停用组织 组织列表 列表字段： 组织名称：组织的名称。 组织编码：组织编码具有唯一性，是组织的标识。 启用状态：启用状态有启用和停用两种。当启用状态为启用时，组织正常运行，可进入该组织中进行其他操作；当启用状态为停用时，无法进入该组织。创建成功一个新组织后，新组织的启用状态默认为启用。 组织查询 可查询字段： 组织名称：组织的名称。 组织编码：组织编码具有唯一性，是组织的标识。 启用状态：启用状态有启用和停用两种。当启用状态为启用时，组织正常运行，可进入该组织中进行其他操作；当启用状态为停用时，无法进入该组织。创建成功一个新组织后，新组织的启用状态默认为启用。 创建组织 必填字段： 组织名称：组织的名称。该字段是必输的。 组织编码：组织编码具有唯一性，是组织的标识。该字段是必输的 编码只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头 编辑组织 组织创建成功后，组织编码不可更改。 可编辑字段： 组织名称：组织的名称。该字段是必输的 启用/停用组织 停用组织：组织的启用状态为启用时，可进行停用组织的操作。停用组织后，组织的启用状态变为停用，不可进入该组织。 启用组织：组织的启用状态为停用时，可进行启用组织的操作。启用组织后，组织的启用状态变为启用，可进入该组织进行组织的用户管理、项目管理等操作。 "},"/zh/docs/user-guide/iam/":{"url":"zh/docs/user-guide/iam/","title":"IAM和管理","description":"","language":"zh","body":"介绍 本节介绍IAM (Identity & Access Management)身份和访问 管理的基础概念。 HAP Cloud支持IAM，即管理谁（identity）对哪个资源有什么访问权限（role）。 使用IAM，你能允许对特定HAP Cloud资源的访问，并且阻止对其他资源的不必要的访问。 与身份有关的概念 在IAM，你能对成员（member）授予访问权限。成员可以是以下类型： 用户（user） 客户端（client） 用户 用户，代表一个独立的个体。在这里，用户是指在HAP Cloud有身份认证的任何人，如游客、匿名用户不包括在用户里面。 用户有唯一的标识-用户名；因此用户名一旦创建，不可更改。 用户可以绑定邮箱、手机号。 用户的登录为登陆账号（用户名/邮箱/手机号）密码方式登录。 客户端 提供服务的一方我们称为 服务端（Server），而接受服务的另一方我们称作客户端（Client）。 与访问管理相关的概念 当一个已认证的成员要发送一个请求时，IAM会对这个成员是否能在资源进行操作做出授权决定。这里将介绍授权过程中要涉及到的实体和概念。 权限 权限决定了在资源上允许的操作。 在HAP Cloud中，权限以..的形式显示。例如hap-user-service.groups.query。 目前，权限1：1对应到API资源上，一条API资源就是一个权限。 角色 角色是权限的集合。你不能直接给成员分配权限，而是要授予角色。当你给成员授予一个角色时，也就是将角色里包含的所有权限授予了成员。 在IAM中，有三种角色： 原始角色：在HAP Cloud系统中一直可用的角色为Admin、Viewer。 预定义角色：预定义角色比原始角色的粒度细，可对更细粒度的访问进行控制。例如，源代码管理员（role/hap-devops-service.sourceCodeAdmin）是对environment、git-flow、devops-service、service-release这些资源进行访问授权。 用户自定义角色：如果原始角色、预定义角色不能满足需求时，用户可根据自身需求创建自定义角色，给该角色添加特定的权限组合。 有关细颗粒度预定义角色的更多信息请参考理解角色。有关用户自定义角色的更多信息请参考理解用户自定义角色和创建与管理用户自定义角色。 角色分配 你可以授予用户角色通过在角色分配管理中添加用户与角色的关联关系，即定义谁有什么样的访问权限的一组关联。 IAM的核心就是角色分配，用member_role对象表示。一个IAMmember_role对象由关联列表组成。一个关联是将成员列表和角色关联在一起。 角色是你想分配给成员的角色。角色有唯一的标识-角色编码。角色编码的指定形式为role/。如，role/hap-kanban-service.kanbanMember（看板项目成员），role/devops-deploy-service.deploymentAdmin（部署管理员）。 成员包含一个列表，这个列表可以是一个或多个身份，参考上面提到的与身份有关的概念部分。 角色分配分层 角色分配是按层次划分的。一共分3层：Site（全局）层、Org（组织)层、Project（项目）层。角色也有分层，一共分3层：Site（全局）层、Org（组织)层、Project（项目）层。 在特定层级的角色分配中，只能分配对应层级的角色。 在全局层的角色分配中，只能分配全局层角色，而全局层角色只包含全局层权限，只能访问全局层的资源； 在组织层的角色分配中，只能分配组织层角色，而组织层角色只包含组织层权限，只能访问组织层资源； 在项目层的角色分配中，只能分配项目层的角色，而项目层角色只包含项目层权限，只能访问项目层资源。 在全局层对成员授予全局层角色后，成员有访问全局层资源的权限，能对HAP Cloud系统进行设置，设置将在HAP Cloud系统中的所有组织、项目生效； 在组织层对成员授予组织层角色后，成员有访问组织层资源的权限，对一个组织的关联对象进行设置，设置将在这个组织与属于这个组织的项目生效； 在项目层对成员授予项目层角色后，成员有访问项目层资源的权限，对一个项目进行操作，操作将只在这个项目生效。 功能 关键流程设计及实现 关键技术方案 领域模型 "},"/zh/docs/user-guide/scrum":{"url":"zh/docs/user-guide/scrum","title":"敏捷管理","description":"","language":"zh","body":"敏捷管理 本页面介绍了用户使用敏捷管理时，如何使用用户故事地图、如何使用冲刺、如何使用看板以及如何操作用户故事、任务、缺陷。 故事地图 在开规划会议之前 用户可以按照角色，活动，任务分类来规划roadmap，整理用户故事，记录的用户故事将会被同步到gitlab的issue上，项目干系人可以在issue下放进行评论，对用户故事展开讨论。 菜单层次：项目层 菜单路径：项目 > 敏捷管理 > 故事管理 > 故事地图 默认角色：看板项目所有者、看板项目成员 使用故事地图 添加角色 角色：提出的用户需求是基于哪类角色考虑的。例如敏捷开发有三种角色，po，master和项目开发人员。 点击创建角色鼠标光标会变为加号，当出现加号图标时，用户在角色这一行任意位置单击，即可添加角色。 添加活动 活动:基于某一个角色下，具体的用户场景。 点击创建活动鼠标光标会变为加号，当出现加号图标时，用户在活动这一行任意位置单击，即可添加活动。 添加任务 任务：用户场景的细化。 点击创建任务鼠标光标会变为加号，当出现加号图标时，用户在任务这一行任意位置单击，即可添加任务。 创建发布计划 点击创建发布计划，即可在用户故事地图上面生成对应的发布计划，依次默认命名为发布计划1、发布计划2等，如果想修改发布计划名称或者删除发布计划，点击发布计划名称旁边的三点符号，可进行修改或者删除。处于安全考虑，已经有用户故事的发布计划，需要先删除里面的用户故事，才能删除整个发布计划。 创建卡片 用户故事：具体的需求。 在故事地图界面移动鼠标，见到卡片创建的提示时，点击提示卡中间的文字部分，也可以创建相应的卡片，比如角色，活动，任务，用户故事。 修改与删除卡片 修改卡片直接单击卡片，弹出卡片详情信息时即可修改标题。 删除卡片需要在没有子卡的情况下才能删除，否则提示相应报错信息。 故事地图工具栏介绍 未规划区的使用 点击未规划区，会出现一个侧边栏，如下图所示，在侧边栏中会放入您在其他界面创建的不属于任何发布计划的故事，比如您在用户故事界面创建了一个未选择发布计划的用户故事，就会以一张故事卡的形式出现在此处，顶部的搜索和过滤可以进行高级搜索，找到您想要的卡片，您考虑好此故事放在哪个发布计划下比较合适时，也可以拖动到具体的发布计划下。 数据统计 此项目下的数据进度的分析，可一键从此入口进入，也可去数据洞察界面选择具体项目查看。 导出为图片 点击导出为图片，即可把当前的地图以图片形式保存下来，导出格式为png。 放大缩小 点击放大缩小标志，或者拖动放大缩小的滚动条，都可完成整个地图的放大缩小。 用户故事 用户故事界面是用户故事的列表展现形式，在这里可以集中查看您创建的所有的用户故事，以及其下的任务缺陷等，方便快捷。 菜单层次：项目层 菜单路径：项目 > 敏捷管理 > 故事管理 > 用户故事 默认角色：看板项目所有者、看板项目成员 创建用户故事 点击创建故事，出现详情信息编辑的窗口，在窗口中进行编辑，编辑完成之后点击保存。 搜索用户故事 点击过滤可以进行高级搜索 删除用户故事 未进入冲刺的用户故事可以删除。 快捷创建任务 可以快捷创建用户故事下面的任务。 快捷创建缺陷 可以快捷创建用户故事下面的缺陷。 冲刺 在冲刺中，可方便为您管理一个迭代周期内要完成的故事，并为您进行后台数据监测，可视化故事完成的情况，冲刺作为用户故事地图和看板的衔接环节，开启冲刺之后才能使用看板的全部功能。 菜单层次：项目层 菜单路径：项目 > 敏捷管理 > 冲刺管理 > 冲刺 默认角色：看板项目所有者、看板项目成员 创建冲刺 点击`创建冲刺，选择发布计划，输入冲刺名称，选择预计的冲刺起止时间(不必输)，即可创建一个新的冲刺。 搜索冲刺 可以在工具栏进行搜索。 开启/关闭冲刺 可以快捷开启或者关闭冲刺，完成状态切换。 点击开启冲刺可开启当前冲刺，开启之后，数据洞察就开始记录当前冲刺的数据。冲刺内添加的故事也会自动导入看板中，并放在第一列。 点击关闭冲刺可关闭当前冲刺，关闭之后不能再开启。 编辑冲刺信息 可以修改冲刺的具体信息，如冲刺名称，开始和结束时间，但是发布计划不允许修改。 添加故事 选择故事来源，从故事地图，或者未规划的故事中，勾选需要导入的故事，点击确定，添加到冲刺中，添加进冲刺的故事，在故事地图界面的颜色会与没有导入冲刺的颜色有一个变化。 创建任务 可以创建进入到冲刺中的用户故事下的具体任务。 创建缺陷 可以创建用户故事下或者任务下测试出现的bug。 筛选故事 可以对故事，任务和缺陷进行分类筛选。 移除故事 可以把导入冲刺的故事移除，移除后不会在故事地图里面删除，只是故事地图中的卡片颜色会变为未导入状态。也可以导入到其他冲刺中。 看板 开启冲刺之后才能使用看板的全部功能。看板可以取代物理看板，也可以可视化您的工作流，同时后台会记录所以操作的时间数据，帮您完成数据分析和记录工作。 菜单层次：项目层。 菜单路径：项目>敏捷管理>冲刺管理>看板。 默认角色：看板项目所有者、看板项目成员 选择模板 进入看板之后，先根据您的需要，选择一个看板模板，单击某个模板，可查看详情，双击就会为您选择当前模板并打开，看板界面没有卡片时，您也可以更换模板。 开启冲刺后看板展示 进入看板之后，您在当前开启的冲刺中添加的故事，会自动为您导入到当前看板，并放在SprintBacklog里面（第一列） 创建卡片 点击创建卡片，出现卡片详情编辑的窗口，选择卡片类型，故事，任务，缺陷，可创建对应类型的卡片，创建的卡片会同步到故事地图界面，放在当前发布计划的第一个角色的第一个任务列里。 看板绘制 点击看板绘制进入看板编辑界面： 1)增加列 2)绘制泳道 3)增加/减少列高 4)撤销/恢复 5)保存 6)在制品和起始列设置 拖动故事卡 点击故事卡，可按需在子卡处拖动任务卡或bug卡至看板对应位置。 任务 可以查看您创建的所有任务，可视化您的任务流，同时后台会记录所以操作的时间数据，帮您完成数据分析和记录工作。 菜单层次：项目层。 菜单路径：项目 > 敏捷管理 > 任务和漏洞 > 任务。 默认角色：看板项目所有者、看板项目成员 查看任务 在任务界面，您可以查看您所有创建的任务，并且可以高级搜索您要找的任务。 删除任务 可以在中完成删除，快捷创建缺陷的快捷操作 漏洞 可以查看您创建的所有漏洞。 菜单层次：项目层。 菜单路径：项目>敏捷管理>任务和漏洞>漏洞。 默认角色：看板项目所有者、看板项目成员 查看缺陷 在任务界面，您可以查看您所有创建的缺陷，并且可以高级搜索您要找的缺陷。 删除缺陷 可以在中完成删除缺陷。 "},"/zh/docs/user-guide/system-configuration":{"url":"zh/docs/user-guide/system-configuration","title":"系统配置","description":"","language":"zh","body":"系统配置 本页面介绍了用户使用系统功能前需要进行的系统配置，以便不同用户可以进行敏捷管理、持续集成、持续部署等操作。该系统配置基本由平台管理员、项目创建者、项目所有者等高权限角色完成。每个模块都包含其概念定义、主要功能及其他注意事项。 角色管理 角色是一组权限的集合。当用户进行某些操作时，系统会检查该用户拥有的角色里是否具有对应的操作权限，因此需要根据实际系统使用情况设置角色。给用户分配角色后，用户即拥有对应的操作权限。该模块将详细介绍如何管理角色。 菜单层次：全局层 菜单路径：管理 > 角色 默认角色：平台管理员 创建角色 点击 创建 ，输入 “角色名” ， “角色编码” ，设置是否可编辑以及是否启用。 点击 添加权限，勾选所需相应权限，点击 确定 ，进行创建角色。 编辑角色权限配置 针对已存在的角色，点击 编辑 ，或者从详情界面点击 编辑 。 点击 添加权限，对角色相关信息进行修改，以及权限进行修改 。 点击 确定，添加或删除一个或多个权限 。 停用/启用角色 点击 停用 ，该角色将不可分配给用户。 点击 启用 ，该角色正常使用，可以分配给相应用户。 角色权限添加说明 注：下表为系统使用前需手动添加的角色权限列表 角色名称 权限名称 权限描述 权限层级 项目创建者 hap-user-service.password-policy.queryOrganization 查询目标组织密码策略 organization 项目创建者 hap-devops-service.environment.listEnvironment 查询全部环境信息 organization 项目创建者 hap-devops-service.environment.createEnvironment 创建环境 organization 项目创建者 hap-devops-service.environment.checkEnvironmentByName 检查环境名是否可用 organization 项目创建者 hap-devops-service.environment.listEnvironmentByPageSize 分页查询环境信息 organization 项目创建者 hap-devops-service.environment.getEnvironmentByEnvironmentId 环境管理详情 organization 项目创建者 hap-devops-service.environment.updateEnvironment 更新环境 organization 项目创建者 hap-devops-service.environment.deleteEnvironmentByEnvironmentId 删除环境 organization 项目创建者 hap-devops-service.project.checkProject 校验项目code name是否重复 organization 项目创建者 hap-user-service.project.select 分页查询项目 organization 项目创建者 hap-user-service.project.create 添加项目，organization id不需要，强制当前用户所属organization organization 项目创建者 hap-user-service.project.checkProjectCode checkProjectCode organization 项目创建者 hap-user-service.project.queryOrganizationProject 根据组织id查询项目 organization 项目创建者 hap-user-service.user.select 分页查询 organization 项目创建者 hap-user-service.user.create 新增用户 organization 项目创建者 hap-user-service.user.query 通过用户id查询用户 organization 项目创建者 hap-user-service.user.updateUser 根据id修改用户 organization 项目创建者 hap-user-service.organization.query 根据组织id查询组织 organization 项目创建者 hap-user-service.role.selectOrganizationRole 查询可分配组织角色列表 organization 项目创建者 hap-user-service.project.update 根据id修改项目信息，只能修改自己组织项目 organization 项目所有者 hap-user-service.project.query 按照Id查询项目，只能查询自己组织项目 project 项目所有者 hap-user-service.member-role-project.select 查询项目成员角色 project 项目所有者 hap-user-service.member-role-project.create 项目层新增成员角色 project 项目所有者 hap-user-service.member-role-project.update 更新项目层成员角色 project 项目所有者 hap-user-service.member-role-project.createSingle 项目层新增成员角色 project 项目所有者 hap-user-service.member-role-project.delete 删除项目层成员角色 project 项目所有者 hap-user-service.role.selectProjectRole 查询可分配项目角色列表 project 项目所有者 hap-user-service.role.selectProjectRoleGroupByService 查询可分配项目角色列表（查询结果以服务分组） project 源代码管理员 hap-user-service.project.query 按照Id查询项目，只能查询自己组织项目 project 项目成员 hap-user-service.project.query 按照Id查询项目，只能查询自己组织项目 project 看板所有者 hap-user-service.project.query 按照Id查询项目，只能查询自己组织项目 project 看板成员 hap-user-service.project.query 按照Id查询项目，只能查询自己组织项目 project 开发监控 hap-user-service.project.query 按照Id查询项目，只能查询自己组织项目 project 部署管理员 hap-user-service.groups.select 查询Group organization 部署管理员 hap-user-service.groups.create 创建Group organization 部署管理员 hap-user-service.groups.query 查询Group organization 部署管理员 hap-user-service.groups.update 更新Group organization 部署管理员 hap-user-service.groups.delete 删除Group organization 部署管理员 hap-user-service.user-groups.insertUserGroups 创建userGroups organization 部署管理员 hap-user-service.user-groups.delete 删除userGroups organization 用户管理 该模块提供用户管理功能，可以新建用户，进行用户信息维护等。用户也可由其他系统批量导入。 菜单层次：组织层 菜单路径：IAM > 用户管理 默认角色：平台管理员、项目创建者 新建用户 点击创建按钮。 输入用户相关信息，点击创建按钮，完成创建。 新建的用户“张三”在用户列表中显示，gitlab自动生成同样的用户“张三”。 查看用户详情 点击详情，进入用户详情界面。 查看所需信息。 编辑用户信息 点击编辑，进入用户编辑界面。或如上一条示例从用户详情界面点击编辑按钮，进入用户编辑界面。 对用户信息进行修改，点击保存按钮，用户信息修改完成。 删除用户 点击删除。 再次点击删除按钮，用户删除成功。 角色分配 角色分配是面向平台管理员、项目所有者提供的权限管理，可以在组织或项目内添加成员，为其分配适当的角色，也可以调整现有成员的角色，从而使这些成员可以有适当的权限使用对应的资源。注意：需选择对应的组织或项目后再进入角色分配，其角色控制范围不同。 菜单层次：组织层/项目层 菜单路径：IAM > 角色分配 默认角色：平台管理员、项目所有者 添加角色 若需要分配的用户不在该组织/项目中，点击 添加 按钮进行角色添加。 例如：当用户“25777”不属于“演示项目0131”项目时，点击添加，输入用户名，为该用户分配角色权限。 若用户存在于成员角色管理列表中，无需点击 添加 ，点击 ▼ ，选择一个或多个角色进行分配。 例如，创建用户完成后，平台会自动分配 “组织查看者” 的角色，该用户存在于成员角色管理列表中，直接进行角色分配，点击 保存 按钮，完成角色修改。 小tips：找不到用户怎么办？直接在搜索框内输入用户名或昵称，回车一下即可显示搜索结果。 注：角色权限列表 下表为目前平台使用的常见角色及对应功能 角色 | 权限 | 层级 --- | --- | --- 平台管理员 | 菜单管理、角色管理、用户管理（初始化导入）、角色分配（组织层）及除服务发布之外所有功能 | 系统层/组织层/项目层 项目创建者 | 用户管理、项目管理、环境管理、用户组管理 | 组织层 部署管理员 | 资源管理、网关管理、域名管理、服务管理、服务部署、部署详情（阶段及日志）、设置自动部署 | 组织层 项目所有者 | 角色分配（所在项目下）服务创建、服务详情查看、分支管理、服务版本、代码质量查看、服务发布、设置自动发布 | 项目层 源代码管理员 | 服务创建、服务详情查看、分支管理、服务版本、代码质量查看、服务发布 | 项目层 项目成员 | 服务详情查看、分支管理、服务版本、代码质量查看、服务发布 | 项目层 看板项目所有者 | 故事管理、冲刺管理、任务和缺陷 | 项目层 看板项目成员 | 故事管理、冲刺管理、任务和缺陷 | 项目层 开发监控查看者 | 全流程信息监控查看 | 项目层 删除角色 点击 删除 。 点击 删除 ，用户从该组织/项目移除成功。 项目管理 根据企业产品研发情况拆分团队，建议采用敏捷项目管理团队为一个项目单位，项目管理可以提供项目创建、项目查询、项目编辑等功能。 菜单层次：组织层 菜单路径：IAM > 项目。 默认角色：平台管理员、项目所有者 新建项目 点击 创建 按钮。 输入 “项目编码” 和 “项目名称” ，点击 创建 按钮。 新建项目 “演示0131” 已在项目管理列表中， gitlab自动对应生成group “演示0131” 。 编辑项目信息 点击 编辑 ，进入项目编辑界面。 对 “项目名称” 进行修改，点击 保存 按钮。 禁用/启用项目 点击 禁用 ，项目禁用后，该项目下的其他操作将无法进行。 点击启用，启用后，该项目恢复正常使用。 环境管理 环境管理是面向平台管理员、项目创建者和项目所有者根据不同用途配置相对应的环境信息。可以创建环境，删除环境，及对环境详情信息进行编辑修改。 平台管理员 、项目创建者可以从组织层管理某组织的环境信息，这些环境会继承到该组织下的所有项目；项目所有者可以从项目层管理某项目的环境信息，由项目层创建的这些环境也会显示在对应的组织层；源代码管理员、项目成员仅可以从项目层查看该项目可用的环境列表（包括该项目上创建的及由组织上继承的）。 常见环境包含：测试环境，UAT环境及正式环境等。 菜单层次：组织层/项目层 菜单路径：开发管理 > 环境 默认角色：平台管理员、项目创建者、项目所有者、源代码管理员、项目成员 创建环境 点击 创建 按钮。 输入 “环境名称” 、 “环境地址” 以及 “环境密钥” ，点击 测试连接 ，若环境地址、秘钥配置正确，会提示“连接成功”；若看到提示信息为“连接失败”，请修改为正确的环境地址或秘钥，点击 创建 按钮。 编辑环境信息 点击 编辑 ，进入环境编辑界面。 对环境信息进行修改，如环境名称，点击 保存 按钮，修改完成。 “环境名称” 修改完成。 停用/启用环境 点击 停用 。环境 “Charlietest” 已停用，停用后，该环境将不可使用。 点击 启用 。环境 “Charlietest” 已启用，启用后，该环境可正常使用。 环境删除 点击 删除 。 再次确认，点击 删除 。 用户组管理 用户组是将不同群体的用户进行分类组合，主要用于灰度部署时选择个别用户组进行测试验证。用户组管理包括创建、编辑、删除用户组及管理该用户组的用户。 菜单层次：组织层 菜单路径：用户管理 > 用户组 默认角色：平台管理员、部署管理员 创建用户组 点击 创建 ，输入 “用户组编码” ， “用户组名” ，“用户组描述” ，点击 创建 ，用户组创建完成。 编辑用户组 点击 编辑 。 修改用户组信息，点击 编辑 。 管理用户组用户 点击 添加用户 。 点击 添加 ，勾选需要添加到该用户组的用户。如需删除用户则取消勾选即可。 删除用户组 点击 删除 ，删除当前用户组。 "}}