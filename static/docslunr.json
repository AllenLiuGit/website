{"/docs/":{"url":"docs/","title":"文档","description":"","body":"欢迎使用 Choerodon 文档 Choerodon 猪齿鱼是一个开源企业服务平台，是基于 Kubernetes 的容器编排和管理能力，整合 DevOps 工具链、微服务和移动应用框架，来帮助企业实现敏捷化的应用交付和自动化的运营管理，并提供 IoT 、支付、数据、智能洞察、企业应用市场等业务组件，来帮助企业聚焦于业务，加速数字化转型。 Choerodon 提供一整套支撑 DevOps 最佳实践的工具链，从计划、编程、构建、测试、发布与运营等支撑敏捷管理；并且还提供了一套基于 Spring Cloud 微服务应用框架，以帮助企业更加快捷高效的进行微服务开发。Choerodon 文档将从Choerodon相关概念，DevOps 工具链 和 应用开发 等方面详细介绍 Choerodon 作为DevOps支撑平台的架构、安装、配置、部署，以及如何使用等，以及 Choerodon 微服务应用框架的开发、部署等。 了解和学习 Choerodon 的概念和安装 概念 01 - Choerodon是什么 02 - 系统架构 03 - 使用的开源组件 更多 04 - 开发区与运行区 05 - 组织层次 06 - 安全 折叠 安装与配置 01 - 概述 02 - 安装开发区 03 - 安装运行区 更多 04 - 安装其他组件 05 - 迁移 06 - .deploy.yml文件说明 07 - .gitlab-ci.yml文件说明 08 - Dockerfile文件说明--> 折叠 了解和学习 Choerodon 的 DevOps 工具链 Choerodon 提供一整套 DevOps 的最佳实践，从计划、编程、构建、测试、发布与运营等。 快速入门 01 - 开发一个微服务前端 02 - 开发一个微服务后端 03 - 开发一个Web应用 更多 04 - 开发一个移动应用 05 - 从用户故事到运营监控 折叠 功能说明 01 - 系统配置 02 - 敏捷管理 03 - 持续集成 更多 04 - 持续部署 05 - 洞察监控 折叠 了解和学习 Choerodon 的开发应用 Choerodon 微服务应用框架是基于多年企业应用服务的经验，面向微服务架构思想和分布式应用架构研发的分布式应用开发平台，以满足应用微服务化和混合云IT架构分布式应用的开发。 快速入门 01 - 开发一个微服务前端 02 - 开发一个微服务后端 开发手册 01 - 后端开发 02 - 前端开发 03 - 后端环境部署 04 - 前端项目部署 最佳实践 01 - 开发规范 02 - 命名规范 03 - 测试 "},"/docs/concept/":{"url":"docs/concept/","title":"概念","description":"","body":"概念 介绍Choerodon相关概念。Choerodon的用户可以通过此章节了解Choerodon的作用、系统架构、使用了哪些开源组件以及系统的组织层次和安全设计等，对Choerodon的有一个全貌的了解。 Choerodon 是什么 说明Choerodon的设计和开发的目的、特点，以及它能够解决的问题和给用户带来哪些价值等。 系统架构 描述Choerodon的微服务系统架构，以及一般性企业系统架构的演进历程。 使用的开源组件 描述Choerodon使用到的开源工具集或者产品。分为两部分，其一是微服务应用框架使用的开源工具集或者产品，其二是DevOps业务流程使用的工具集。 开发区与运行区 介绍说明Choerodon开发区和运行区的概念，涉及到的服务，以及对应的系统部署方式。 组织层次 介绍说明Choerodon采用全局、组织和项目三个层次来组织系统资源。 安全 描述说明Choerodon的认证体系和权限控制。 "},"/docs/concept/choerodon-concept":{"url":"docs/concept/choerodon-concept","title":"Choerodon 是什么?","description":"","body":"Choerodon 是什么？ 企业级数字化服务平台 Choerodon猪齿鱼是一个开源企业服务平台，是基于Kubernetes的容器编排和管理能力，整合DevOps工具链、微服务和移动应用框架，来帮助企业实现敏捷化的应用交付和自动化的运营管理，并提供IoT、支付、数据、智能洞察、企业应用市场等业务组件，来帮助企业聚焦于业务，加速数字化转型。 Choerodon使用Kubernetes来管理和部署服务。关于Kubernetes，请参考Kubernetes 概览。 同时，Choerodon使用Spring Cloud作为微服务分布式系统，并且Choerodon还使用Spring Boot进行了通用性模块的封装，例如组织管理、用户管理、权限管理等；前端使用React作为开发组件。关于Choerodon的开发请参考 Cloud Framework 开发。 有关Choerodon组件的详细概念信息，请参阅我们的其他概念指南。 为什么要使用 Choerodon ？ Choerodon解决了开发人员和运维人员面临的许多挑战。随着企业或者组织业务模式不断的互联网化，尤其是对于一些有软件研发能力的公司或者组织，如何有效的应对开发和运维之间的关系，提高IT部门的总体运作效率，以支撑业务的快速发展，已成为了我们面临的重大挑战。 同时，现代企业或者组织对于软件系统的需求，也在随着互联网和大数据等新技术的进步在悄然发生变化，尤其是在数字化转型的思潮中，企业或者组织要求： 零宕机 部署松耦合的组件，通过冗余来避免故障，零停机的情况下完成升级 极短反馈周期 经常发布代码，缩短反馈回路，降低风险 移动和多设备 充分利用移动设备，用户能够在多种设备使用，系统能够适应扩展的需求 设备互联 互联网连接的设备导致数据量剧增和要求“边缘”的计算能力，需要新的软件设计和实践 数据驱动 使用数据，通过更智能的应用向客户提供极致的体验和更高的价值 Choerodon可以有效的帮助企业或者组织提升IT效能。Choerodon采用DevOps的原则和流程来管理软件的开发和运维。Choerodon可以有效提高软件交付的质量（比如，提高可用性，提高变更成功率，减少故障，等等），加快产品推向市场（比如，缩短开发周期时间和更高的部署频率），并且提高组织的有效性（比如，将时间花在价值增加活动中，减少浪费，同时交付更多的价值至客户手中）。 Choerodon是将服务和应用构建在Kubernetes上，后端服务使用Spring Boot开发，前端使用React开发。Choerodon分为两类环境，即应用PaaS环境和产品PaaS环境，应用PaaS环境为主要软件开发区，包括应用构建、敏捷管理、开发管理和持续发布管理等核心功能；产品PaaS环境主要软件运行区，包括测试环境、用户集成测试环境、正式环境等，用户可以根据自身需求定义。 以下是对Choerodon关键特性说明： 应用构建 我们可以方便的通过Choerodon开发构建微服务、Web前端、移动、普通应用和Java库。 敏捷管理 Choerodon采用Scrum来管理需求和计划执行，包括用户故事地图，ISSUE管理，冲刺管理和电子看板。 开发管理 Choerodon使用gitlab管理代码，包括代码托管、分支管理（Gitflow分支模型），根据服务类型提供持续集成的流水线模板，开发人员也可以根据需要进行定制化修改，以及代码质量管理等。 持续发布管理 在应用PaaS环境，Choerodon通过Gitlab CI/CD产生软件应用的版本，例如2.0.3，Choerodon将2.0.3发布到生产PaaS环境，然后在生产PaaS环境部署应用版本，同时也可以进行灰度发布。 运营管理 Choerodon提供一整套完整的监控工具来监控PaaS平台，监控主要包含开发类指标、日志和微服务调用链三类信息。 "},"/docs/concept/choerodon-development-deployment":{"url":"docs/concept/choerodon-development-deployment","title":"开发区与运行区","description":"","body":"开发区与运行区 Choerodon 采用微服务架构融合多个开源组件实现 DevOps的开发相关功能，包括计划、编码、构建、测试、部署、运行、运维等，并且Choerodon是以Docker容器作为运行环境和使用Kubernetes作为容器编排和管理工具，在一个Kubernetes集群中运行DevOps流程的开发相关（计划、编码、构建、测试）微服务和开源工具，我们将此Kubernetes集群称作开发区；在一个Kubernetes集群中运行DevOps流程的运行相关（部署、运行、运维）微服务和开源工具，我们将此Kubernetes集群称作运行区。 关于开发区的安装，请参考开发区安装。 关于运行区的安装，请参考运行区安装。 部署 Choerodon 可以有两种不同的部署方式，用户可以选择单集群部署，将开发和运行相关服务部署到一个Kubernetes集群上，也可以将开发区和运行区的服务分别部署到不同的Kubernetes集群上。 一个Kubernetes集群如果仅部署开发区相关的服务，则可作为DevOps开发端使用，如果仅部署运行区相关服务，则可作为DevOps运行端使用，如果既部署开发区相关服务和组件，又部署运行区相关服务和组件，则可以为一个完整的PaaS平台。 单集群部署 单集群部署是将开发区相关的服务和运行区相关的服务部署到一个Kubernetes集群中。用户的开发和应用的部署和运行全部在一个Kubernetes集群中。 多集群部署 多集群部署是将开发区相关的服务和运行区相关的服务分别部署到多个Kubernetes集群中，开发区和运行区集群之间通过http通信。我们可以把多个运行区看做是多套环境，例如测试环境、正式环境等。 开发区相关服务 Choerodon 开发区各服务版本信息如下： 服务名 服务组 服务代码 版本号 K8S消息收集 com.choerodon.devops k8s-informer V0.1.1 Gitlab服务 com.choerodon.devops choerodon-gitlab-service 1.1.0 K8S服务 com.choerodon.devops devops-kubernetes-service 1.1.0 文件服务 com.choerodon.devops choerodon-file-service 1.1.0 开发服务 com.choerodon.devops choerodon-devops-service 1.1.0 部署服务 com.choerodon.devops devops-deploy-service 1.1.6 SonarQube服务 com.choerodon.insight data-sonar-service 1.0.1 数据整合服务 com.choerodon.insight data-intergration-service 1.0.0 数据提供服务 com.choerodon.insight data-provide-service 1.0.1 数据操作服务 com.choerodon.insight data-operation-service 1.0.0 看板服务 com.choerodon.kanban choerodon-kanban-service 1.1.0 移动服务 com.choerodon.mobile mobile-cloud-service 1.0.0 开发前端 com.choerodon.devops devops-front 1.1.3 部署前端 com.choerodon.devops deploy-front 1.1.5 洞察前端 com.choerodon.insight analysis-insight-front 1.0.0 监控前端 com.choerodon.insight monitor-front 1.0.0 看板前端 com.choerodon.kanban choerodon-kanban-front 1.1.0 移动前端 com.choerodon.mobile mobile-front 1.0.0 运行区相关服务 Choerodon 运行区各服务版本信息如下： 服务名 服务组 服务代码 版本号 K8S消息收集 com.choerodon.devops k8s-informer V0.1.1 K8S服务 com.choerodon.devops devops-kubernetes-service 1.1.0 文件服务 com.choerodon.devops choerodon-file-service 1.1.0 部署服务 com.choerodon.devops devops-deploy-service 1.1.6 数据整合服务 com.choerodon.insight data-intergration-service 1.0.0 数据提供服务 com.choerodon.insight data-provide-service 1.0.1 数据操作服务 com.choerodon.insight data-operation-service 1.0.0 移动服务 com.choerodon.mobile mobile-cloud-service 1.0.0 部署前端 com.choerodon.devops deploy-front 1.1.5 监控前端 com.choerodon.insight monitor-front 1.0.0 移动前端 com.choerodon.mobile mobile-front 1.0.0 "},"/docs/concept/choerodon-opensource-component":{"url":"docs/concept/choerodon-opensource-component","title":"使用的开源组件","description":"","body":"Choerodon 使用的开源组件 Choerodon 完全基于开源产品打造。我们从两个方面来叙述Choerodon使用的开源产品或者工具。其一，Choerodon的本身是使用Spring Cloud作为微服务架构，运行在Docker上，同时使用Kubernetes作为容器管理和编排工具；其二，它以DevOps为理论指导，实现了敏捷的最佳实践。 以下我们从两个方面来阐述Choerodon使用了哪些开源产品和工具： 微服务应用框架使用的开源工具集 Choerodon 的微服务应用系统架构由五个不同的层组成，从应用程序代码到所需运行平台和连接服务。这些应用程序和服务通过一致的调度和编排和监督进行管理，所有这些应用程序和服务都运行在K8s提供的运行环境上。 应用前端 Choerodon前端使用react和mobx。 核心组件有： React。React 是一个用于构建用户界面的 JAVASCRIPT 库。 Mobo。Mobx是一个功能强大，上手非常容易的状态管理工具。 微服务后端 Choerodon的微服务后端采用Spring Cloud作为微服务框架，使用Spring Boot作为开发脚手架。 核心组件有： Spring Cloud。Spring Cloud是一个集成了众多开源的框架，利用Spring Boot的开发便利性实现了服务治理、服务注册与发现、负载均衡、数据监控，REST API发布方式等，基本囊括了分布式框架所需要的所有功能。是一套易开放、易部署、易维护的分布式开发工具包。 Spring Boot。Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 消息中间件 Choerodon使用Kafka作为消息中间件。 核心组件有： Kafka。Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 数据服务层 Choerodon采用MySQL作为关系型数据存储库，Redis作为缓存库。 核心组件有： MySQL。Mysql是最流行的开源关系型数据库管理系统。 Redis。Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API 运行环境 Choerodon运行在Docker上。 核心组件有： Docker。Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器编排 Choerodon使用Kubernetes作为容器编排和管理工具。 核心组件有： Kubernetes。Kubernetes是一个开源平台 用于跨主机群集自动部署 扩展和操作应用程序容器 提供以容器为中心的基础架构。 DevOps平台使用的开源工具集 自动化是整个DevOps实现的核心，对应生命周期的每个阶段都可以选择开源工具框架。将DevOps工具集环境作为整体服务交付是一件非常有挑战的事情。Choerodon融合了多个DevOps的开源工具，并且结合自身的能力。DevOps不同阶段的工具使用不同的编程语言开发，需要不同的运行环境(OS、数据库、中间件服务器等)。我们选取了如下的工具集的组合来落地实施DevOps，并且通过Choerodon平台融合能力，将不同的工具融合到Choerodon的DevOps流程中，用户仅需简单的配置即可使用，开始敏捷迭代之旅。 计划 Choerodon使用自主开发的敏捷管理开完成DevOps的计划步骤的工作。Choerodon敏捷管理的核心是需求，计划和执行。即通过用户故事地图来管理用户故事和发布计划，通过迭代来管理冲刺，最后通过看板来可视化冲刺的执行。 核心组件有： 用户故事地图。Choerodon的用户故事地图可以将你的backlog变成一张二维地图，而不是传统的简单列表。 迭代。迭代可以计划冲刺的用户故事数量、故事点、工时，并且拆分用户故事等。 看板。Choerodon的看板是Choerodon敏捷管理中执行部分，它的核心作用是可视化整个迭代的计划执行，并且暴露开发执行过程中的短板或者瓶颈 关于敏捷管理的详情，请参考敏捷管理。 编码 Choerodon采用主流的Git和Gitlab作为代码的管理和托管工具，同时使用Maven作为项目代码的组织和管理工具。 核心组件有： Git。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Gitlab。GitLab 是一个基于 Git 的仓库管理程序 也是一个方便软件开发的强大完整应用。 Maven。Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具 构建 Choerodon在构建阶段，采用Gitlab CI作为持续集成工具，Harbor作为镜像的存放库，同时Choerodon融合了Gitlab CI和Harbor这两个工具，以实现自动化和版本的控制。 Gitlab CI。Gitlab CI是Gitlab提供的一个持续集成工具。主要通过.gitlab-ci.yml 配置文件管理CI过程。 Harbor。Harbor 是一个企业级的 Docker Registry，可以实现 images 的私有存储和日志统计权限控制等功能，并支持创建多项目。 测试 Choerodon采用多个代码检查和测试工具，其中，SonarQube作为自动化代码检查工具；JUnit作为后端Java代码的测试工具； Selenium作为前端测试的工具。 核心组件有： SonarQube。SonarQube是一个用于代码质量管理的开源平台，用于管理源代码的质量，可以从七个维度检测代码质量搜索。通过插件形式，可以支持包括java C# C/C++ PL/SQL Cobol JavaScrip Groovy等等二十几种编程语言的代码质量管理与检测 JUnit。JUnit是一个Java语言的单元测试框架。 Selenium。Selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE） 编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。 部署和运营 Choerodon融合使用Docker、Kubernetes和Harbor作为部署工具。 核心组件有： Docker。Docker是一个开源的引擎 可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。 Kubernetes。Kubernetes是一个开源平台 用于跨主机群集自动部署 扩展和操作应用程序容器 提供以容器为中心的基础架构。 Harbor。Harbor 是一个企业级的 Docker Registry，可以实现 images 的私有存储和日志统计权限控制等功能，并支持创建多项目。 监控 Choerodon的监控包括了从用户故事开始到服务的运营全生命周期的状态、反馈、监控等，帮助开发和运营管理更好的提升效能。 核心组件有： Zipkin。Zipkin为分布式链路调用监控系统 聚合各业务系统调用延迟数据 达到链路调用监控跟踪。 Grafana。Grafana 是一个开箱即用的可视化工具，具有功能齐全的度量仪表盘和图形编辑器，有灵活丰富的图形化选项，可以混合多种风格，支持多个数据源特点。 Promethues。Promethues是由 SoundCloud 开发的开源监控报警系统和时序列数据库(TSDB)。 Micrometer。Micrometer 是一个监控指标的度量类库。 "},"/docs/concept/choerodon-org":{"url":"docs/concept/choerodon-org","title":"组织层次","description":"","body":"Choerodon 的组织架构 组织层次 Choerodon中有三层组织层次，即全局层、组织层和项目层。Choerodon使用三层组织结构来管理用户、权限、项目、环境资源、菜单，以及其他系统资源和功能。Choerodon这样的设计其实是借用的SaaS组织管理概念，主要是Choerodon应用开发框架为了满足用户SaaS化的需求而设计的，在Choerodon的应用开发和运营管理中使用的不多。 下面我们将从如下几个方面来阐述Choerodon的组织层次： 全局层 Choerodon的全局层中包含了系统的一些基本设置，例如组织管理、菜单管理、全局角色管理等。另外，在全局层还可以查看Choerodon系统中的服务和权限分配等。 全局层可以包含多个组织，例如运营组织。 关于全局的具体操作，请查看用户手册全局管理。 组织层 Choerodon使用组织来管理用户、权限、项目、环境资源，以及其它系统资源和功能。在系统中有一个默认的组织运营组织，目前Choerodon中所有的服务、功能和资源都定义在整个组织下面。举个例子，有一个零售公司，想通过Choerodon搭建一个基于微服务的数字化服务平台，此平台涵盖了从门店、零售到库存等整个供应链的管理，需要开发门店管理服务、零售服务、支付服务、库存服务、商品服务等，此时我们可以整个公司看做一个组织，将数字服务平台中包含的所有服务放在这个组织下。当然，如何以项目的形式开发，我们将在项目层中说明。 一个组织可以包含多个项目，例如智能监控。 关于组织的具体操作，请查看用户手册组织管理。 运营组织是Choerodon自带的缺省组织，Choerodon平台上所有的基础服务全部放在次组织下面。例如，用户服务、权限服务、看板服务、Gitlab服务等。 项目层 Choerodon通过项目来管理软件的开发，项目属于组织。Choerodon中项目的含义和现实项目的含义相似。在组织层我们提到零售公司的例子，需要开发门店管理服务、零售服务、支付服务、库存服务、商品服务等五个服务，我们有两个项目组来完成五个服务的开发，A项目组开发门店管理服务、零售服务、支付服务，B项目组负责库存服务、商品服务的开发，我们可以在零售公司组织下创建两个项目，A项目和B项目，在A项目中创建门店管理服务、零售服务、支付服务三个服务，在B项目下创建库存服务、商品服务两个服务。当然，根据具体的业务系统来定义项目，例如数字化服务平台项目，在此项目下创建门店管理服务、零售服务、支付服务、库存服务、商品服务等五个服务。 关于项目的具体操作，请查看用户手册项目管理。 "},"/docs/concept/choerodon-system-architecture":{"url":"docs/concept/choerodon-system-architecture","title":"系统架构","description":"","body":"Choerodon 的系统架构 Choerodon采用Spring Cloud作为微服务架构，本文介绍Spring Cloud微服务架构的概念并描述了Spring Cloud的功能，然后介绍基于Spring Cloud的各个组件搭建Choerodon的微服务整体架构，并对总体架构进行了设计和说明。 企业级系统服务架构演进 单体应用 在诞生之初始，应用与数据库是部署在同一台机器上，这时的用户量、数据量规模都比较小，这样的架构既简单实用、便于维护，成本又低，成为了这个时代的主流架构方式（这种架构仍然存在，在一些小型应用或者实验环境仍是主流，主要还是成本与方便性的原因）。 随着安全意识的提高及技术的发展，数据与应用分离的呼声渐高，原始单一应用逐步转化为WebServer＋DatabaseServer的模式。这一阶段的发展已经走到的尽头。 垂直应用 当单一应用不能满足需求时（主要是响应速度与吞吐量），如何改变架构以应对实际问题呢？问题是推动技术发展的源动力，当问题出现时，总是会有响应的解决方案，垂直型应用架构在这种背景下出现了。 所谓垂直型应用架构，是指将一个大的单一应用拆分成若干个小的单一应用，这样每个应用的压力大约有原来的1/n（粗略估计值）。这种拆分方式为后来的技 术发展奠定了基础，每次架构的变化都与这次有着密不可分的关系——分治（将一个大的问题按一定业务规则分成若干个小的问题，逐个解决）。 SOA 当垂直应用越来越多，业务上跨应用的交互不可避免，这给垂直应用架构带来了很大的挑战，如何才能进行跨应用的交互呢？RPC的出现解决了这个问 题，RPC作为分布式架构的核心内容，在提高业务复用、业务整合、架构扩展等方面发挥着不可替代的作用。因为RPC的实现方式有很多种，单一语言、跨语言 都存在相应的开源产品（当然也可以自建），这为RPC的使用及推广奠定了良好的基础。 此时需要注意，服务一定是无状态的、接口稳定的。 在分布式架构中，将剥离出来的核心业务构成的服务层相对独立、稳定，以这些服务为基础进行不同形式的组合使用，使前端（view、消费者）能够快速适应业务发展、变化。这时的前端架构也逐渐被从整体架构中剥离并越来越受到重视（尤其是移动应用的快速发展）。 微服务架构 分布式架构中的服务越来越多，导致交互越发复杂，不可避免会出现资源浪费的情况。如何才能更好的管理复杂的调用关系、提高资源利用率、对整个服务集群进行动态控制。服务治理被引入来解决上述问题。 如何在服务化架构中实现服务治理以及要对哪些内容进行治理，需要根据实际情况进行取舍，因为每个服务化架构中关注的内容可能都会有所不同。治理的实现方案也没有统一的方案、规范，在能满足自身需要的前提下，尽量避免过度管理、控制。 下面是一些建议： 服务注册与发现，能做到自动化最好，尽量少的人工干预会给后期运维带来非常大的好处； 路由、负载可以通过类似LVS这样的工具或者编码实现软复杂各有好处； 服务升、降级分自动与手动，根据实际访问情况进行动态调整； 服务监测、依赖关系尽量做到自动化； 监控、统计一定要自动化，并且能够进行细粒度分析。 Choerodon 微服务架构 Choerodon 是基于Spring Cloud构建的微服务系统。构件一套完整的微服务架构需要考虑许多问题，包括API Gateway、服务间调用、服务发现、服务容错、服务部署、数据调用等。基于Spring Cloud构建微服务架构可以通过自动配置和绑定Spring环境和其他Spring编程模型来实现微服务。采用Spring Boot应用程序提供的集成功能，通过几个简单的注释，开发人员可以快速配置和启用应用程序中的常见功能模块，并使用久经考验的Netflix组件构建大型分布式系统。 提供的微服务功能模块包括服务发现（Eureka），断路器（Hystrix），智能路由（Zuul）和客户端负载均衡（Ribbon）等。下图显示了采用Spring Cloud系列平台构建的微服务整体架构。 服务网关 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 认证中心 在Spring Cloud需要使用OAUTH2来实现多个微服务的统一认证授权，通过向OAUTH服务发送某个类型的grant type进行集中认证和授权，从而获得access_token，而这个token是受其他微服务信任的，我们在后续的访问可以通过access_token来进行，从而实现了微服务的统一认证授权。 注册中心 Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现。Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server，并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。Spring Cloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。 Eureka由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。 配置服务 Spring Cloud Config为服务端和客户端提供了分布式系统的外部化配置支持。配置服务中心采用Git的方式存储配置文件，因此我们很容易部署修改，有助于对环境配置进行版本管理。 消息服务 Kafka是分布式发布-订阅消息系统，最初由LinkedIn公司开发，之后成为之后成为Apache基金会的一部分，由Scala和Java编写。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。 服务监控 Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间 请求成功率等数据。但是只使用Hystrix Dashboard的话 你只能看到单个应用内的服务信息 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上 这个工具就是Turbine. 调用链追踪 Zipkin 是一款开源的分布式实时数据追踪系统（Distributed Tracking System），基于 Google Dapper 的论文设计而来，由 Twitter 公司开发贡献。其主要功能是聚集来自各个异构系统的实时监控数据，用来追踪微服务架构下的系统延时问题。 "},"/docs/concept/security/RBAC":{"url":"docs/concept/security/RBAC","title":"角色控制访问(RBAC)","description":"","body":"Choerodon 角色控制访问权限(RBAC) Choerodon 的对资源的管理是基于角色控制的，并从组织层、项目层和用户层对角色进行划分。 包含如下的特点： 基于角色的权限访问控制 基于组织层、项目层和用户层的三层权限体系 自定义角色创建和绑定 架构 下图介绍了Choerodon RBAC的架构。 工作流 下图介绍了RBAC的流程图。 组成 Choerodon RBAC 包含资源、角色、用户。同时包含资源与角色的关联，角色与用户的关联。 资源 Choerodon 遵循REST 原则，视HTTP-based REST API 为一个或一组资源。 对资源的引用和操作则视为权限。 权限的级别对应全局、组织、项目。 角色 角色是资源的超集。 角色的级别对应为全局、组织、项目。 角色和资源之间通过RBAC 关联起来。 一个角色严格遵循只能访问所属资源的原则。 角色支持自定义角色，通过标签将角色和第三方系统进行关联。 用户 用户是资源的实际使用者。 用户和角色之间通过RBAC 关联起来。 "},"/docs/concept/security/":{"url":"docs/concept/security/","title":"安全","description":"","body":"安全 介绍Choerodon的认证体系和权限控制功能。 认证体系 介绍 Choerodon 的认证体系， Choerodon 采用 Spring Cloud Security 和 Spring Cloud OAuth2 作为认证技术框架。 权限控制 介绍 Choerodon 的权限控制功能， Choerodon 采用基于角色的权限访问控制（Role-Based Access Control）。 "},"/docs/concept/security/authentication":{"url":"docs/concept/security/authentication","title":"认证体系","description":"","body":"Choerodon 认证体系 身份验证的目的是增强微服务和保证微服务之间的通信安全。 主要负责如下功能： 提供给网关一个统一的认证入口。 提供微服务通信的统一的用户 session 保证。 提供 token 管理系统，用来生成 token ，存储 token ， 撤销 token 。 架构 下图介绍了Choerodon 认证体系的架构。 组成 认证服务器 认证服务器，即专门用来处理认证的服务器。 资源服务器 资源服务器，即存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 在Choerodon 中，资源服务器主要指系统中的一个个微服务。 工作流 认证流程包含三个阶段， 授权阶段，鉴权阶段和使用阶段。 授权阶段 资源拥有者根据用户名和密码，调用授权服务器。 授权服务器校验用户名和密码，生成对应的token返回给客户端，并将token存储下来，用于之后的鉴权。 客户端将token存储在本地，用于之后每次请求的鉴权。 鉴权阶段 客户端根据本地的token请求资源。 网关将根据token去授权服务器鉴权。 授权服务器将网关传来的token 和存储的token 进行对比，来确定本次操作是否是合法的。 使用阶段 鉴权通过，网关将token转化成包含用户信息的JWT token，并将JWT token 传给资源服务器。 资源服务器根据JWT token 解析成用户信息，执行资源操作。 "},"/docs/development-guide/":{"url":"docs/development-guide/","title":"开发手册","description":"","body":""},"/docs/development-guide/backend/":{"url":"docs/development-guide/backend/","title":"后端开发手册","description":"后端开发手册","body":""},"/docs/development-guide/backend/demo/":{"url":"docs/development-guide/backend/demo/","title":"开发Demo程序","description":"","body":"概述 开发环境 在开发之前，要保证环境已经安装正确，详见 软件安装(Windows) 业务需求 创建一个简单的项目，实现记录待办事项的功能. 具体功能包括：创建任务、根据任务Id获取任务、根据ID删除任务、根据任务编号删除任务、根据任务ID更新任务信息。 表结构 todo_task 表：id employee_id task_number task_description state todo_user 表：id employee_name employee_number email todo_swimlane 表：id state next_state "},"/docs/development-guide/backend/demo/api":{"url":"docs/development-guide/backend/demo/api","title":"编写api-展现层","date":"2018-04-27T13:47:28+08:00","body":"api层编写 此demo需涉及api层的 dto 以及 controller 。 编写DTO DTO 类用来封装用户请求的数据信息，这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。 创建在 项目模块 的 xxx.api.dto 包下。 根据需要补充 domain 层对应的 convertor 类。 DTO代码（以taskDTO为例） package io.choerodon.todo.api.dto; public class TaskDTO { private Long id; private Long employeeId; private String state; private String taskNumber; private String taskDescription; private Long objectVersionNumber; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Long getEmployeeId() { return employeeId; } public void setEmployeeId(Long employeeId) { this.employeeId = employeeId; } public String getState() { return state; } public void setState(String state) { this.state = state; } public String getTaskNumber() { return taskNumber; } public void setTaskNumber(String taskNumber) { this.taskNumber = taskNumber; } public String getTaskDescription() { return taskDescription; } public void setTaskDescription(String taskDescription) { this.taskDescription = taskDescription; } public Long getObjectVersionNumber() { return objectVersionNumber; } public void setObjectVersionNumber(Long objectVersionNumber) { this.objectVersionNumber = objectVersionNumber; } } 编写Controller Controller 负责对 Model 和 View 的处理，创建在 项目模块 的 xxx.api.controller.v_ 包下。如 xxx.api.controller.v1。 每一个 Controller 是对一个具体的 DTO 资源进行处理的，所以命名为 dto 类名尾缀替换为 Controler 。如： TaskController 对应 TaskDTO 类。 需要通过 @Controller 指定该类为一个 Controller 类。 Controller 类相关标签 @Permission ，设置API访问权限，有四种属性 permissionLogin ：设置是否需要登陆访问 level ：设置访问资源层级，包括site organization project，user四种层级 roles ：设置可访问用户角色，此为数组 permissionPublic ：设置任意访问。 @ApiOperation ，显示在swagger ui上的接口注释，同时与该接口对应的权限表中的描述字段对应(iam_permission.description) @GetMapping ，是一个组合注解，是@RequestMapping(mathod = RequestMethod.GET)的缩写 @PostMapping等同理。建议使用组合注解。 @CustomPageRequest ，用于分页。 Controller代码（以TaskController为例） Controller中的path以v1开头，需在bootstrap.yml中配置 ignored: /v2/api-docs。 Controller中的path不以v1开头，比如以app开头，则需配置 @Value(\"${choerodon.resource.pattern:/app/*}\") private String pattern package io.choerodon.todo.api.controller.v1; import io.choerodon.core.exception.CommonException; import io.choerodon.todo.api.dto.TaskDTO; import io.choerodon.todo.app.service.TaskService; import io.swagger.annotations.ApiOperation; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.*; import javax.validation.Valid; import java.util.Optional; @RestController @RequestMapping(value = \"/v1/task\") public class TaskController { private TaskService taskService; public TaskController(TaskService taskService) { this.taskService = taskService; } @ApiOperation(value = \"创建任务\") @PostMapping(value = \"/create\") public ResponseEntity create(@RequestBody @Valid TaskDTO task) throws CommonException { return Optional.ofNullable(taskService.create(task)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new CommonException(\"error.Task.create\")); } @ApiOperation(value = \"根据任务Id获取任务\") @GetMapping(value = \"/findTaskById/{id}\") public ResponseEntity findByNumber(@PathVariable @Valid Long id) throws CommonException { return Optional.ofNullable(taskService.queryById(id)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new CommonException(\"error.Task.notFound\")); } /** * 根据任务ID更新任务信息 * * 注意：更新task时需在json数据中添加objectVersionNumber属性及值才能更新成功。 * * @param id 任务ID * @param task 任务信息 * @return 更新后的任务信息 * @throws CommonException 更新失败 */ @ApiOperation(value = \"根据任务ID更新任务状态\") @PutMapping(value = \"/update/{id}\") public ResponseEntity updateUser(@PathVariable Long id) throws CommonException { return Optional.ofNullable(taskService.updateStateById(id)) .map(result -> new ResponseEntity<>(result HttpStatus.OK)) .orElseThrow(() -> new CommonException(\"error.Task.update\")); } @ApiOperation(value = \"根据任务ID删除任务\") @DeleteMapping(value = \"/{id}\") public ResponseEntity deleteByEmployeeId(@PathVariable Long id) throws CommonException { taskService.deleteById(id); return new ResponseEntity(HttpStatus.NO_CONTENT); } @ApiOperation(value = \"根据任务编号删除任务\") @DeleteMapping(value = \"/taskNumber/{taskNumber}\") public ResponseEntity deleteByTaskNumber(@PathVariable String taskNumber) throws CommonException { taskService.deleteByTaskNumber(taskNumber); return new ResponseEntity(HttpStatus.NO_CONTENT); } } "},"/docs/development-guide/backend/demo/app":{"url":"docs/development-guide/backend/demo/app","title":"编写app-应用层","date":"2018-04-27T11:40:28+08:00","body":"App层编写 此demo需涉及到app层的service接口类与其实现类（根据需要补充api层的dto类 以及 domain 层的 convertor 类） Service 接口类 Service 接口类定义了业务操作的一系列接口，并不提供实现，具体实现需要通过服务实现层提供，所以属于供应方的服务接口层。创建在 项目模块 的 xxx.app.service 包下。 Service 接口类代码（以TaskService为例） package io.choerodon.todo.app.service; import io.choerodon.todo.api.dto.TaskDTO; import org.springframework.stereotype.Service; public interface TaskService { TaskDTO queryById(Long id); TaskDTO create(TaskDTO taskDTO); void deleteById(Long id); void deleteByTaskNumber(String taskNumber); TaskDTO updateStateById(Long id); } Service 实现类 Service 接口的具体实现通过服务实现层提供，所以属于供应方的服务实现层。创建在 项目模块 的 xxx.app.service.impl 包下。 实现类，需要用 @Component 标注 Service 实现类代码（以TaskServiceImpl为例） package io.choerodon.todo.app.service.impl; import io.choerodon.todo.api.dto.TaskDTO; import io.choerodon.todo.app.service.TaskService; import io.choerodon.todo.domain.repository.TaskRepository; import io.choerodon.todo.domain.service.ITaskService; import io.choerodon.todo.domain.todo.convertor.TaskConvertor; import org.springframework.stereotype.Component; @Component public class TaskServiceImpl implements TaskService { private TaskRepository taskRepository; private ITaskService iTaskService; public TaskServiceImpl(TaskRepository taskRepository ITaskService iTaskService) { this.taskRepository = taskRepository; this.iTaskService = iTaskService; } @Override public TaskDTO queryById(Long id) { return new TaskConvertor().entityToDto(taskRepository.queryById(id)); } @Override public TaskDTO create(TaskDTO taskDTO) { return new TaskConvertor().entityToDto(taskRepository.create(new TaskConvertor().dtoToEntity(taskDTO))); } @Override public void deleteById(Long id) { taskRepository.deleteById(id); } @Override public void deleteByTaskNumber(String taskNumber) { taskRepository.deleteByTaskNumber(taskNumber); } @Override public TaskDTO updateStateById(Long id) { return new TaskConvertor().entityToDto(iTaskService.updateTaskStateById(id)); } } "},"/docs/development-guide/backend/demo/application":{"url":"docs/development-guide/backend/demo/application","title":"编写Application类","date":"2018-04-27T11:40:28+08:00","body":"编写Application类 编写TodoServiceApplication类 package io.choerodon.todo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class TodoServiceApplication { public static void main(String[] args) { SpringApplication.run(TodoServiceApplication.class args); } } 结构 └─main ├─java │ └─io │ └─choerodon │ └─todo │ └─TodoServiceApplication.java └─resources 启动程序 进入./choerodon-todo-service/ 路径，执行mvn clean spring-boot:run。 控制台打印出如下信息，则表示启动成功。 Started TodoServiceApplication in 21.299 seconds (JVM running for 22.968) "},"/docs/development-guide/backend/demo/create_project":{"url":"docs/development-guide/backend/demo/create_project","title":"新建项目","date":"2018-04-26T13:44:28+08:00","body":"新建项目 项目是基于spring boot的maven项目。 新建maven项目 添加项目依赖 添加默认配置文件 创建maven项目 本地新建一个空的maven 项目choerodon-todo-service-parent 进入项目中，创建子模块choerodon-todo-service 添加项目依赖 在父项目中添加一些公用的pom属性。修改父项目的pom文件。 4.0.0 choerodon-todo-service-parent choerodon-todo-service-parent pom 0.1.0 choerodon-todo-service 0.1.0 io.choerodon choerodon-framework-parent 0.1.0 hand-snapshot-repository Hand Snapshot Repository http://nexus.saas.hand-china.com/content/repositories/rdcsnapshot/ true hand-release-repository Hand Release Repository http://nexus.saas.hand-china.com/content/repositories/rdc/ 在子项目中添加一些子项目的依赖。修改子项目的pom文件。 choerodon-todo-service-parent choerodon-todo-service-parent 0.1.0 4.0.0 choerodon-todo-service org.springframework.boot spring-boot-starter-undertow org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-actuator org.springframework.cloud spring-cloud-starter-eureka io.choerodon choerodon-starter-core ${choerodon.version} io.choerodon choerodon-starter-oauth-resource ${choerodon.version} io.choerodon choerodon-starter-mybatis-mapper ${choerodon.version} io.choerodon choerodon-starter-swagger ${choerodon.version} mysql mysql-connector-java org.springframework.boot spring-boot-starter-test test app 根据子级模块所需jar包添加需要的依赖。 (必须)choerodon-starter-core，核心工具包。提供了一些基础类用于开发过程中使用。以及主要帮助获取自定义的userDetail和一些通用的方法。 (必须)choerodon-starter-oauth-resource，oauth资源服务工具包，主要提供了服务controller的异常统一捕获，并转换成用户语言对应的描述信息，以及配置了服务在接受请求时对jwt token的验证规则。 choerodon-starter-mybatis-mapper，通用mapper和分页插件集成，扩展多语言、审计字段等功能。 添加默认配置文件 项目采用spring boot 进行管理。需要在子项目中配置默认的配置项。 在子模块resource文件夹中创建 bootstrap.yaml 包含如下内容： 项目基础配置，类如数据库、端口号等等 项目与choerodon进行集成，关联注册服务器、验证服务器、以及gateway bootstrap.yml 一定会执行的配置文件，声明项目的一些基本配置。 spring: application: name: choerodon-todo-service server: port: 8080 mybatis: mapperLocations: classpath*:/mapper/*.xml configuration: mapUnderscoreToCamelCase: true management: port: 8081 security: enabled: false feign: hystrix: enabled: true security: basic: enabled: false ignored: /v2/api-docs "},"/docs/development-guide/backend/demo/domain":{"url":"docs/development-guide/backend/demo/domain","title":"编写domain-领域模型层","date":"2018-04-27T11:40:28+08:00","body":"domain层编写 此demo需涉及到demain层的entity、convertor、多entity的service、repository接口类以及infra层的repository实现类 编写entity entity 类需提供属性及简单行为 创建在 项目模块 的 xxx.domain.[模块名称] 包下。如：xxx.domain.todo 每一个 entity 类对应一个 DO 类，所以命名为 DO 类名尾缀替换为 E。如：TaskE 对应 DO 为TaskDO。 属性规范 所有属性均为private属性。 每一个属性需要生成对应的 getter 方法，不允许生成 setter 方法。 需添加Long类型属性 objectVersionNumber ，用以更新数据时的版本控制。 entity代码（以 TaskE 为例） package io.choerodon.todo.domain.todo.entity; public class TaskE { private Long id; private Long employeeId; private String state; private String taskNumber; private String taskDescription; private Long objectVersionNumber; public TaskE(Long id Long employeeId String state String taskNumber String taskDescription Long objectVersionNumber) { this.id = id; this.employeeId = employeeId; this.state = state; this.taskNumber = taskNumber; this.taskDescription = taskDescription; this.objectVersionNumber = objectVersionNumber; } public Long getId() { return id; } public Long getEmployeeId() { return employeeId; } public String getState() { return state; } public String getTaskNumber() { return taskNumber; } public String getTaskDescription() { return taskDescription; } public Long getObjectVersionNumber() { return objectVersionNumber; } public TaskE updateState(TaskE taskE String state){ return new TaskE(taskE.getId() taskE.getEmployeeId() state taskE.getTaskNumber() taskE.getTaskDescription() taskE.getObjectVersionNumber()); } } 编写convertor convertor用于Entity、DO、DTO三者之间的转换，需继承ConvertorI接口，E、D、T对应具体的Entity、DO、DTO 每一个 convertor 类对应一组E、D、T，所以命名为同组类名尾缀替换为 Convertor。如：TaskConvertor。 需要通过@Component纳入spring管理 重写方法 重写doToEntity、entityToDo两个方法 convertor代码（以TaskConvertor为例） package io.choerodon.todo.domain.todo.convertor; import io.choerodon.core.convertor.ConvertorI; import io.choerodon.todo.infra.dataobject.TaskDO; import io.choerodon.todo.domain.todo.entity.TaskE; import org.springframework.beans.BeanUtils; import org.springframework.stereotype.Component; @Component public class TaskConvertor implements ConvertorI { @Override public TaskE doToEntity(TaskDO dataObject) { return new TaskE(dataObject.getId() dataObject.getEmployeeId() dataObject.getState() dataObject.getTaskNumber() dataObject.getTaskDescription() dataObject.getObjectVersionNumber()); } @Override public TaskDO entityToDo(TaskE entity) { TaskDO taskDO = new TaskDO(); BeanUtils.copyProperties(entity taskDO); return taskDO; } } 编写Repository Repository 接口类 Repository 接口类定义了数据操作的一系列接口，并不提供实现，具体实现需要通过Repository实现层提供。创建在项目模块的 xxx.domain.repository 包下。 每一个 Repository 对应一个 entity ，所以命名为 entity 类名尾缀替换为 Repository。如：TaskRepository 对应 TaskE 。 Repository 接口类代码（以TaskRepository为例） package io.choerodon.todo.domain.repository; import io.choerodon.todo.domain.todo.entity.TaskE; public interface TaskRepository { TaskE create(TaskE taskE); void deleteById(Long id); void deleteByTaskNumber(String taskNumber); TaskE update(TaskE taskE); TaskE queryById(Long id); } Repository 实现类 Repository 接口的集体实现。创建在项目模块的 xxx.infra.repository.impl 包下。 每一个 Repository 实现类对应一个 Repository 接口类，所以命名为 Repository 接口类名 + Impl。如：TaskRepositoryImpl 对应 TaskRepository 。 需要通过@Component纳入spring管理 Repository 实现类代码（以TaskRepositoryImpl为例） package io.choerodon.todo.infra.repository.impl; import io.choerodon.core.exception.CommonException; import io.choerodon.todo.domain.repository.TaskRepository; import io.choerodon.todo.domain.todo.convertor.TaskConvertor; import io.choerodon.todo.domain.todo.entity.TaskE; import io.choerodon.todo.infra.dataobject.TaskDO; import io.choerodon.todo.infra.mapper.TaskMapper; import org.springframework.stereotype.Component; import java.util.List; @Component public class TaskRepositoryImpl implements TaskRepository { private TaskMapper taskMapper; public TaskRepositoryImpl(TaskMapper taskMapper) { this.taskMapper = taskMapper; } @Override public TaskE create(TaskE taskE) { TaskDO taskDO = new TaskConvertor().entityToDo(taskE); List taskDOList = taskMapper.select(taskDO); if (!taskDOList.isEmpty()) { throw new CommonException(\"error.repo.create.task.exist\"); } if (taskMapper.insertSelective(taskDO) != 1) { throw new CommonException(\"error.repo.create.task.failed\"); } return new TaskConvertor().doToEntity(taskMapper.selectByPrimaryKey(taskDO.getId())); } @Override public TaskE queryById(Long id) { return new TaskConvertor().doToEntity(taskMapper.selectByPrimaryKey(id)); } @Override public void deleteById(Long id) { if (taskMapper.selectByPrimaryKey(id) == null) { throw new CommonException(\"error.task.not.exist\"); } if (taskMapper.deleteByPrimaryKey(id) != 1) { throw new CommonException(\"error.task.delete\"); } } @Override public void deleteByTaskNumber(String taskNumber) { if (taskMapper.queryByTaskNumber(taskNumber) == null) { throw new CommonException(\"error.task.not.exist\"); } if (taskMapper.deleteByPrimaryKey(taskMapper.queryByTaskNumber(taskNumber).getId()) != 1) { throw new CommonException(\"error.task.delete\"); } } @Override public TaskE update(TaskE taskE) { TaskDO taskDO = new TaskConvertor().entityToDo(taskE); if (taskMapper.updateByPrimaryKeySelective(taskDO) != 1) { throw new CommonException(\"error.task.update\"); } return new TaskConvertor().doToEntity( taskMapper.selectByPrimaryKey(taskDO.getId())); } } 编写Service Service 接口类 Service 接口类定义了业务操作的一系列接口，并不提供实现，具体实现需要通过服务实现层提供，所以属于供应方的服务接口层。创建在 项目模块 的 xxx.domain.service 包下。 每一个 Service 对应一个或多个 entity 类，因需要与app层service区分，所以规定命名为 I + 涉及主要entity类名 + Service。如：ITaskService。代码（以 ITaskService 为例） package io.choerodon.todo.domain.service; import io.choerodon.todo.domain.todo.entity.TaskE; public interface ITaskService { TaskE updateTaskStateById(Long id); } Service 实现类 Service 接口的具体实现通过服务实现层提供，所以属于供应方的服务实现层。创建在 项目模块 的 xxx.domian.service.impl 包下。 实现类，如无特殊情况，需要用 @Service 标注，以自动扫描注册 代码(以 ITaskServiceImpl 为例) package io.choerodon.todo.domain.service.impl; import io.choerodon.todo.domain.repository.SwimlaneRepository; import io.choerodon.todo.domain.repository.TaskRepository; import io.choerodon.todo.domain.service.ITaskService; import io.choerodon.todo.domain.todo.entity.SwimlaneE; import io.choerodon.todo.domain.todo.entity.TaskE; import org.springframework.stereotype.Service; @Service public class ITaskServiceImpl implements ITaskService { private TaskRepository taskRepository; private SwimlaneRepository swimlaneRepository; public ITaskServiceImpl(TaskRepository taskRepository SwimlaneRepository swimlaneRepository) { this.taskRepository = taskRepository; this.swimlaneRepository = swimlaneRepository; } @Override public TaskE updateTaskStateById(Long id) { TaskE taskE = taskRepository.queryById(id); SwimlaneE swimlaneE = swimlaneRepository.selectByState(taskE.getState()); return taskRepository.update(taskE.updateState(taskE swimlaneE.getNextState())); } } "},"/docs/development-guide/backend/demo/infra":{"url":"docs/development-guide/backend/demo/infra","title":"编写infra-基础设施层","date":"2018-04-27T11:01:28+08:00","body":"infra层编写 此demo需涉及到infra层的 dataobject 类以及 mapper 类。 关于此章节具体工具包介绍见Mybatis mapper工具包 编写dataobject类 DO 类不需要提供任何实现，所以属于供应方的服务接口层。创建在 项目模块 的 xxx.infra.dataobject 包下。 每一个 DO 类即为一个实体类，对应数据库中的一个具体表。 名称=表具体名称+DO，表名中 _ 替换为驼峰命名法，首字母大写。如：TaskDO 对应表为 todo_task。 指定对应表 @Table(name = “table_name”) 指定 DO 对应数据库中表的名称。 每一个 DO 对应数据库中的一个具体表，一般都需要继承 AuditDomain 类。 属性规范 所有属性均为private属性。 每一个属性需要生成对应的 getter 和 setter 方法。 字段名称应根据驼峰命名规则从数据库列名转换过来。例如：数据库列名为 USER_NAME ，则字段名为 UserName，特殊字段名称，可以在字段在添加 @Column(name = “xxx”) 注解，指定数据库列名。 属性的的类型与字段的 type 对应 不使用基本类型，全部使用基本类型的包装类，如 Long 对应数据库中的 INTEGER，而不是使用 long 数字类型主键统一采用 Long 金额、数量 等精度严格浮点类型采用 BigDecimal 注意：BigDecimal 在计算、比较方面的特殊性 所有的主键字段都需要用@Id标注 对于自增张、序列（SEQUENCE）类型的主键，需要添加注解@GeneratedValue 序列命名规范：表名_S。例如：表 SYS_USER 对应的序列为 SYS_USER_S 非数据库字段 需要用 @Transient 标注 javax.persistence.Transient TaskDO.java 代码 package io.choerodon.todo.infra.dataobject; import io.choerodon.mybatis.annotation.ModifyAudit; import io.choerodon.mybatis.annotation.VersionAudit; import io.choerodon.mybatis.domain.AuditDomain; import javax.persistence.GeneratedValue; import javax.persistence.Id; import javax.persistence.Table; @ModifyAudit //在类上使用，启用审计字段支持，实体类加上该注解后，插入和更新会启动对creationDate、createdBy、lastUpdateDate、lastUpdatedBy自维护字段支持 @VersionAudit //在类上使用，启用objectVersionNumber自维护支持，插入一条数据objectVersionNumber默认为1，每次update后objectVersionNumber自增1 @Table(name = \"todo_task\") public class TaskDO extends AuditDomain { //AuditDomain包含5个自维护字段，使用@ModifyAudit和@VersionAudit的实体类要继承该类 @Id @GeneratedValue //对于自增张、序列（SEQUENCE）类型的主键，需要添加该注解 private Long id; private Long employeeId; private String state; private String taskNumber; private String taskDescription; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public Long getEmployeeId() { return employeeId; } public void setEmployeeId(Long employeeId) { this.employeeId = employeeId; } public String getState() { return state; } public void setState(String state) { this.state = state; } public String getTaskNumber() { return taskNumber; } public void setTaskNumber(String taskNumber) { this.taskNumber = taskNumber; } public String getTaskDescription() { return taskDescription; } public void setTaskDescription(String taskDescription) { this.taskDescription = taskDescription; } } Mapper mapper接口类 Mapper 接口类即为传统意义上的 DAO，但与 interface 不同，Mapper 本身就是对数据访问的具体实现，所以属于供应方的服务实现层。创建在 项目模块 的 xxx.infra.mapper 包下。 每一个 Mapper 接口类封装了对数据库表的操作，每一个 Mapper 对应一个 DO 类，所以命名为 DO 类名尾缀替换为 Mapper 。如：TaskMapper 对应DO为 TaskDO 类。 基础的 CRUD 操作不需要再次实现，通过继承 BaseMapper 类实现。其中 T 为 对应 DO 的泛型。 复杂的数据库操作需要定义具体的接口方法。 mapper.xml Mapper的xml文件 是数据库的的具体映射，与 Mapper 接口同级，创建在 项目模块 resources 目录的 xxx..mapper 包下。 Mapper的xml文件，与 Mapper 接口对应。所以命名 Mapper 接口类相同。 Mapper的xml文件非必须，由于继承BaseMapper类后基本的 CRUD 不需要进行配置，所以只有CRUD操作时不需要创建对应的 xml 文件。 对于自定义的数据库方法，需要创建对应的 Mapper.xml 文件。 Mapper的xml 中的操作 id 对应 Mapper 接口类的方法名。 以下为一个示例，不在本项目中使用: package io.choerodon.iam.infra.mapper; import java.util.List; import io.choerodon.iam.infra.dataobject.MenuDO; import io.choerodon.mybatis.common.BaseMapper; public interface MenuMapper extends BaseMapper { List queryIncludeTl(); List queryMenusWithPermissions(); } SELECT * tl1.name as zh_name tl2.name as en_name FROM iam_menu m LEFT JOIN iam_menu_tl tl1 ON m.id = tl1.id AND tl1.lang = 'zh_CN' LEFT JOIN iam_menu_tl tl2 ON m.id = tl2.id AND tl2.lang = 'en_US' SELECT im.* ip.id permission_id ip.code permission_code ip.path ip.method ip.level permission_level ip.action ip.resource ip.public_access ip.login_access ip.service_name FROM iam_menu im LEFT JOIN iam_menu_permission imp on im.id = imp.menu_id LEFT JOIN iam_permission ip on imp.permission_id = ip.id WHERE im.type = \"menu\" 以下为本项目中使用的mappper接口 UserMapper.java ，未定义额外的sql所以无需创建对应xml： package io.choerodon.todo.infra.mapper; import io.choerodon.mybatis.common.BaseMapper; import io.choerodon.todo.infra.dataobject.UserDO; public interface UserMapper extends BaseMapper { } "},"/docs/development-guide/backend/demo/init_db":{"url":"docs/development-guide/backend/demo/init_db","title":"初始化数据库","date":"2018-04-26T15:38:28+08:00","body":"初始化数据库 项目创建成功之后，需要初始化本地数据库。 创建用户 创建数据库 编写表结构对应的groovy脚本 初始化表结构 验证表结构 创建用户 确保数据库启动成功 创建项目访问的用户，执行如下命令： CREATE USER 'choerodon'@'%' IDENTIFIED BY \"123456\"; 创建数据库 用户创建成功之后，创建项目对应的数据库，执行如下命令： CREATE DATABASE choerodon_demo_service_todo DEFAULT CHARACTER SET utf8; 将新创建的数据库权限赋予用户 GRANT ALL PRIVILEGES ON choerodon_demo_service_todo.* TO choerodon@'%'; FLUSH PRIVILEGES; 在项目的bootstarp.yaml 文件中添加数据库连接信息： spring: datasource: url: jdbc:mysql://localhost/choerodon_demo_service_todo?useUnicode=true&characterEncoding=utf-8&useSSL=false username: choerodon password: 123456 编写表结构对应的groovy脚本 Choerodon 采用Liquibase + groovy 的方式对数据库管理。 更多有关Liguibase的资料见 Liquibase 官网。 在./choerodon-todo-service/src/resources/db/script 路径下创建todo_swimlane.groovy todo_user.groovy todo_task.groovy。 编写groovy 脚本。 todo_user.groovy // todo_user.groovy package script.db databaseChangeLog(logicalFilePath: 'todo_user.groovy') { changeSet(id: '2017-05-29-todo_user' author: 'your.email@email.com') { createTable(tableName: \"todo_user\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'employee_name' type: 'VARCHAR(32)' remarks: '员工名') column(name: 'employee_number' type: 'VARCHAR(32)' remarks: '员工号') { constraints(unique: true) } column(name: 'email' type: 'VARCHAR(32)' remarks: '邮箱') column(name: \"OBJECT_VERSION_NUMBER\" type: \"BIGINT\" defaultValue: \"1\") column(name: \"CREATED_BY\" type: \"BIGINT\" defaultValue: \"-1\") column(name: \"CREATION_DATE\" type: \"DATETIME\" defaultValueComputed: \"CURRENT_TIMESTAMP\") column(name: \"LAST_UPDATED_BY\" type: \"BIGINT\" defaultValue: \"-1\") column(name: \"LAST_UPDATE_DATE\" type: \"DATETIME\" defaultValueComputed: \"CURRENT_TIMESTAMP\") } } } todo_task.groovy // todo_task.groovy package script.db databaseChangeLog(logicalFilePath: 'todo_task.groovy') { changeSet(id: '2017-05-29-todo_task' author: 'your.email@email.com') { createTable(tableName: \"todo_task\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'employee_id' type: 'BIGINT' remarks: '员工ID') column(name: 'state' type: 'VARCHAR(36)' remarks: '状态') column(name: 'task_number' type: 'VARCHAR(64)' remarks: '任务编号') { constraints(unique: true) } column(name: 'task_description' type: 'VARCHAR(256)' remarks: '任务编号') column(name: \"OBJECT_VERSION_NUMBER\" type: \"BIGINT\" defaultValue : \"1\") column(name: \"CREATED_BY\" type: \"BIGINT\" defaultValue : \"-1\") column(name: \"CREATION_DATE\" type: \"DATETIME\" defaultValueComputed : \"CURRENT_TIMESTAMP\") column(name: \"LAST_UPDATED_BY\" type: \"BIGINT\" defaultValue : \"-1\") column(name: \"LAST_UPDATE_DATE\" type: \"DATETIME\" defaultValueComputed : \"CURRENT_TIMESTAMP\") } } } todo_swimlane.groovy // todo_swimlane.groovy package script.db databaseChangeLog(logicalFilePath: 'todo_swimlane.groovy') { changeSet(id: '2017-05-29-todo_swimlane' author: 'your.email@email.com') { createTable(tableName: \"todo_swimlane\") { column(name: 'id' type: 'BIGINT UNSIGNED' remarks: 'ID' autoIncrement: true) { constraints(primaryKey: true) } column(name: 'state' type: 'VARCHAR(36)' remarks: '状态') { constraints(unique: true) } column(name: 'next_state' type: 'VARCHAR(36)' remarks: '下一状态') } } } 初始化表结构 在./choerodon-todo-service 路径下，创建init-local-database.sh 文件。 #!/bin/bash mkdir -p target if [ ! -f target/choerodon-tool-liquibase.jar ] then curl http://nexus.saas.hand-china.com/content/repositories/rdc/io/choerodon/choerodon-tool-liquibase/0.1.0/choerodon-tool-liquibase-0.1.0.jar -o target/choerodon-tool-liquibase.jar fi java -Dspring.datasource.url=\"jdbc:mysql://localhost/choerodon_demo_service_todo?useUnicode=true&characterEncoding=utf-8&useSSL=false\" \\ -Dspring.datasource.username=choerodon \\ -Dspring.datasource.password=123456 \\ -Ddata.drop=false -Ddata.init=true \\ -Ddata.dir=src/main/resources \\ -jar target/choerodon-tool-liquibase.jar 进入./choerodon-todo-service 执行如下命令： sh init-local-database.sh 脚本执行程序会自动扫描resources中的groovy数据库初始化文件以及excel初始化数据。 执行 init-local-database.sh 脚本，若出现错误： Error: Invalid or corrupt jarfile target/choerodon-tool-liquibase.jar 则自行下载 choerodon-tool-liquibase.jar 并重命名覆盖./choerodon-todo-service/target/choerodon-tool-liquibase.jar 并重新执行init-local-database.sh 脚本 验证表结构 登录数据库，查询现有的表结构。 mysql> show tables; +---------------------------------------+ | Tables_in_choerodon_demo_service_todo | +---------------------------------------+ | DATABASECHANGELOG | | DATABASECHANGELOGLOCK | | todo_swimlane | | todo_task | | todo_user | +---------------------------------------+ 5 rows in set (0.00 sec) "},"/docs/development-guide/backend/demo/proj_structure":{"url":"docs/development-guide/backend/demo/proj_structure","title":"项目结构","date":"2018-04-25T13:42:28+08:00","body":"项目结构 choerodon-todo-service-parent └─choerodon-todo-service └─src ├─main │ ├─java │ │ └─io │ │ └─choerodon │ │ └─todo │ │ ├─api │ │ │ ├─controller │ │ │ │ └─v1 │ │ │ └─dto │ │ ├─app │ │ │ └─service │ │ │ └─impl │ │ ├─domain │ │ │ ├─repository │ │ │ ├─service │ │ │ │ └─impl │ │ │ └─todo │ │ │ ├─convertor │ │ │ └─entity │ │ └─infra │ │ ├─dataobject │ │ ├─mapper │ │ └─repository │ │ └─impl │ └─resources │ ├─mapper │ └─script │ └─db └─test └─java "},"/docs/development-guide/backend/develop_env/":{"url":"docs/development-guide/backend/develop_env/","title":"开发环境搭建","description":"开发环境搭建","body":""},"/docs/development-guide/backend/develop_env/install_windows":{"url":"docs/development-guide/backend/develop_env/install_windows","title":"软件安装(Windows)","description":"软件安装(Windows)","body":"软件安装 开发工具 Git JDK 1.8.0 及以上 maven 3.3 及以上 Docker for Windows IDE Mysql Kafka Phpmyadmin (可选) Git 安装 在 Git 官网 下载对应平台的 Git。 本地执行安装文件，安装 Git 环境。 配置完成后打开 git bash 执行 git ，有提示则说明环境安装成功。 配置本地git。 打开git bash 执行如下命令： # 请将下面命令按实际情况进行执行 git config --global user.name \"Your Name\" git config --global user.email \"Your Email\" Java 安装 在 Oracle 官网 下载对应平台的 JDK 1.8.0 以上的环境。 本地执行安装文件，安装 JDK 环境。 Win 在环境变量系统变量中 配置环境变量 JAVA_HOME 指向JDK安装目录，并将 path 配置 JDK 的环境变量 指向 JDK 安装目录下 JDK/bin， 配置完成后打开 git bash 执行 java ，有提示则说明环境安装成功。(git bash执行会有乱码，cmd则正常) Maven 安装 在 Maven 官网 下载对应平台的合适的 maven 版本的压缩包。 本地解压压缩包。 Win 在环境变量中系统变量的 path 配置 maven 的环境变量指向 maven 解压目录下的 /bin 。 配置完成后打开 git bash 执行 mvn -v ，有提示则说明环境安装成功。 Docker for Windows 安装 在 Docker for Windows 下载安装包 本地执行安装文件，安装Docker 启动Docker，然后会提示启用Hyper-V需要重启 重启后Docker会自动启动 打开 git bash 执行 docker --version ，有提示则说明环境安装成功。 打开 docker for windows，并在General 中勾选 Expose daemon on tcp://localhost:2375 without TLS 注意要使用Docker for Windows，机器必须开启虚拟化支持，部分机型默认禁用，需进入bios进行设置，因各机型设置不相一致，在此不做详细说明 IDE 安装 这里以idea 为例 在IDEA官网下载安装包 本地执行安装文件，安装IDEA 菜单栏File > Setting打开设置 Editor > Code Style > Line separator (for new lines): Unix and OS X (n) 确保idea使用utf-8编码 安装Docker插件。在File-Settings-Plugins中，搜索Docker integration，点击Install安装，并重启软件加载插件 IDEA中配置Docker，在File-Settings-Build Execution Deployment-Clouds中，点击加号新建，会自动读取docker信息，直接保存即可 其他软件安装 除了基本的软件之外，其他基础软件可以通过官网下载安装包，也可以通过docker启动镜像。choerodon建议通过docker 启动。 在本地创建docker-compose的运行路径 编写docker-compose.yaml 文件 打开git bash 执行docker-compose up -d 执行docker ps 或docker-compose ps 查看容器是否启动 这里提供一份默认的mysql 配置和docker-compose.yaml 配置。 # mysql_db.cnf [mysqld] lower_case_table_names=1 character_set_server=utf8 max_connections=500 # docker-compose.yaml version: \"3\" services: zookeeper-0: container_name: zookeeper-0 image: registry.saas.hand-china.com/tools/zookeeper:3.4.10 hostname: zookeeper-0 environment: - ZK_REPLICAS=1 - ZK_HEAP_SIZE=2G - ZK_TICK_TIME=2000 - ZK_INIT_LIMIT=10 - ZK_SYNC_LIMIT=5 - ZK_MAX_CLIENT_CNXNS=60 - ZK_SNAP_RETAIN_COUNT=3 - ZK_PURGE_INTERVAL=1 - ZK_LOG_LEVEL=INFO - ZK_CLIENT_PORT=2181 - ZK_SERVER_PORT=2888 - ZK_ELECTION_PORT=3888 ports: - \"2181:2181\" - \"2888:2888\" - \"3888:3888\" command: - sh - -c - zkGenConfig.sh && exec zkServer.sh start-foreground volumes: - \"./kafka/zk:/var/lib/zookeeper\" kafka-0: container_name: kafka-0 image: registry.saas.hand-china.com/tools/kafka:1.0.0 hostname: 127.0.0.1 depends_on: - zookeeper-0 links: - zookeeper-0 ports: - \"9092:9092\" command: - sh - -c - \"/opt/kafka/bin/kafka-server-start.sh config/server.properties \\ --override zookeeper.connect=zookeeper-0:2181 \\ --override log.dirs=/opt/kafka/data/logs \\ --override broker.id=0 \" volumes: - \"./kafka/kafka:/opt/kafka/data\" mysql: container_name: mysql image: registry.saas.hand-china.com/tools/mysql:5.7.17 ports: - \"3306:3306\" environment: MYSQL_ROOT_PASSWORD: root volumes: - ./mysql/mysql_data:/var/lib/mysql - ./mysql/mysql_db.cnf:/etc/mysql/conf.d/mysql_db.cnf redis: container_name: redis image: registry.saas.hand-china.com/tools/redis:4.0.2 ports: - \"6379:6379\" phpadmin: container_name: phpadmin image: registry.saas.hand-china.com/tools/phpmyadmin ports: - \"80:80\" environment: PMA_ARBITRARY: 1 停止容器通过命令docker-compose down。 有关Docker的更多信息请见此处 有关Docker-Compose的更多信息请见此处 "},"/docs/development-guide/backend/intergration/":{"url":"docs/development-guide/backend/intergration/","title":"测试与集成","description":"","body":"概述 准备 在集成之前，要保证： 环境已经安装正确，详见 软件安装(Windows) Demo已正确编写，详见 Demo编写 需求 要求demo与choerodon结合，进行API测试。 "},"/docs/development-guide/backend/intergration/init":{"url":"docs/development-guide/backend/intergration/init","title":"数据初始化","date":"2018-04-25T11:00:28+08:00","body":"数据初始化 启动容器 启动 mysql容器 创建Mysql数据库 1.查看容器，确认存在容器名为mysql的容器 2.用choerodon用户命令行登陆 mysql 容器，密码为 123456 docker exec -ti mysql mysql -u choerodon -p If you are using mintty try prefixing the command with 'winpty'： winpty docker exec -ti mysql mysql -u choerodon -p 3.创建用户和数据库: CREATE DATABASE iam_service DEFAULT CHARACTER SET utf8; CREATE DATABASE manager_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON iam_service.* TO choerodon@'%'; GRANT ALL PRIVILEGES ON manager_service.* TO choerodon@'%'; FLUSH PRIVILEGES; 查看用户与数据库 mysql> select User from mysql.user; +-----------+ | User | +-----------+ | choerodon | | root | | mysql.sys | +-----------+ 3 rows in set (0.00 sec) mysql> show databases; +-----------------------------+ | Database | +-----------------------------+ | information_schema | | iam_service | | manager_service | | choerodon_demo_service_todo | | mysql | | performance_schema | | sys | +-----------------------------+ 7 rows in set (0.01 sec) 初始化数据库 需初始化manager-service，iam-service两个数据库，此处以manager-service为例。 新建初始化数据库临时目录，如：managerInit cd managerInit，新建sh脚本init-local-database，以下提供脚本示例，具体请根据本地配置修改。 init-local-database.sh: #!/usr/bin/env bash mkdir -p target curl http://nexus.saas.hand-china.com/content/repositories/rdc/io/choerodon/choerodon-tool-liquibase/0.1.0/choerodon-tool-liquibase-0.1.0.jar -o target/choerodon-tool-liquibase.jar curl http://nexus.saas.hand-china.com/content/repositories/rdc/io/choerodon/manager-service/0.1.0/manager-service-0.1.0.jar -o target/manager-service.jar java -Dspring.datasource.url=\"jdbc:mysql://localhost/manager_service?useUnicode=true&characterEncoding=utf-8&useSSL=false\" \\ -Dspring.datasource.username=choerodon \\ -Dspring.datasource.password=123456 \\ -Ddata.drop=false -Ddata.init=init \\ -Ddata.jar=target/manager-service.jar \\ -jar target/choerodon-tool-liquibase.jar 执行命令:sh init-local-database.sh 命令执行成功之后，刷新 manager_service 数据库，会出现初始化脚本中的表以及初始化数据 "},"/docs/development-guide/backend/intergration/intergration_swagger":{"url":"docs/development-guide/backend/intergration/intergration_swagger","title":"集成与测试","date":"2018-04-27T15:58:28+08:00","body":"集成与测试 前提 启动eureka-serve等服务 Eureka服务发现 如需添加Eureka服务发现，需在CHOERODON-TODO-SERVICE中进行两步修改： 在TodoServiceApplication 上添加@EnableEurekaClient 注解 在TodoServiceApplication 上添加@ChoerodonRoute注解 @EnableEurekaClient @ChoerodonRoute(name = \"dev\" path = \"/todo/**\" serviceId = \"choerodon-todo-service\") 在bootstrap.yml中添加关于Eureka的配置 eureka: instance: preferIpAddress: true leaseRenewalIntervalInSeconds: 1 leaseExpirationDurationInSeconds: 3 client: serviceUrl: defaultZone: ${EUREKA_DEFAULT_ZONE:http://localhost:8000/eureka/} 重启Todo服务 如果上述步骤执行无误，可在本地的 http://localhost:8000/ 查看注册成功的服务: OAUTH-SERVER API-GATEWAY-TEST CHOERODON-TODO-SERVICE REGISTER-SERVER GATEWAY-HELPER swagger Api服务 使用swagger测试需启动manager-service模块，在docker-compose.yaml中加入此容器并重启所有模块 manager-service: container_name: manager-service image: registry.saas.hand-china.com/choerodon-framework/manager-service:0.1.0 ports: - \"8963:8963\" Note. 启动顺序：基础软件mysql、kafka等 ，eureka-server服务，manager-service，api-gateway，其余模块。 打开 http://localhost:8963/swagger-ui.html 该地址端口号为Eurake上对应端口号 打开任意一个api，点击右边红色的叹号对调用该api进行授权（勾选default scope） 在弹出界面输入用户名密码，本地默认为admin/admin 在这里便可以对controller中声明的api进行测试，这一步需启动gateway-helper "},"/docs/development-guide/backend/intergration/run":{"url":"docs/development-guide/backend/intergration/run","title":"模块运行","date":"2018-04-25T11:00:28+08:00","body":"前提 开发环境配置：windows开发环境安装 数据环境准备：基础环境准备 启动 mysql，redis，kafka等容器 启动相关服务 要使功能完整可用，在本地至少启动如下模块 register api-gateway gateway-helper oauth 编写docker-compose.yaml 文件 打开git bash 执行docker-compose up -d 执行docker ps 或docker-compose ps 查看容器是否启动 这里提供一份docker-compose.yaml以供参考，具体根据本地配置进行修改 # docker-compose.yaml version: \"3\" services: eureka-server: container_name: eureka-server image: registry.saas.hand-china.com/choerodon-framework/eureka-server:0.1.0 hostname: 127.0.0.1 ports: - \"8000:8000\" api-gateway: container_name: api-gateway image: registry.saas.hand-china.com/choerodon-framework/api-gateway:0.1.0 ports: - \"8080:8080\" environment: - zuul.addHostHeader=true - zuul.routes.dev.path=/todo/** - zuul.routes.dev.serviceId=choerodon-todo-service oauth-server: container_name: oauth-server image: registry.saas.hand-china.com/choerodon-framework/oauth-server:0.1.0 ports: - \"8020:8020\" gateway-helper: container_name: gateway-helper image: registry.saas.hand-china.com/choerodon-framework/gateway-helper:0.1.0 ports: - \"9180:9180\" 停止容器通过命令docker-compose down。 有关Docker的更多信息请见此处 有关Docker-Compose的更多信息请见此处 启动todo服务 进入choerodon-todo-service目录下，运行以下命令启动本地项目 mvn clean spring-boot:run "},"/docs/development-guide/backend-environment-deployment":{"url":"docs/development-guide/backend-environment-deployment","title":"后端环境部署","date":"2017-10-30","body":"HAPCloud 后端demo环境部署 前置条件kubernetes环境 本教程旨在于k8s中通过现有的部署文件轻松部署一个HAPCloud环境，所有部署文件的在hapcloud-deploy。 部署DB以及相关基础依赖 部署mysql 在k8s管理节点上通过执行kubectl create -f pv.yml新建在k8s控制台界面上或者在节点终端建立mysql所对应的PersistentVolumeClaim(简称pv)即持久卷，因为mysql容器中'/var/lib/mysql目录需挂载出去。并在nfs上建立pv.yml中所设设置的挂载目录。建立好之后执行kubectl get pv所建pv的状态为Available。 在k8s控制台界面上或者在节点终端建立mysql所对应的PersistentVolumeClaim(简称pvc)、Service、deploymentConfigConfigMap。pvc建立好之后如果与先前建立的pv绑定成功，此时再查看pv的状态则为Bound`。 部署rabbitmq和redis rabbitmq和redis无需挂载卷所以只需在k8s上执行对应的部署文件即可。 首次初始化数据库 可以通过phpmyadmin或者通过连接openvpn在mysql容器中建立用户和数据库并赋予权限。脚本如下： CREATE USER 'hapcloud'@'%' IDENTIFIED BY \"handhand\"; CREATE DATABASE hap_user_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_framework_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_scheduler_service DEFAULT CHARACTER SET utf8; CREATE DATABASE hap_zipkin_ui DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON hap_user_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_framework_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_scheduler_service.* TO hapcloud@'%'; GRANT ALL PRIVILEGES ON hap_zipkin_ui.* TO hapcloud@'%'; FLUSH PRIVILEGES; 建立配置文件git仓库 可以从我们的git仓库fork出一份自己的仓库，以便添加一些额外的配置。此时hap-config-server.yml文件中把注释部分取消并换成自己的仓库地址。 部署HAPCloud核心服务 1. 注册服务hap-register-server 直接执行。 2. 配置服务hap-config-server 在注释处替换自己的配置文件仓库，直接运行即可。 3. 认证服务hap-oauth-server 直接执行 4. 网关hap-api-gateway hap-api-gateway的SWAGGER认证地址需要根据所配置的路由地址来确认。 5. 用户服务hap-user-service 首次需先执行数据库的初始化。在hap-user-service项目的根目录下执行`sh init-local-database.sh`，需连上openvpn并把脚本中的mysql地址替换为k8s上mysql pod地址。现在也可直接执行hap-user-service.yml中的job即可初始化话数据库。 现在也 6. 用户管理服务hap-user-admin-service 用户管理服务也是依赖`hap_user_service`数据库的初始化，与hap-user-service所依赖数据库相同。 7. 框架服务hap-framework-service 框架服务的数据库初始化需在用户服务的数据库初始化之后，同样可以通过执行yml文件的job初始化和远程执行`sh init-local-database.sh`进行初始化数据。 hap-user-service先执行数据库初始化。 部署HAPCloud其他服务 1. 调度服务hap-scheduler-service 确保`hap_user_service`数据初始化后，进入项目目录，执行`sh init-local-database.sh`初始化项目数据库，初始化结束后即可启动应用。 "},"/docs/development-guide/front/":{"url":"docs/development-guide/front/","title":"前端开发","description":"","body":""},"/docs/development-guide/front/component/":{"url":"docs/development-guide/front/component/","title":"通用组件和封装函数","description":"","body":""},"/docs/development-guide/front/component/commoncomponent/":{"url":"docs/development-guide/front/component/commoncomponent/","title":"通用组件","description":"","body":""},"/docs/development-guide/front/component/commoncomponent/action":{"url":"docs/development-guide/front/component/commoncomponent/action","title":"Action","date":"2017-02-01","body":"Action 操作组件 用途 Action组件为封装的框架统一Table表操作一栏功能组件。 用法 在组件头部引用后直接调用 ... import Action from 'Action'; ... return ( ... ... ) 参数 说明 service 该按钮具有的permision字段， 如果没有权限则不显示该按钮 icon 图标 text 按钮文字 action 点击之后的事件 "},"/docs/development-guide/front/component/commoncomponent/antd":{"url":"docs/development-guide/front/component/commoncomponent/antd","title":"ANTD","body":"ANTD HAP Cloud 大量运用ANTD UI框架 可以通过链接 进行系统学习。 "},"/docs/development-guide/front/component/commoncomponent/clientsearch":{"url":"docs/development-guide/front/component/commoncomponent/clientsearch","title":"ClientSearch","body":"ClientSearch 搜索框 用途 ClientSearch搜索框组件是为实现页面table表过滤搜索功能。 用法 在组件头部引用后直接调用 ... import ClientSearch from ClientSearch ... handleSearch = (result) => { this.setState({ search: result }); } ... return ( ) 参数 说明 options 搜索框下拉列表的数据 name代表一行的文字 code代表该行对应的字段 onSearch 搜索的点击事件 默认带一个对象参数 该对象参数有两个key为code和input 分别对应下拉框选中的字段和input框输入的内容 "},"/docs/development-guide/front/component/commoncomponent/isauthspin":{"url":"docs/development-guide/front/component/commoncomponent/isauthspin","title":"开放master之IsAuthSpin组件","body":"开放master之IsAuthSpin组件 自定义master HAP Cloud 默认首页进入iam模块container目录下的master.js文件 如需自定义master，可在根目录config.js中配置 const config = { ... \"master\": JSON.stringify('devops') ... } module.exports = config; 此处配置将页面根路由配置于'devops'模块 /src/containers/Master.js IsAuthSpin 组件 IsAuthSpin组件用于判断用户是否登录，登录成功会显示IsAuthSpin包裹的内部组件，没有登录不会展示内容。 使用方法： 在Master.js头部引入IsAuthSpin import IsAuthSpin from 'IsAuthSpin'; 在组件return根标签中引入组件，并在组件内部包裹首页内容 ... return ( style: '' } { component: style: '' } { component: style: '' } { component: style: { float: 'right' paddingTop: '6px' paddingRight: '0px' } }]} /> ); ... "},"/docs/development-guide/front/component/commoncomponent/mainmenu":{"url":"docs/development-guide/front/component/commoncomponent/mainmenu","title":"开放master之CommonMenu组件","date":"2017-09-29","body":"开放master之CommonMenu组件 用途 CommonMenu组件集成了所有菜单资源，用于用户选择查看当前菜单，通过管理设置里的菜单配置层级，可动态显示自定义菜单层级。 用法 通过组件头部引入，直接调用 ... import CommonMenu from 'CommonMenu' ... return( ) "},"/docs/development-guide/front/component/commoncomponent/masterheader":{"url":"docs/development-guide/front/component/commoncomponent/masterheader","title":"开放master之MasterHeader组件","body":"开放master之MasterHeader组件 头部标题栏展示 MasterHeader组件用于自定义头部标题栏 如上图头部蓝色部分 使用方法 在组件头部引入MasterHeader ... import MasterHeader from 'MasterHeader'; ... 在组件return中引入该组件 ... return( ... ... ) ... 组件参数 MasterHeader默认携带一个menuChild参数，该参数是一个对象数组 用于给菜单栏添加多个菜单列表 例子： ... style: { padding: '0' } } { component: style: { marginLeft: '14px' padding: '4px 10px 4px 10px' } hoverIf: true } { component: style: { marginLeft: 'calc(2rem - 10px)' marginRight: '-20px' padding: '4px 10px 4px 10px' } hoverIf: true } { component: style: { flex: 1 display: 'block' visibility: 'hidden' } hoverIf: false } { component: hoverIf: false } { component: style: { paddingRight: '2rem' } hoverIf: false }]} /> ... 参数 说明 component 封装的组件，用于按次序放入头部 style 组件的样式 hoverIf 鼠标悬停组件是否出发hover事件 "},"/docs/development-guide/front/component/commoncomponent/menutype":{"url":"docs/development-guide/front/component/commoncomponent/menutype","title":"开放master之MenuType组件","date":"2017-09-29","body":"开放master之MenuType组件 用途 MenuType组件用于选择当前所处的组织或项目 点击不同组织或项目将不同组织项目的服务和选项存储到menuStore里的menu字段中 使用方法 通过组件头部引用后，直接调用 ... import MenuType from 'MenuType'; ... return( ) ... "},"/docs/development-guide/front/component/commoncomponent/newbutton":{"url":"docs/development-guide/front/component/commoncomponent/newbutton","title":"NewButton 按钮组件","date":"2017-02-01","body":"NewButton 按钮组件 用途 NewButton组件为封装的框架统一按钮组件，通过一系列参数配置可实现按钮基础功能效果。 用法 在组件头部引用后直接调用 ... import NewButton from 'NewButton' ... return ( ... ... ) 参数 说明 text 按钮的文字内容 htmlType 按钮的类型 submit/button/reset width 按钮的宽度 height 按钮的高度 className 按钮的class名 默认有三种 color2/color3/color4 style 按钮的样式 onClick 按钮的点击事件 icon 按钮内部的图标 disabled 按钮是否不可点击 loading 按钮是否是加载中 loadingRender 自定义按钮加载样式，不填为默认 "},"/docs/development-guide/front/component/commoncomponent/pageheader":{"url":"docs/development-guide/front/component/commoncomponent/pageheader","title":"Pageheader","date":"2017-02-01","body":"Pageheader 框架目前界面的头部都是统一使用 PageHeader 渲染。 查询展示界面 import PageHeader { PageHeadStyle UnderPageHeadStyle } from 'PageHeader' ... {HAP.getMessage('创建' 'create')} { this.loadRoles(this.state.page) }} style={PageHeadStyle.leftBtn2} > {HAP.getMessage('刷新' 'flush')} ... 编辑新增界面 API 参数 说明 类型 默认值 title 页面的title（必须） Object 无 backPath 返回的页面的路径 String 无 "},"/docs/development-guide/front/component/commoncomponent/remove":{"url":"docs/development-guide/front/component/commoncomponent/remove","title":"Remove 删除弹窗","date":"2017-02-01","body":"Remove 删除弹窗 界面中会大量用到 table 的删除操作 ，此时可以使用 框架中的 Remove 组件。 import Remove from '../../components/Remove'; class App extends React.Component { handleOpen = (id) => { this.setState({ open: true id: id }); }; handleClose = (event) => { this.setState({ open: false }); }; handleDelete = (event) => { this.setState({ open: false }); }; render() { return ( Open a modal dialog ); } } ReactDOM.render( mountNode); API 参数 说明 类型 默认值 open 对话框是否可见 boolean 无 handleCancel 点击取消按钮的回调 function 无 handleConfirm 点击确定按钮的回调 function 无 "},"/docs/development-guide/front/component/commoncomponent/repagination":{"url":"docs/development-guide/front/component/commoncomponent/repagination","title":"RePagination","date":"2017-02-01","body":"RePagination 分页组件 用途 RePagination分页组件为框架统一分页组件，为解决单页面数据量过多，提升用户体验的功能。 用法 在组件头部引用后直接调用 ... import RePagination from 'RePagination'; ... return ( ... { this.setState({ page: page }) this.loadClient(page this.state.params) }} /> ... ) 参数 说明 total 要分页数据的总数 pageSize 一页显示的个数 current 当前选中的页数 onChange 点击页数的回调事件 "},"/docs/development-guide/front/component/commoncomponent/select":{"url":"docs/development-guide/front/component/commoncomponent/select","title":"Select","date":"2017-02-01","body":"Select 下拉选择组件 用途 Select组件为封装的框架统一下拉选择组件，通过统一，简便的配置完成下拉选择功能。 用法 在组件头部引用后直接调用 ... import Select from 'Select' ... handleSelectChange = (value) => { this.setState({ value }) } ... return ( ) ... 参数 说明 data 下拉菜单的数据，code为对应的字段 name为对应的文字 onChange 下拉列表选中事件 回调函数默认带一个参数为选中的code type 可选长下拉框 typ2 可选短下拉框 width 可选下拉框长度 default 默认显示文字 "},"/docs/development-guide/front/component/commoncomponent/userpreferences":{"url":"docs/development-guide/front/component/commoncomponent/userpreferences","title":"开放master之UserPreferences组件","date":"2017-09-29","body":"开放master之UserPreferences组件 用途 UserPreferences组件用于登出用户和设置用户首选项 用法 在组件头部引入后直接调用 ... import UserPreferences from 'UserPreferences'; ... return( ) 参数 说明 imgUrl 传入对应后端返回的头像字段(注意将字段保存在前端store中，避免在个人中心成功上传头像，页面不会动态刷新的问题) "},"/docs/development-guide/front/component/commonfunc/":{"url":"docs/development-guide/front/component/commonfunc/","title":"通用函数","description":"","body":""},"/docs/development-guide/front/component/commonfunc/hap":{"url":"docs/development-guide/front/component/commonfunc/hap","title":"HAP封装函数","body":"HAP封装函数 HAP文件为框架全局注入的封装函数类，项目内部可以直接调用HAP函数算法进行计算操作 function getAccessToken(hash) { if (hash) { const ai = hash.indexOf(ACCESS_TOKEN); if (ai !== -1) { const accessToken = hash.split('&')[0].split('=')[1]; return accessToken; } } return null; } function setAccessToken(token expiresion) { const expires = expiresion * 1000; const expirationDate = new Date(Date.now() + expires); setCookie(ACCESS_TOKEN token { path: '/' expires: expirationDate }); } function removeAccessToken() { removeCookie(ACCESS_TOKEN { path: '/' }); } function languageChange(id) { return ; } function logout() { removeAccessToken(); AppState.setAuthenticated(false); window.location = `${process.env.AUTH_HOST}/logout`; } function getMessage(zh en) { const language = AppState.currentLanguage; if (language === 'zh') { return zh; } else if (language === 'en') { return en; } return false; } function prompt(type content) { switch (type) { case 'success': message.success(content); break; case 'error': message.error(content); break; default: break; } } function handleResponseError(error) { const response = error.response; if (response) { const status = response.status; switch (status) { case 400: { const mess = response.data.message; message.error(mess); break; } default: break; } } } function unauthorized() { HAP.removeAccessToken(); AppState.setAuthenticated(false); window.location = `${HAP.AUTH_URL}`; } // 生成指定长度的随机字符串 function randomString(len = 32) { let code = ''; const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; const maxPos = chars.length; for (let i = 0; i { if (type === 'organization') { permission = { \"name\": `${data}.${value}` \"resourceId\": organid \"resourceType\": type \"organizationId\": organid }; } else if (type === 'project') { permission = { \"name\": `${data}.${value}` \"resourceId\": proid \"resourceType\": type \"organizationId\": organid }; } MenuCode.push(permission); }) const uniqMenuCode = _.uniqBy(MenuCode 'name'); return uniqMenuCode; } function getPermission(data type) { let approve; data[0] && data[0].map(value => { if(value.name) { if (value.name === type) { approve = value.approve; } } }) return approve; } 函数名 说明 getAccessToken 获取url token值 setAccessToken 前端存储cookie token值 removeAccessToken 移除token值 languageChange 多语言 logout 登出系统 getMessage 返回多语言字符串 prompt 提示错误信息 handleResponseError 处理错误响应 unauthorized 没有权限 页面跳转 randomString 生成制定长度的随机字符串 setTheme 获取主题配置 getConfig 获取主配置 使用方法 在页面直接调用HAP.函数名 "},"/docs/development-guide/front/develop_env":{"url":"docs/development-guide/front/develop_env","title":"开发环境配置","description":"","body":"Mac下软件安装 安装工具 NVM VScode或其他代码编辑器安装 Git NVM 安装 打开终端 输入 curl -o- https:/raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 如果没有curl命令，可以通过wget\b命令: wget -qO- https:/raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 在~/.nvm ~/.bash_profile ~/.zshrc ~/.profile ~/.bashrc 其中任意一个文件中加入 export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm 这里修改~/.profile vim ~/.profile 如果没有vim \bapt-get install vim或者直接编辑文件 然后输入source ~/.profile 通过nvm -v\b便可以看到nvm\b版本和相关操作 通过nvm install 6.11.4安装node的6.11.4版本 其他版本相似 详细\bNVM安装使用和系统权限等问题可看文档（通过其他方式\b进行安装） NVM的githubgit 安装 \b安装brew/usr/bin/ruby -e \"$(curl -fsSL https:/raw.githubusercontent.com/Homebrew/install/master/install)\" \b打开终端 输入 brew install git 安装\b\b\bgit命令 VScode或其他代码编辑器安装 在 VScode官网 下载安装 在 WebStorm官网 下载安装 全局安装 Webpack 我们希望能够在系统的任何文件夹中使用 Webpack，使用的方式是通过 Webpack 命令来完成的，这需要我们全局安装 Webpack。这也只需要安装一次，以后每个项目就不需要重新全局安装了。 $ npm install webpack -g 成功安装之后，你应该能够在任何目录中执行 webpack 命令，如果你还没有项目的配置文件的话，应该会看到当前的 Webpack 版本和一个命令的帮助列表。 全局安装 Gulp 在项目中，gulp 用于监视各模块文件的变化和同步相应的文件到boot目录中。 $ npm install gulp -g 安装成功后，在终端里运行 gulp -v 应该可以看到gulp的版本信息。 全局安装 yeoman 在项目中，yeoman 用于自动生成与boot同级的模块目录和文件。 $ npm -g install yo 安装成功后，在终端里运行 yo --version 应该可以看到yeoman的相关信息。 全局安装python 安装python mac系统其实自带了一个python的执行执行环境，用来运行python还行，但是开发可能就不够了，因此我们需要重新安装python。这里有两种方案安装： homebrew brew install python 这个方案比较简单 如果出错的话可以给前面加sudo试试 这个安装的python可能不是最新版. 官网下载安装 大家可以从https:/www.python.org/download下载安装最新版的python 安装比较无脑 一路按下去就OK 缺点是以后升级 卸载都得自己维护. 这两个方法安装的python的位置是不一样的 大家可以用: which python 来查看安装位置.安装完成后在终端中键入python来验证安装是否成功 安装pip brew install pip 源代码安装pip wget https:/bootstrap.pypa.io/get-pip.py sudo python get-pip.py 用python执行刚才获取的脚本 这里sudo可以选择使用 若遇到类似这个报错则必须加sudo: Exception: Traceback (most recent call last): ... OSError: [Errno 13] Permission denied: 'XXX/pip-0.7.2-py2.7.egg/EGG-INFO/dependency_links.txt' Storing debug log for failure in /Users/bilt/.pip/pip.log 安装成功后可以在终端中键入pip来检测 如果不行重启终端后尝试. 克隆代码 可以新建一个 hap-cloud-front 的目录，进入到该目录下，在终端执行 git clone release-1.2.0 https:/xxxx@rdc.hand-china.com/gitlab/HAPCloud/HAPCloudFront.git --recursive 其中 xxxx 是你的工号。 (确保克隆之前设置了 git config --global user.name git config --global user.email ) git submodule 子模块操作 git config 配置操作 运行代码 进入到项目根目录，打开终端，键入bash boot\\structure\\npm.sh boot iam。 安装依赖完成后，执行node_modules/.bin/gulp 如果已全局安装gulp 则可直接执行gulp 不要关闭该终端(在iam等其他模块项目中源文件发生修改时，gulp会自动检测修改并同步)，新开一个git bash同样在该目录下执行 npm start 启动项目，看到如图所示效果说明启动成功 提示: (可以通过 gulp clean 删除所有自动生成的文件 再通过 gulp 来重新生成，再重新启动 npm start ，这样可以解决有时页面未更新的状态) 查看效果 在浏览器中键入 localhost:9090/ Windows下软件安装 安装工具 Node.js 6.3及以上版本 Webstorm 或其他代码编辑器 Git node 安装 在 Node.js官网下载用于Windows平台的安装包 Window 上安装Node.js，你可以采用以下两种方式来安装 Windows 安装包(.msi) 本文实例以v0.10.26版本为例，其他版本类似，安装步骤： 步骤1 :双击下载后的安装包 v0.10.26，如下所示： 步骤2 :点击以上的Run(运行)，将出现如下界面： 步骤3 :勾选接受协议选项，点击next（下一步）按钮: 步骤4 : Node.js默认安装目录为“C:\\Program Files\\nodejs” 你可以修改目录，并点击next（下一步）： 步骤5 :点击树形图标来选择你需要的安装模式 然后点击下一步next（下一步） 步骤6 :点击Install（安装）开始安装Node.js。你也可以点击Back（返回）来修改先前的配置。然后并点击next（下一步）： 安装过程： 点击Finish（完成）按钮退出安装向导。 检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入“cmd” =>输入命令“path”，输出如下结果： PATH=C:\\oraclexe\\app\\oracle\\product\\10.2.0\\server\\bin;C:\\Windows\\system32; C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\; c:\\python32\\python;C:\\MinGW\\bin;C:\\ProgramFiles\\GTK2-Runtime\\lib; C:\\ProgramFiles\\MySQL\\MySQLServer5.5\\bin;C:\\ProgramFiles\\nodejs\\; C:\\Users\\rg\\AppData\\Roaming\\npm 我们可以看到环境变量中已经包含了C:\\Program Files\\nodejs\\ 检查Node.js版本 Windows 二进制文件 (.exe)安装 步骤1 :双击下载的安装包Node.exe，将出现如下界面: 点击Run（运行）按钮将出现命令行窗口： 版本测试 进入node.exe所在的目录，如下所示： 如果你获得以上输出结果，说明你已经成功安装了Node.js。 git 安装 在Git 官网下载对应平台的 Git。 本地执行安装文件， 安装 Git 环境。 Win 在环境变量中系统变量的 path 配置 Git 的环境变量指向 Git安装目录下的/bin。 配置完成后打开 cmd 执行git，有提示则说明环境安装成功。 对于 Windows，安装 Git 以后，你可以在任意目录 右键，Git Bash Here 打开的 MINGW 命令窗口可以执行兼容 linux 系统的命令，如rm，ls等 WebStorm或其他代码编辑器安装 在 WebStorm官网 下载安装 本地执行.exe文件，自行安装 开发准备 npm是Node.js的包管理工具（package manager）。npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。 npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入 npm -v，应该看到类似的输出： C:\\>npm -v 4.1.2 如果直接输入 npm ，你会看到类似下面的输出： C:\\>npm Usage: npm where is one of: 提示 npm 需要跟上命令。这样确保npm正确安装了，能运行就行。 全局安装 Webpack 我们希望能够在系统的任何文件夹中使用 Webpack，使用的方式是通过 Webpack 命令来完成的，这需要我们全局安装 Webpack。这也只需要安装一次，以后每个项目就不需要重新全局安装了。 $ npm install webpack -g 成功安装之后，你应该能够在任何目录中执行 webpack 命令，如果你还没有项目的配置文件的话，应该会看到当前的 Webpack 版本和一个命令的帮助列表。 全局安装 Gulp 在项目中，gulp 用于监视各模块文件的变化和同步相应的文件到boot目录中。 $ npm install gulp -g 安装成功后，在终端里运行 gulp -v 应该可以看到gulp的版本信息。 全局安装 yeoman 在项目中，yeoman 用于自动生成与boot同级的模块目录和文件。 $ npm install yeoman -g 若windows系统中安装失败. 可尝试运行。 $ npm -g install yo 安装成功后，在终端里运行 yo --version 应该可以看到yeoman的相关信息。 全局安装 python 在项目中，python用于执行功能性脚本。 在Windows上安装python 首先 从python的官方网站python.org下载最新的2.7版本 网速慢的请移步国内镜像。 然后，运行下载的MSI安装包，在选择安装组件的一步时，勾上所有的组件: 特别要注意选上pip和Add python.exe to Path 然后一路点\"Next\"即可完成安装。 默认会安装到C:\\Python27目录下，然后打开命令提示符窗口，敲入python后，会出现两种情况: 情况一： 看到上面的画面，就说明python安装成功！ 情况二： 得到一个错误: ‘python’不是内部或外部命令，也不是可运行的程序或批处理文件。 这是因为windows会根据一个path的环境变量设定的路径去查找python.org，如果没找到，就会报错。如果在安装时漏掉了勾选Add python.exe to Path 那就要手动把python.exe所在的路径添加到Path中。 克隆代码 可以新建一个 hap-cloud-front 的目录，进入到该目录下，在终端执行 git clone -b release-1.2.0 https:/xxxx@rdc.hand-china.com/gitlab/HAPCloud/HAPCloudFront.git --recursive 其中 xxxx 是你的工号。 (确保克隆之前设置了 git config --global user.name git config --global user.email ) git submodule 子模块操作 git config 配置操作 运行代码 进入到项目根目录，打开终端，键入bash boot\\structure\\npm.sh boot iam。 安装依赖完成后，执行node_modules/.bin/gulp 如果已全局安装gulp 则可直接执行gulp 不要关闭该终端(在iam等其他模块项目中源文件发生修改时，gulp会自动检测修改并同步)，新开一个git bash同样在该目录下执行 npm run dev 启动项目，看到如图所示效果说明启动成功 提示: (可以通过 gulp clean 删除所有自动生成的文件 再通过 gulp 来重新生成，再重新启动 npm start ，这样可以解决有时页面未更新的状态) 查看效果 在浏览器中键入 localhost:9090/ Lunix下软件安装 安装工具 NVM VScode或其他代码编辑器安装 Git NVM 安装 打开终端 输入 curl -o- https:/raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 如果没有curl命令，可以通过wget\b命令: wget -qO- https:/raw.githubusercontent.com/creationix/nvm/v0.33.6/install.sh | bash 在~/.nvm ~/.bash_profile ~/.zshrc ~/.profile ~/.bashrc 其中任意一个文件中加入 export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm 这里修改~/.profile vim ~/.profile 如果没有vim \bapt-get install vim或者直接编辑文件 然后输入source ~/.profile 通过nvm -v\b便可以看到nvm\b版本和相关操作 通过nvm install 6.11.4安装node的6.11.4版本 其他版本相似 详细\bNVM安装使用和系统权限等问题可看文档（通过其他方式\b进行安装） NVM的github git 安装 \b打开终端 输入 apt-get install git 安装\b\b\bgit命令 VScode或其他代码编辑器安装 在 VScode官网 下载安装 在 WebStorm官网 下载安装 全局安装 Webpack 我们希望能够在系统的任何文件夹中使用 Webpack，使用的方式是通过 Webpack 命令来完成的，这需要我们全局安装 Webpack。这也只需要安装一次，以后每个项目就不需要重新全局安装了。 $ npm install webpack -g 成功安装之后，你应该能够在任何目录中执行 webpack 命令，如果你还没有项目的配置文件的话，应该会看到当前的 Webpack 版本和一个命令的帮助列表。 全局安装 Gulp 在项目中，gulp 用于监视各模块文件的变化和同步相应的文件到boot目录中。 $ npm install gulp -g 安装成功后，在终端里运行 gulp -v 应该可以看到gulp的版本信息。 全局安装 yeoman 在项目中，yeoman 用于自动生成与boot同级的模块目录和文件。 $ npm -g install yo 安装成功后，在终端里运行 yo --version 应该可以看到yeoman的相关信息。 在linux上安装python 直接使用apt-get进行安装 apt-get install python && python-pip 源代码进行安装 准备编译环境 yum groupinstall 'Development Tools' yum install zlib-devel bzip2-devel openssl-devel ncurses-devel 下载python2.7代码包 wget https:/www.python.org/ftp/python/2.7.14/Python-2.7.14.tar.xz 在安装包中有一个README的文件，里面有写如何安装 tar Jxvf Python-2.7.14.tar.xz cd Python-2.7.14 ./configure --prefix=/usr/local/python make && make install 做软链接 ln -s /usr/local/python3/bin/python2.7 /usr/local/bin/python 安装成功后，如果提示：Ignoring ensurepip failure:pip 7.1.2 requires SSL/TLS 这是由于没有安装或升级oenssl yum install openssl-devel 再次重复编译方案python2.7 提示同时成功安装pip-7.12与setuptools 做软链接 ln -s /usr/local/python3/bin/pip /usr/local/bin/pip 升级pip到最新版本 pip install --upgrade pip 克隆代码 可以新建一个 hap-cloud-front 的目录，进入到该目录下，在终端执行 git clone -b release-1.2.0 https:/xxxx@rdc.hand-china.com/gitlab/HAPCloud/HAPCloudFront.git --recursive 其中 xxxx 是你的工号。 (确保克隆之前设置了 git config --global user.name git config --global user.email ) git submodule 子模块操作 git config 配置操作 运行代码 进入到项目根目录，打开终端，键入bash boot\\structure\\npm.sh boot iam。 安装依赖完成后，执行node_modules/.bin/gulp 如果已全局安装gulp 则可直接执行gulp 不要关闭该终端(在iam等其他模块项目中源文件发生修改时，gulp会自动检测修改并同步)，新开一个git bash同样在该目录下执行 npm start 启动项目，看到如图所示效果说明启动成功 提示: (可以通过 gulp clean 删除所有自动生成的文件 再通过 gulp 来重新生成，再重新启动 npm start ，这样可以解决有时页面未更新的状态) 查看效果 在浏览器中键入 localhost:9090/ 前端开发手册 目录划分 开发仿照iam项目结构（推荐通过yo命令自动生成目录结构，节省自动建立目录时间），源文件目录在 iam/src/app/iam ，主要目录结构如下： . ├── package-lock.json ├── package.json ├── src │ └── app │ └── iam │ ├── assets │ │ ├── css │ │ │ ├── Codemirror.less │ │ │ ├── logView.less │ │ │ └── search.less │ │ └── images │ │ ├── gulp.png │ │ ├── react.png │ │ └── webpack.png │ ├── common │ │ ├── IconAntd.js │ │ ├── IconMaterial.js │ │ ├── Icons.js │ │ ├── Permission.js │ │ └── RouteMap.js │ ├── components │ │ ├── ClientSearch.js │ │ ├── Codemirror.js │ │ ├── FullButton.js │ │ ├── MasterHeaderCopys.js │ │ ├── SearchField.js │ │ ├── memberRole │ │ │ ├── PoReRoleCas.js │ │ │ ├── ReRoleCas.js │ │ │ ├── RoleCas.js │ │ │ ├── RoleCasPro.js │ │ │ ├── RoleList.js │ │ │ ├── RolePanels.js │ │ │ └── globalRoleCas.js │ │ ├── menuOld │ │ │ ├── CommonMenu.js │ │ │ ├── LeftIconButton.js │ │ │ ├── MainMenuOne.js │ │ │ ├── MainMenuold.js │ │ │ ├── MenuTitle.js │ │ │ ├── MenuType.js │ │ │ ├── MutilMenu.js │ │ │ ├── ResourceMenu.js │ │ │ ├── RightIconButton.js │ │ │ ├── headerOrg.js │ │ │ └── menu.css │ │ ├── menuType │ │ │ ├── menuType.js │ │ │ └── menuType.less │ │ ├── organization │ │ │ ├── DeploymentTable.js │ │ │ ├── Label.js │ │ │ ├── LabelList.js │ │ │ ├── LabelTable.js │ │ │ ├── OrganizationList.js │ │ │ ├── ServiceDeployment.js │ │ │ ├── ServiceTable.js │ │ │ ├── labelOrganizationList.js │ │ │ ├── reLabel.js │ │ │ └── reLabelTable.js │ │ └── rightTabs │ │ ├── RightTab.js │ │ └── rightTab.less │ ├── config │ │ ├── Menu.yml │ │ └── language │ │ ├── en.yml │ │ └── zh.yml │ ├── containers │ │ ├── Home.js │ │ ├── IAMIndex.js │ │ ├── MasterOld2.js │ │ ├── Masters.js │ │ ├── MastersNew.js │ │ ├── MatersOld.js │ │ ├── global │ │ │ ├── MemberRole │ │ │ │ ├── GlobalIndex.js │ │ │ │ ├── GlobalMemberRole.css │ │ │ │ └── GlobalMemberRole.js │ │ │ ├── Menu │ │ │ │ ├── GlobalMenuPermission.js │ │ │ │ └── MenuIndex.js │ │ │ ├── MenuPermission │ │ │ │ ├── EditRole.js │ │ │ │ ├── MenuPermission.js │ │ │ │ ├── MenuPermissionIndex.js │ │ │ │ └── role.css │ │ │ ├── MenuTree │ │ │ │ ├── InputIcon.js │ │ │ │ ├── MenuDetail.js │ │ │ │ ├── MenuTree.js │ │ │ │ ├── MenuTreeIndex.js │ │ │ │ ├── MenuTreeOld.js │ │ │ │ ├── node.js │ │ │ │ ├── react-ui-tree.js │ │ │ │ ├── theme.less │ │ │ │ └── tree.js │ │ │ ├── adminOrganization │ │ │ │ ├── AdminOrganization.js │ │ │ │ ├── AdminOrganizationIndex.js │ │ │ │ ├── AdminOrganizationLabel.js │ │ │ │ ├── CreateAdminOrganization.js │ │ │ │ ├── EditAdminOrganization.js │ │ │ │ └── LabelOrganization.js │ │ │ ├── excel │ │ │ │ ├── Excel.js │ │ │ │ └── ExcelIndex.js │ │ │ ├── permission │ │ │ │ ├── permission.js │ │ │ │ └── permissionIndex.js │ │ │ ├── role │ │ │ │ ├── CreateRole.js │ │ │ │ ├── EditRole.js │ │ │ │ ├── Role.js │ │ │ │ ├── RoleIndex.js │ │ │ │ └── role.css │ │ │ ├── service │ │ │ │ ├── Service.js │ │ │ │ └── ServiceIndex.js │ │ │ └── token │ │ │ ├── CreateSaasToken.js │ │ │ ├── SaasToken.js │ │ │ └── TokenIndex.js │ │ ├── master.css │ │ ├── organization │ │ │ ├── adminClient │ │ │ │ ├── Client.js │ │ │ │ ├── ClientIndex.js │ │ │ │ ├── CreateClient.js │ │ │ │ └── EditClient.js │ │ │ ├── adminDeploymentLabel │ │ │ │ ├── AdminLabel.js │ │ │ │ ├── AdminLabelIndex.js │ │ │ │ └── AdminLabels.js │ │ │ ├── client │ │ │ │ ├── ClientDetail.js │ │ │ │ ├── ClientIndex.js │ │ │ │ ├── Clients.js │ │ │ │ ├── CreateClient.js │ │ │ │ └── EditClient.js │ │ │ ├── language │ │ │ │ ├── EditLanguage.js │ │ │ │ ├── Language.js │ │ │ │ └── LanguageIndex.js │ │ │ ├── ldap │ │ │ │ ├── EditLDAP.js │ │ │ │ └── LDAPIndex.js │ │ │ ├── lookup │ │ │ │ ├── CreateLookup.js │ │ │ │ ├── EditLookup.js │ │ │ │ ├── Lookup.js │ │ │ │ └── LookupIndex.js │ │ │ ├── memberRole │ │ │ │ ├── MemberRole.js │ │ │ │ ├── MemberRoleIndex.js │ │ │ │ ├── ReMemberRole.css │ │ │ │ ├── ReMemberRole.js │ │ │ │ └── all.css │ │ │ ├── organization │ │ │ │ ├── Organization.js │ │ │ │ └── OrganizationIndex.js │ │ │ ├── passwordPolicy │ │ │ │ ├── PasswordPolicy.js │ │ │ │ ├── PasswordPolicyIndex.js │ │ │ │ └── UpdatePasswordPolicy.js │ │ │ ├── project │ │ │ │ ├── CreateProject.js │ │ │ │ ├── EditProject.js │ │ │ │ ├── Project.js │ │ │ │ └── ProjectIndex.js │ │ │ ├── reProject │ │ │ │ ├── Project.js │ │ │ │ └── project.less │ │ │ ├── user │ │ │ │ ├── CreateUser.js │ │ │ │ ├── EditUser.js │ │ │ │ ├── ModifyPassword.js │ │ │ │ ├── User.js │ │ │ │ ├── UserDetail.js │ │ │ │ ├── UserIndex.js │ │ │ │ └── UserInfo.js │ │ │ └── userGroup │ │ │ ├── CreateUserGroup.js │ │ │ ├── UserGroup.js │ │ │ ├── UserGroupIndex.js │ │ │ └── userGroup.css │ │ └── project │ │ ├── language │ │ │ ├── EditLanguage.js │ │ │ ├── Language.js │ │ │ └── LanguageIndex.js │ │ └── memberRole │ │ ├── MemberRole.js │ │ ├── MemberRoleIndex.js │ │ ├── ReMemberRole.css │ │ ├── ReMemberRole.js │ │ └── all.css │ ├── locale │ │ ├── en.js │ │ └── zh.js │ ├── stores │ │ ├── globalStores │ │ │ ├── GlobalMenuStore.js │ │ │ ├── MemberRoleStore.js │ │ │ ├── MenuTreeStore.js │ │ │ ├── role │ │ │ │ └── RoleStore.js │ │ │ ├── service │ │ │ │ └── ServiceStore.js │ │ │ └── token │ │ │ └── SaasTokenStore.js │ │ ├── organization │ │ │ ├── adminClient │ │ │ │ └── AdminClientStore.js │ │ │ ├── adminOrganization │ │ │ │ ├── AdminOrganizationStore.js │ │ │ │ └── LabelStore.js │ │ │ ├── client │ │ │ │ └── ClientStore.js │ │ │ ├── excel │ │ │ │ └── ExcelStore.js │ │ │ ├── language │ │ │ │ └── LanguageStore.js │ │ │ ├── ldap │ │ │ │ └── LDAPStore.js │ │ │ ├── lookup │ │ │ │ └── LookupStore.js │ │ │ ├── memberRole │ │ │ │ └── MemberRoleStore.js │ │ │ ├── organization │ │ │ │ └── OrganizationStore.js │ │ │ ├── passwordPolicy │ │ │ │ └── PasswordPolicyStore.js │ │ │ ├── project │ │ │ │ └── ProjectStore.js │ │ │ ├── reProject │ │ │ │ └── ProjectStore.js │ │ │ ├── user │ │ │ │ ├── CreateUserStore.js │ │ │ │ └── UserStore.js │ │ │ └── userGroup │ │ │ └── UserGroupStore.js │ │ └── project │ │ └── memberRole │ │ └── MemberRoleStore.js │ └── test │ └── index.test.js ├── tsconfig.json └── yarn.lock containers 存放前端的页面 stores 存放前端页面所需的数据 assets 存放样式表和图片资源 common 存放公共的配置文件 components 存放的是公共的组件 local 存放多语言文件 config 存放yml配置文件 test 存放测试文件 文件命名方式 文件夹命名 统一小写，比如模块 user。同一个模块的组件都放在同一个目录下，比如与 user 相关的 UserIndex EditUser 等文件。 组件命名 采用帕斯卡命名规范，单个单词首字母大写，比如 User 多个单词仅首字母大写，比如 CreatUser "},"/docs/development-guide/front/new":{"url":"docs/development-guide/front/new","title":"开发新功能","description":"","body":"开发新页面 新建文件夹 在 \\iam\\src\\app\\iam\\containers\\organization目录下新建一个新的功能文件夹\\demo及其相关的JS文件： // Demo.js文件 import React { Component } from 'react'; import { withRouter } from 'react-router-dom'; class Demo extends Component { render() { return ( {'Hello it\\'s a demo!'} ); } } export default withRouter(Demo); // DemoIndex.js文件 import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../../util/asyncRouter'; const Demo = asyncRouter(()=>import('./Demo')); const DemoIndex = ({ match }) => ( ); export default DemoIndex; 配置路由 在\\iam\\src\\app\\iam\\containers\\IAMIndex.js文件中配置新建文件的访问路径： ... //异步路由 const DemoIndex = asyncRouter(()=>import('./organization/demo/DemoIndex')); ... ... 注意： 本次demo的访问路径应该为： /iam/demo ，因为在gulp自动生成路由配置时，IAMIndex的路由被映射为iam 配置完路由信息后就可以使用url访问刚刚新建的文件了。 获取后台数据 文件可以被访问后，接下来就是完善界面信息，从后台获取数据。获取数据的方法都写在和文件对应的store文件中。 axios()函数 axios()可以设置全局的配置，例如请求头信息，拦截器等，这样的好处是可以避免重复配置。 常用方法： axios.request(config) axios.get(url[ config]) axios.delete(url[ config]) axios.head(url[ config]) axios.post(url[ data[ config]]) axios.put(url[ data[ config]]) axios.patch(url[ data[ config]]) // store/organization/demo/DemoStore.js文件 import { observable action computed } from 'mobx'; // 该axios是封装过的，设置了请求头信息和响应拦截器 import axios from 'Axios'; import store from 'Store'; // store注解符令组件可以通过DemoStore来找到该store @store('DemoStore') class DemoStore { @observable roles = []; @computed get getRoles() { return this.roles.slice(); } @action setRoles(data) { this.roles = data; } loadRole() { axios.get('uaa/v1/roles?page=0&size=100').then((data) => { if (data) { this.setRoles(data.content); } }); } } const demoStore = new DemoStore(); export default demoStore; 更多关于axios()的相关信息可以参考：https://www.npmjs.com/package/axios 前端数据渲染 拿到后台数据后就可以将数据渲染到界面了，下面将介绍如何将数据渲染到前端界面： 加载DemoStore 修改\\iam\\src\\app\\iam\\containers\\organization\\demo\\DemoIndex.js，添加添加异步加载DemoStore： // DemoIndex.js文件 import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../../util/asyncRouter'; // DemoIndex.js文件中异步加载DemoStore const Demo = asyncRouter(() => import('./Demo') () => import('../../../stores/organization/demo/DemoStore')); const DemoIndex = ({ match }) => ( ); export default DemoIndex; 获取数据并渲染 在 react 的状态处理函数 componentDidMount() 中调用 loadRoles 函数获取数据，此时才真正拿到后台的数据。数据被存储在了组件的 props.DemoStore.roles 中。我们可以在 render() 中（或者在任何 componentDidMount() 函数之后执行的函数中）查看拿到的数据：console.log(this.props.DemoStore.getRoles())。 componentDidMount(){ this.props.DemoStore.loadRoles(); } 更多关于react的信息可以参考： https://hulufei.gitbooks.io/react-tutorial/content/introduction.html 最终的demo界面源码如下： import React { Component } from 'react'; import { Table } from 'antd'; import { observer } from 'mobx-react'; import { withRouter } from 'react-router-dom'; @observer class Demo extends Component { componentDidMount() { this.props.DemoStore.loadRole(); } render() { const columns = [{ title: HAP.languageChange('role.name') dataIndex: 'name' key: 'name' } { title: HAP.languageChange('role.level') dataIndex: 'roleLevel' key: 'roleLevel' } { title: HAP.languageChange('role.description') dataIndex: 'description' key: 'description' } { title: HAP.languageChange('role.serviceName') dataIndex: 'serviceName' key: 'serviceName' }]; return ( ); } } // withRouter添加history支持 export default withRouter(Demo); 开发新模块 新建模块 新建模块 切换到boot/generator-hap的目录下，运行 npm link 。 在项目根目录，运行 yo hap 则会出现需要输入和选择的信息. 注意: 在后面文档中 模块名默认输入的是demo 如果输入的其他的模块名 相应替换便可。 信息如图所示: 此时会自动构建模块的结构，目录结构如图所示: 然后进入到 boot 的目录下 运行 gulp 之后运行 npm start 启动项目 在 localhost:9090/#/demo 便可以查看页面. 其中 输入的模块名 + Index 文件是必须的，该文件的命名规则为 模块名的大写 + Index ，如若模块名为test，则该文件应命名为TESTIndex.js，这是在gulp的配置文件中规定的。 配置路由 在containers 目录中新建test\\Page1.js： import React from 'react'; const Page1 = () => ( This is page1! ); export default Page1; 在containers 目录中新建test\\Page1Index.js 配置Page1的访问路径： //Page1Index.js文件 import React from 'react'; import { Route Switch } from 'react-router-dom'; import asyncRouter from '../../../../util/asyncRouter'; const Page1 = asyncRouter(()=>(import('./Page1'))); const Page1Index=({ match })=>( ); export default Page1Index; 在DEMOIndex.js文件 配置demo模块的路由： import React {Component} from 'react'; import { Route Switch } from 'react-router-dom' import asyncRouter from '../../../util/asyncRouter' class DEMOIndex extends Component { render() { const Home = asyncRouter(() => import('./Home')); const Page1Index = asyncRouter(() => import('./test/Page1Index')); const {match} = this.props; return ( ) } } export default DEMOIndex; 查看效果 在浏览器中键入 http://localhost:9090/#/demo 在浏览器中键入 http://localhost:9090/#/demo/page1 提示: 在新模块中开发新页面与前面在iam中开发新页面的规则和规范完全一致 可以参考iam中开发过程。 第三方文件包安装 如果开发模块需要其他的第三方安装包 可以直接添加在模块package.json文件 在部署集成时 通过执行boot目录下的 npm run preinstall 可以将各个子模块package.json文件合并到boot的package.json文件中 再执行npm install安装项目依赖。 权限组件 通过引入权限组件，可以动态判断用户是否具有此操作权限，并控制页面是否展示功能。 引用 通过组件头部引入权限组件 ... import Permission from 'PerComponent'; ... 调用 调用权限组件需要额外当前组织或项目类型和id参数 在组件头部引入inject组件 导入Appstate ... import { inject } from 'mobx-react' ... @inject('AppState') 在组件适当位置获取当前组织或项目类型type和id 如果当前组件在组织层 ... const { AppState } = this.props; const menuType = AppState.currentMenuType; const organizationId = menuType.id; let type; if (AppState.getType) { type = AppState.getType; } else if (sessionStorage.type) { type = sessionStorage.type; } else { type = menuType.type; } ... 如果当前组件在项目层 ... const { AppState } = this.props; const menuType = AppState.currentMenuType; const organizationId = menuType.organizationId; const projectId = menuType.id; let type; if (AppState.getType) { type = AppState.getType; } else if (sessionStorage.type) { type = sessionStorage.type; } else { type = menuType.type; } ... 在需要调用权限的地方用Permission包裹住要展示的组件，如果有权限则展示，没有则隐藏 ... that} > ... Permission组件的service参数是后台存储的权限code，可以通过不同服务的api接口获取。 项目配置项 配置项详解 为了应对不同开发环境和不同项目需求，可以对hap cloud框架多个配置进行个性化。 配置项文件在项目根目录的config.js文件中。看起来是这样的 const config = { local: false clientId: 'localhost' titlename: 'HAPCloud' favicon: 'a.png' theme: true mainCss: JSON.stringify('boot') Masters: JSON.stringify('boot') Home: JSON.stringify('iam') themeSetting: { antdTheme: { 'primary-color': '#3b78e7' } header: '#3F51B5' backgroundColor: 'white' } server: 'http://gateway.devops.saas.hand-china.com' }; module.exports = config; 参数 说明 local 是否本地开发，如果是true，点击本地开发没有的模块菜单，会跳转到404，否则会跳转已发布的线上域名 clientId 认证成功之后的回调参数，对应后端的回调地址 titlename 标签页名称 favicon 标签页图标 theme 是否开启主题色设定 mainCss 选择哪个模块的主css文件 Masters 选择哪个模块的master.js文件作为入口文件 Home 选择哪个模块的Home.js文件作为Home页 primary-color antd的主体颜色设定 header 头部主题色 backgroundColor 背景色 server 后端的api host地址 新建或覆盖全局配置 在项目根目录右键git bash here 输入yo hap:1.2.0 根据提示 键入各个配置项参数 完成后将会覆盖原有config文件 菜单配置 在Hap Cloud之前开发版本中，前端新加模块和页面，想在菜单中显示需要跟后端沟通各种事宜与配置，大大增加了开发效率与成本。在此版本中，只需要简单配置，菜单数据完全由前端控制。 以iam模块为例. 在模块内部创建config文件夹，目录结构为： ├── language | ├── en.yml | └── zh.yml | └── Menu.yml 文件 说明 language 菜单中英文配置文件夹 en.yml 英文菜单 zh.yml 中文菜单 Menu.yml 菜单配置项 Menu.yml文件内容看起来是这样的: \"iam\": # 此处为最外层的模块服务字段 icon: account_circle # 服务的图标 global: # global层的菜单 - \"role\": # 菜单字段 icon: assignment_ind # 菜单图标 Routes: /iam/role # 菜单对应路由 permission: # 菜单内容具有的权限 - 'hap-user-service.role.update' - 'hap-user-service.role.delete' - 'hap-user-service.role.select' - 'hap-user-service.role.updateRoleWithPermission' - 'hap-user-service.role.createRoleWithPermission' - \"permission\": icon: verified_user Routes: /iam/permission permission: - 'hap-user-service.permission.awesomeSelect' - \"menu-management\": icon: view_list Routes: /iam/menuTree permission: - 'hap-user-service.menu.menuOrganizations' - 'hap-user-service.menu.menuProjects' - 'hap-user-service.menu.menuGlobal' - \"menu-permission\": icon: security Routes: /iam/globalMenuPermission permission: - 'hap-user-service.menu.selectAll' - \"member-role-global\": icon: person_add Routes: /iam/globalMemberRole permission: - 'hap-user-service.member-role-global.delete' - 'hap-user-service.member-role-global.create' - 'hap-user-service.member-role-global.select' - 'hap-user-service.member-role-global.update' - \"service\": icon: next_week Routes: /iam/service permission: - 'hap-user-service.service.self' - 'hap-user-service.service.select' organization: # 组织层的菜单 - \"client\": icon: laptop_mac Routes: /iam/client permission: - 'hap-user-service.client.create' - 'hap-user-service.client.update' - 'hap-user-service.client.delete' - 'hap-user-service.client.select' - \"ldap\": icon: device_hub Routes: '/iam/ldap' permission: - 'hap-user-service.ldap.updateSelf' - 'hap-user-service.ldap.query' - \"password-policy\": icon: verified_user Routes: /iam/password-policy permission: - 'hap-user-service.password-policy.updateSelf' - 'hap-user-service.password-policy.queryOrganization' - \"user\": icon: person Routes: /iam/user permission: - 'hap-user-service.user.updateUser' - 'hap-user-service.user.create' - 'hap-user-service.user.delete' - 'hap-user-service.user.select' - 'hap-user-service.user.query' - \"project\": icon: widgets Routes: /iam/project permission: - 'hap-user-service.project.crete' - 'hap-user-service.project.update' - 'hap-user-service.project.delete' - 'hap-user-service.project.query' - 'hap-user-service.project.select' - \"member-role-organization\": icon: person_add Routes: /iam/origanizationMemberRole permission: - 'hap-user-service.member-role-organization.create' - 'hap-user-service.member-role-organization.delete' - 'hap-user-service.member-role-organization.update' - 'hap-user-service.member-role-organization.select' - \"user-groups\": icon: people Routes: /iam/userGroup permission: - 'hap-user-service.groups.update' - 'hap-user-service.user-groups.insertUserGroups' - 'hap-user-service.groups.delete' project: # 项目层的菜单 - \"member-role-project\": icon: person_add Routes: /iam/projectMemberRole permission: - 'hap-user-service.member-role-project.create' - 'hap-user-service.member-role-project.delete' - 'hap-user-service.member-role-project.select' - 'hap-user-service.member-role-project.update' user: # 个人中心层的菜单 - \"user-info\": icon: more Routes: /iam/user/info permission: - 'hap-user-service.user-info.querySelf' - 'hap-user-service.user-info.updateSelf' - \"password\": icon: grain Routes: /iam/user/modifyPwd permission: - 'hap-user-service.password-policy.queryOrganization' - 'hap-user-service.password-policy.updateSelf' - 'hap-user-service.password.updateSelf' - \"token\": icon: lock Routes: /iam/token permission: - 'hap-user-service.token.querySelf' - 'hap-user-service.token.create' - 'hap-user-service.token.deleteSelf' en.yml文件内容： \"iam\": IAM \"iam.client\": \"Client\" \"iam.ldap\": \"LDAP\" \"iam.member-role-global\": \"Role Assignment\" \"iam.member-role-organization\": \"Role Assignment\" \"iam.member-role-project\": \"Role Assignment\" \"iam.menu-management\": \"Menu Setting\" \"iam.organization\": \"Organization\" \"iam.password\": \"Password Modification\" \"iam.password-policy\": \"Password Policy\" \"iam.permission\": \"Permission\" \"iam.project\": \"Project\" \"iam.role\": \"Role\" \"iam.service\": \"Service\" \"iam.token\": \"Authorization\" \"iam.user\": \"User\" \"iam.user-groups\": \"User Group\" \"iam.user-info\": \"User Information Maintenance\" \"iam.menu-permission\": \"Menu Permission\" 模板为[服务字段].[菜单字段]: [菜单英文名] zh.yml文件内容： \"iam\": \"用户服务\" \"iam.client\": \"客户端\" \"iam.ldap\": \"LDAP\" \"iam.member-role-global\": \"角色分配\" \"iam.member-role-organization\": \"角色分配\" \"iam.member-role-project\": \"角色分配\" \"iam.menu-management\": \"菜单配置\" \"iam.organization\": \"组织\" \"iam.password\": \"密码修改\" \"iam.password-policy\": \"密码策略\" \"iam.permission\": \"权限\" \"iam.project\": \"项目\" \"iam.role\": \"角色\" \"iam.service\": \"服务\" \"iam.token\": \"授权\" \"iam.user\": \"用户\" \"iam.user-groups\": \"用户组\" \"iam.user-info\": \"用户信息维护\" \"iam.menu-permission\": \"菜单权限\" 模板为[服务字段].[菜单字段]: [菜单中文名] 在项目根目录下，执行python .\\boot\\structure\\configAuto.py iam(确保python版本为2.7.x 以及本地安装pyyaml包)脚本。 成功之后在项目根目录会生成config.yml文件。 然后再执行python ./boot/structure/pythonsql.py -i ip地址 -p 端口号 -u \b用户名 -s 密码 在部署时候也可通过环境变量进行传递参数 变量名 说明 DB_HOST 用户名 DB_PORT 端口 DB_USER 用户名 DB_PASS 密码 成功后，会将前端配置的菜单信息插入后端数据库中。 如果要\b显示插入的菜单，需要在全局层的菜单配置下，进行页面操作，将\b数据已有的菜单\b展示在菜单列。 "},"/docs/development-guide/front/problems/":{"url":"docs/development-guide/front/problems/","title":"常见问题","description":"","body":""},"/docs/development-guide/front/problems/problems":{"url":"docs/development-guide/front/problems/problems","title":"npm install失败","date":"2017-02-01","body":"npm install失败 情景 windows系统下由于node版本升级可能导致npm install出现如下图所示错误 解决办法 使用nvm node版本管理工具(推荐) 经过测试，node版本高于8.0.0会出现这个错误。 推荐使用nvm node版本管理工具动态切换node版本来解决这个问题 进入nvm安装链接 下载nvm-setup.zip 安装完毕后，控制台输入nvm -v出现 说明nvm安装成功 在控制台键入nvm install 6.11.0 安装完后键入nvm use 6.11.0 成功将node版本切换到6.11.0 之后再npm install 就不会出现报错信息了 "},"/docs/development-guide/front/problems/undefined":{"url":"docs/development-guide/front/problems/undefined","title":"项目运行出现打包文件未找到","body":"项目运行出现打包文件未找到 情景 由于webpack打包运用HardSourceWebpackPlugin缓存打包机制，在优化打包速度的过程中，同时带来一些不可比避免的问题 如果在拉取新代码，本地编译后，项目控制台显示无法找到打包文件时， 停止编译控制台，在boot目录下执行npm run dev，多数情况会解决这种问题 "},"/docs/development-guide/front/style_specification/":{"url":"docs/development-guide/front/style_specification/","title":"代码和样式编写规范","description":"","body":""},"/docs/development-guide/front/style_specification/code":{"url":"docs/development-guide/front/style_specification/code","title":"代码规范","body":"代码规范 代码规范 采用Alibnb规范 https://github.com/airbnb/javascript 代码注释 新建文件，头部进行注释。 /* author: xxx@hand-china.com time: 2017-2-17 feature: 模块功能 */ class User extends Component{ …… …… } 函数功能注释 //feature:输出变量的值 function inputDome(demo) { console.log(demo); }; eslint规范 项目eslint配置为 { \"root\": true \"parser\": \"babel-eslint\" \"env\": { \"browser\": true \"node\": true \"es6\": true // \"worker\": true } \"parserOptions\": { \"ecmaVersion\": 6 \"sourceType\": \"module\" \"ecmaFeatures\": { \"jsx\": true } } \"plugins\": [ \"react\" ] \"extends\": \"airbnb\" \"rules\": { \"react/jsx-no-bind\": [ \"error\" { \"ignoreRefs\": true \"allowArrowFunctions\": true \"allowBind\": true } ] \"react/prefer-stateless-function\": [\"off\" { \"ignorePureComponents\": true } ] \"jsx-a11y/interactive-supports-focus\": \"off\" \"no-trailing-spaces\": \"off\" \"class-methods-use-this\": \"off\" \"import/no-extraneous-dependencies\": \"off\" \"no-else-return\": \"off\" \"linebreak-style\": \"off\" \"import/extensions\": \"off\" \"import/no-unresolved\": \"off\" \"react/prop-types\": \"off\" \"react/jsx-filename-extension\": \"off\" \"jsx-a11y/href-no-hash\": \"off\" \"react/require-default-props\": \"off\" \"no-console\": \"warn\" \"no-debugger\": \"off\" \"jsx-a11y/anchor-is-valid\": [ \"warn\" { \"aspects\": [ \"invalidHref\" ] } ] } \"globals\": { \"HAP\": true } } "},"/docs/development-guide/front/style_specification/style":{"url":"docs/development-guide/front/style_specification/style","title":"样式规范","date":"2017-02-01","body":"样式规范 本项目相关样式主要参考谷歌云。暂定以下样式规范。 1.页面边距 页面内容内外边距默认制定为：“15px” 2.字体颜色 系统默认字体颜色为：“rgba(0 0 0 0.75)” 3.pageHeader pageHeader中button文内容最好控制在两位，例如：创建客户端修改为创建； 存在两个button情况下：“创建”离“客户端管理”30px，“刷新”离“创建”15px 4.提示 在需要对内容补充说明时使用“Popover”-气泡卡片组件；对图标icon的解释说明用“Tooltip”-提示组件 5.表格相关规范 “Table”组件默认大小使用size=“middle” 两张table之间间距“40px” 不使用table自带分页，分页组件table“15px” table如果可编辑（创建）的字段不超过3个时，使用模态框“Model”组件弹出编辑（创建）页；如果超过三个字段，则新建界面处理 "},"/docs/development-guide/front/technology":{"url":"docs/development-guide/front/technology","title":"技术栈","description":"","body":"Git简明教程 git 基本操作 git 基本操作 开发流程 获取仓库 添加至暂存区 代码commit 回撤到某个版本 分支操作 分支合并 远程分支 开发流程 Note. git commit 信息需注意分类 [FIX] 修复了功能 [MOD] 修改或重构 [ADD] 添加了功能 [DEL] 删除了功能 [IMP] 修改相关配置 获取仓库 git clone url --recursive git clone -b dev url Note: git clone -b 分支名 远程仓库地址 指定远程分支进行克隆 添加至暂存区 git add 文件名 将某文件从工作目录加入暂存区 git add . 添加工作区所有文件到暂存区 git reset HEAD 文件名 撤销某文件提交到暂存区的操作 Note: git reset 若加上--hard参数，将会把工作区的文件也进行改变 代码commit git commit -m \"commit信息\" 此命令将暂存区的文件载入至本地仓库 若commit后发现有文件未加入暂存区，故而没有commit，而不想生成两条commit信息，在没有对工作区修改的情况下可使用: git add 文件名 git commit --amend 这样便可以覆盖提交 回撤到某个版本 git checkout hash码 指定历史版本进行回撤，其效用等同于: git reset --hard hash码 s 若想在确保新文件不消失的情况下回撤到指定版本，则: git reset --soft hash码 分支操作 git branch 列出本地仓库的所有分支 git branch 分支名 新建分支 git checkout 分支名 切换到指定分支 git checkout -b 分支名 等价于 git branch 分支名 git checkout 分支名 分支合并 git merge 分支名 以当前分支合并其它分支 此操作建议在vscode或jetbrain的ide操作，以便于当代码冲突时直接在图形化界面中进行处理。若在命令行操作，则需手工查找冲突文件进行合并。 远程分支 git remote add 远程仓库别名 远程仓库url 添加远程仓库 git push -u origin [本地分支:]远程分支 推送本地分支到远程仓库的某分支 git pull 拉取远程仓库 git pull 等价于git fetch 紧跟 git merge Note. git pull 远程仓库别名 远程仓库分支 Note. git fetch 远程仓库别名 远程分支[:本地分支] Git简明教程 React 本项目使用React与Mobx作为前端框架，React 的核心思想是：封装组件。各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。我们不再需要查找某个 DOM 元素，然后操作 DOM 去更改 Mobx 是 JavaScript 状态容器，提供可预测化的状态管理。 import React { Component PropTypes } from 'react'; import { observer injext } from 'mobx-react'; @inject('AppState') @observer class Dashboard extends Component { constructor(props) { super(props); }; componentDidMount(){}; static propTypes = { }; static contextTypes = { router: PropTypes.object.isRequired }; render() { return ( ) } } function mapStateProps(state) { return { }; } module.exports = Dashboard; React Mobx mobx是一个react的状态管理库，相对于redux，它使用更加简便，可扩展性更强。 mobx 的核心理念是 简单、可扩展的状态管理库。 react 关注的状态(state)到视图(view)的问题。而 mobx 关注的是状态仓库（store）到的状态(state)的问题。 mobx有两个核心的概念 @observable 和 @observer ，它们分别对应的是被观察者和观察者。被观察者和一些操作函数共同组成了store，而观察者时刻观察着这些store的变化，当store内数据变化之后，观察者便会自动更新。 定义一个store class Store { // 被观察者 @observable todos = [{ title: \"完成 Mobx 翻译\" done: false }]; } 定义一个观察者 // 观察者 @observer class TodoBox extends Component { render() { return ( {this.props.store.todos.map(todo => {todo.title})} ) } 获取以及更新值 通常使用@computed get来获取值 使用@action对store内的数据进行修改 class Store { @observable todos = [{ title: \"todo标题\" done: false } { title: \"标题\" done: true }]; @action changeTodoTitle({index title}){ this.todos[index].title = title } @computed get finishedTodos () { return this.todos.filter((todo) => todo.done) } } Mobx相关资料:[http://eyehere.net/2016/mobx-getting-started/] Webpack 本项目选择Webpack作为脚手架 // webpack 配置文件 |-- packjson.js |-- webpack.config.js |-- webpack.dev.js |-- webpack.dev.production.js |-- webpack.dll.config.js |-- webpack.file.js |-- webpack.pro.config.js |-- webpack.production.js // npm相关命令 \"scripts\": { // 整合各个模块package.json \"adjustinstall\": \"node webpack/packjson.js\" //npm start 运行开发环境 \"start\": \"node bin/server\" //清除缓存 重新编译 \"dev\": \"rimraf .cache && npm start\" //npm run build 清除dist生成文件，并运行生产环境 \"build\": \"npm run clean && webpack --config ./webpack/webpack.production.js\" \"devbuild\": \"npm run clean && webpack --config ./webpack/webpack.dev.production.js\" //npm run clean 清除dist生成文件 \"clean\": \"rimraf dist\" //npm run test 运行测试文件 \"test:mocha\": \"./node_modules/.bin/mocha ./src/app/*/test/\" \"eslint\": \"eslint --ext .js src\" \"pre-push\": \"npm run eslint\" } webpack的基础配置 const HtmlWebpackPlugin = require('html-webpack-plugin'); const path = require('path'); const webpack = require('webpack'); const HappyPack = require('happypack'); const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin'); const config = require('./webpack.file'); const ExtractTextPlugin = require('extract-text-webpack-plugin'); const HardSourceWebpackPlugin = require('hard-source-webpack-plugin'); //处理 BashOnWindow 下的打包错误 try { require('os').networkInterfaces() } catch (e) { require('os').networkInterfaces = () => ({}) } module.exports = { entry: { // vendor: [\"react\" \"react-dom\" \"react-router-dom\" \"antd\" \"babel-polyfill\"] app: [ \"babel-polyfill\" 'react-hot-loader/patch' path.resolve(__dirname '../src/index.js') ] } output: { path: path.resolve(__dirname '../dist') filename: 'app/[name]_[hash:8].js' chunkFilename: 'app/chunks/[name].[chunkhash:5].chunk.js' } resolve: { modules: [path.resolve(__dirname '../src') path.resolve(__dirname '../node_modules') 'node_modules' ...config.pathModule] extensions: ['.js' '.json' '.jsx' '.ts' '.tsx' '.less'] alias: { Axios: path.resolve(__dirname '../src/containers/common/axios.js') Store: path.resolve(__dirname '../src/containers/common//store.js') RouteMap: path.resolve(__dirname '../src/app/generate/RouteMap.js') Icons: path.resolve(__dirname '../src/app/generate/Icons.js') Permission: path.resolve(__dirname '../src/app/generate/Permission.js') PerComponent: path.resolve(__dirname '../src/app/iam/components/permission.js') MainCss: path.resolve(__dirname `../src/app/${config.mainCss}/assets/css/main.less`) Masters: path.resolve(__dirname `../src/app/${config.Masters}/containers/Masters.js`) AutoRouter: path.resolve(__dirname '../src/app/generate/AutoRouter.js') MenuType: path.resolve(__dirname '../src/app/iam/components/menu/MenuType.js') MainMenu: path.resolve(__dirname '../src/app/iam/components/menu/MainMenu.js') ResourceMenu: path.resolve(__dirname '../src/app/iam/components/menu/ResourceMenu.js') UserPreferences: path.resolve(__dirname '../src/app/iam/containers/UserPreferences.js') IsAuthSpin: path.resolve(__dirname '../src/app/iam/components/IsAuthSpin.js') MasterHeader: path.resolve(__dirname '../src/app/iam/components/MasterHeader.js') LeftIconButton: path.resolve(__dirname '../src/app/iam/components/menu/LeftIconButton.js') MenuTitle: path.resolve(__dirname '../src/app/iam/components/menu/MenuTitle.js') Config: path.resolve(__dirname '../../config.js') } } module: { loaders: [{ loader: path.resolve(__dirname '../node_modules/happypack/loader.js') }] rules: [{ enforce: \"pre\" test: /\\.(js|jsx)$/ exclude: /node_modules/ loader: 'Happypack/loader?id=eslint' } { test: /\\.(js|jsx)$/ exclude: /node_modules/ loader: 'Happypack/loader?id=babel' } { test: /\\.(tsx?$)/ use: [{ loader: 'Happypack/loader?id=ts' }] exclude: /node_modules/ } { test: /\\.css$/ use: [{ loader: 'Happypack/loader?id=css' }] } { test: /\\.less$/ use: [{ loader: 'style-loader' } { loader: 'css-loader' } { loader: 'less-loader' options: { \"sourceMap\": true \"modifyVars\": config.themeSetting.antdTheme } }] } { test: /\\.(jpe?g|png|gif|svg|ico)/i use: [{ loader: 'file-loader' options: { name: 'img_[hash:8].[ext]' } }] } { test: /\\.(ttf|eot|svg|woff|woff2)/ use: [{ loader: 'file-loader' }] }] } plugins: [ new HappyPack({ id: 'eslint' threads: 1 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'eslint-loader' options: { emitError: true failOnWarning: true failOnError: true } }] }) new HappyPack({ id: 'babel' threads: 3 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'babel-loader' }] }) new HappyPack({ id: 'ts' threads: 1 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'ts-loader' }] }) new HappyPack({ id: 'ts' threads: 1 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'ts-loader' }] }) new HappyPack({ id: 'css' threads: 1 loaders: [{ loader: 'cache-loader' options: { cacheDirectory: path.resolve('.cache') } } { path: 'style-loader' } { path: 'css-loader' }] }) // new HappyPack({ // id: 'less' // threads: 1 // loaders: [{ // path: 'style-loader' // } { // path: 'css-loader' // } { // path: 'less-loader' // options: { // \"sourceMap\": true // \"modifyVars\": config.theme.antdTheme // } // }] // }) // new webpack.DllReferencePlugin({ // context: path.join(__dirname \"webpack\") // manifest: require(\"./dll/vendor-manifest.json\") // }) new webpack.DefinePlugin({ 'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development') 'process.env.AUTH_HOST': JSON.stringify(`${process.env.SERVER}/oauth`) 'process.env.CLIENT_ID': JSON.stringify(`${config.clientid}`) 'process.env.API_HOST': JSON.stringify(`${process.env.SERVER}`) // 'process.env.API_HOST': JSON.stringify('http://gateway.hapcloud.stage.cloud.saas.hand-china.com') }) new HardSourceWebpackPlugin({ cacheDirectory: path.resolve('.cache' 'hard-source/[confighash]') recordsPath: path.resolve('.cache' 'hard-source/[confighash]/records.json') environmentHash: { root: process.cwd() directories: ['node_modules'] files: ['package.json'] } environmentHash: function() { return new Promise(function(resolve reject) { require('fs').readFile(path.resolve(__dirname '../yarn.lock') function(err src) { if (err) {return reject(err);} resolve( require('crypto').createHash('md5').update(src).digest('hex') ); }); }); } }) new HtmlWebpackPlugin({ title: config.titlename template: path.resolve(__dirname '../src/index.template.html') inject: true favicon: path.resolve(__dirname `../../${config.favicon}`) minify: { html5: true collapseWhitespace: true removeComments: true removeTagWhitespace: true removeEmptyAttributes: true removeStyleLinkTypeAttributes: true } }) // new AddAssetHtmlPlugin({ // filepath: path.resolve(__dirname 'dist/dll/dll.vendor.js') // }) ] }; Webpack的相关手册：https://webpack.js.org/ "},"/docs/development-guide/front-environment-deployment":{"url":"docs/development-guide/front-environment-deployment","title":"前端环境部署","date":"2017-10-30","body":"环境安装 HAP Cloud项目具有持续集成，持续部署功能。在项目根目录的.gitlab-ci.yml文件中，写明了项目提交到gitlab之后 gitlab ci执行的一系列打包编译工作，并且使用docker打包新项目镜像到远程地址。然后登录openshift，拉取远程镜像实现持续部署。 这一套流程是不需要本地安装部署环境的，但如果本地开发想要npm run build生成打包文件，并在本地docker build & push一个新的镜像，并自定义deployment.yml文件部署openshift的话，需要在本地进行如下环境安装。 docker安装 Ubuntu安装Docker Docker 支持以下版本的Ubuntu操作系统 Zesty 17.04 Xenial 16.04(LTS) Trusty 14.04(LTS) 使用APT镜像源安装 由于官方源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添 加使用 HTTPS 传输的软件包以及 CA 证书。 $ sudo apt-get update $ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 鉴于国内网络问题，强烈建议使用国内源，下面先介绍国内源的使用。 国内源 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 $ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 然后，我们需要向 source.list 中添加 Docker 软件源 $ sudo add-apt-repository \\ \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。 官方源 $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 安装Docker 更新apt软件包缓存，并安装docker-ce: $ sudo apt-get update $ sudo apt-get install docker-ce 使用脚本自动安装 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚 本，Ubuntu 系统上可以使用这套脚本安装： $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 安装在系 统中。 启动Docker $ sudo systemctl enable docker $ sudo systemctl start docker Ubuntu 14.04请使用以下命令启动： $ sudo service docker start 建立docker用户组 默认情况下， docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于 安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将 需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： $ sudo groupadd docker 将当前用户加入 docker 组： $ sudo usermod -aG docker $USER macOS 安装Docker 系统要求 Docker for Mac 要求系统最低为 macOS 10.10.3 Yosemite，或者 2010 年以后的 Mac 机型，准确说是带 Intel MMU 虚拟化的，最低 4GB 内存。 如果系统不满足需求，可以安装 Docker Toolbox。 安装 使用 Homebrew 安装 Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装： brew cask install docker 手动下载安装 如果需要手动下载，可以通过这个链接下 载：https://download.docker.com/mac/stable/Docker.dmg 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将 那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间可能会询问系 统密码）。 运行 从应用中找到 Docker 图标并点击运行。 运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的 运行状态。 第一次点击图标，可能会看到这个安装成功的界面，点击 \"Got it!\" 可以关闭这个窗 口。 以后每次点击鲸鱼图标会弹出操作菜单。 启动终端后，通过命令可以检查安装后的 Docker 版本。 $ docker --version Docker version 1.12.3 build 6b644ec $ docker-compose --version docker-compose version 1.8.1 build 878cff1 $ docker-machine --version docker-machine version 0.8.2 build e18a919 如果 docker version 、 docker info 都正常的话，可以运行一个 Nginx 服务 器： $ docker run -d -p 80:80 --name webserver nginx 服务运行后，可以访问 http://localhost，如果看到了 \"Welcome to nginx!\"，就说明 Docker for Mac 安装成功了。 Windows 安装Docker 系统要求 Docker CE 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V。 安装 点击以下链接下载 stable 或 edge 版本的 Docker CE。 下载好之后双击 Docker for Windows Installer.exe 开始安装。 运行 在 Windows 搜索栏 输入 Docker 点击 Docker for Windows 开始运行。 Docker CE 启动之后会在 Windows 任务栏出现鲸鱼图标。 等待片刻，点击 Got it 开始使用 Docker CE。 docker使用教程 本地项目打包编译 HAP Cloud项目默认打包编译在boot目录下，查看boot目录下的package.json文件 在build脚本中定义了本地打包编译的步骤。 先删除本地dist文件夹 执行webpack.production.js文件 在终端进入boot目录下执行命令 npm run build 成功之后会在boot目录下生成dist文件夹 docker镜像打包发布 docker镜像仓库登录 在终端键入 docker login -u $REGISTRY_USER -p $REGISTRY_PWD $registry $REGISTRY_USER 为镜像仓库的登录用户名 $REGISTRY_PWD 为镜像仓库的登录密码 $registry 为镜像仓库地址 镜像构建 在上一步构建dist文件夹的目录下 新建一个Dockerfile文件 ### nginx镜像根据实际项目替换 FROM registry.saas.hand-china.com/tools/nginx:stable ### 后端api地址 根据实际项目替换 ENV PRO_API_HOST gateway.hapcloud.test.code.saas.hand-china.com ENV PRO_CLIENT_ID hapcloudfront ### 将dist文件夹添加到nginx镜像html目录下 ADD dist /usr/share/nginx/html ### 将boot/structure/enterpoint.sh 文件放入nginx/html目录下 COPY ./boot/structure/enterpoint.sh /usr/share/nginx/html ### 运行该enterpoint脚本文件 RUN chmod 777 /usr/share/nginx/html/enterpoint.sh ENTRYPOINT [\"/usr/share/nginx/html/enterpoint.sh\"] CMD [\"nginx\" \"-g\" \"daemon off;\"] ### 暴露80端口 EXPOSE 80 boot/structure/enterpoint.sh文件看起来是这样的 #!/bin/bash set -e ### 替换PRO_API_HOST和PRO_CLIENT_ID环境变量 find /usr/share/nginx/html -name '*.js' | xargs sed -i \"s/localhost:8080/$PRO_API_HOST/g\" find /usr/share/nginx/html -name '*.js' | xargs sed -i \"s/localhost:clientId/$PRO_CLIENT_ID/g\" exec \"$@\" 在此目录终端下，运行 ### $docker_Name为镜像名称 根据实际需求更改 docker build -t $docker_Name . 生成$docker_Name命名的镜像 镜像发布 ### $registry为远程镜像地址 根据实际项目更改 docker push $registry "},"/docs/installation-configuration/":{"url":"docs/installation-configuration/","title":"安装与配置","description":"","body":"安装与配置 Choerodon 采用Spring Cloud作为微服务框架，运行在Docker上，以Kubernetes作为容器的编排工具。理论上讲只要服务器资源允许，只要可以运行Kubernetes，就可以在Kubernetes上运行Choerodon。由于Choerodon不是一个单体应用系统，而是一个包含多个微服务的分布式系统，所以安装相对比较复杂，目前，我们不提供基于源码的安装方式，仅提供基于Docker镜像的安装方式。 根据Choerodon的系统架构，Choerodon有两个类型的部署，即开发区和运行区。作为应用的开发平台，可以安装开发区；作为应用的运行平台，可以仅安装运行区； 部署 由于Choerodon存在开发区和运行区的概念，用户可以根据自身的情况来决定采用哪一种方式。为了能够更加清晰的说明Choerodon的部署方式，下面我们将这两种不同的部署方式分别说明。在这之前，我们先来看一下Choerodon的系统服务架构图。关于Choerodon的详细系统架构，请参考系统架构。 其中，运行管理是属于运行区相关的主要服务，敏捷看板、移动开发、开发管理属于开发相关的主要服务。也就是说，我们在选择安装开发区和运行区的时候，可以根据这几个服务来决定。日志服务用来\b用来统一的管理和存储日志并为日后基于的分析提供基础，日志存储在elasticsearch集群中，由fluent-bit收集每个节点上的日志通过fluentd缓存之后发给elasticseach集群，kibana用以查看日志和界面搜索。日志的数据流转和安装文档详见此处。监控服务监控Choerodon的各个服务，确保各个服务和基础组件处在正常的运行中，当其中某一组件运行异常时发送告警提醒。监控服务的核心是Prometheus，Prometheus主动收集各个服务提供的指标信息，经过加工汇总对比预警规则满足条件时发送预警信息给alertmanager，alertmanger可以配置人员邮箱接口等信息实现报警信息按条件发送给不同的人员。关于监控架构和安装文档详见此处。 部署开发区 开发区包含了与开发相关的服务，用户可以使用此作为应用程序的开发平台。整个开发区部署在一个Kubernetes集群上，用户可以使用敏捷看板、移动开发、开发管理属于开发相关服务。开发区最终提交的结果是存储在Gitlab上的代码，当然可以选择是否生成Harbor镜像和相关部署文件。 关于如何安装和配置开发区，请参考开发区安装文档。 部署运行区 运行区包含了与运行相关的服务，用户可以使用此作为应用程序的运行平台。整个开发区部署在一个Kubernetes集群上，用户可以手工的将生成的docker镜像和部署文件，部署到运行区。 关于如何安装和配置运行区，请参考运行区安装文档。 "},"/docs/installation-configuration/components/Gitlab-Runner":{"url":"docs/installation-configuration/components/Gitlab-Runner","title":"Gitlab Runner","description":"","body":"Gitlab-Runner 安装 介绍 Gitlab-Runner 的安装和部署，Gitlab-Runner 是 Gitlab CI 的运行环境。 搭建所需镜像及文件 镜像列表 registry.saas.hand-china.com/tools/gitlab-runner:alpine-v10.1.0 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs.git 前置准备 获取Runner注册Token 此教程注册的Runner属性为共享，若需注册私有Runner，请在Git项目仓库Settings -> CI/CD菜单中获取Token 注册Runner 方式1 docker run -it --rm --entrypoint=bash registry.saas.hand-china.com/tools/gitlab-runner:alpine-v10.1.0 gitlab-runner register # 注册成功后查看生成的token cat /etc/gitlab-runner/config.toml 方式2 docker run -it --rm registry.saas.hand-china.com/tools/gitlab-runner:alpine-v10.1.0 register 注册完成后在Gitlab管理界面获取Runner的token、name和url 修改部署配置 将上一步得到的token、name和url复制出来填写到gitlab-runner-config中的对应位置。 修改cache-pv.yml和maven-pv.yml中nfs服务器地址和路径，并且在nfs的机器上创建这些目录。 运行 # 创建namespace kubectl create ns tools # 部署Runner kubectl apply -f gitlab-runner/ -n tools "},"/docs/installation-configuration/components/Gitlab":{"url":"docs/installation-configuration/components/Gitlab","title":"Gitlab","description":"","body":"Gitlab 安装 介绍 Gitlab 的安装和部署，Gitlab 作为 Choerodon 的代码托管库和分支管理工具。 安装所需镜像及文件 镜像列表 registry.saas.hand-china.com/tools/gitlab-ce:10.2.0-hand 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs.git 前置准备 构建镜像 在使用mysql作为gitlab的数据库时，需要自行安装mysql的依赖和驱动包，使用postgresql则无需构建镜像。进入devops-install-docs/devops/gitlab-ce目录，下文我们将以此目录进行讲解。 # 在镜像仓库中已有也可直接pull docker build -t registry.saas.hand-china.com/tools/gitlab-ce:10.2.0-hand -f . 镜像构建完成后可以使用以下环境变量配置自动备份 参数 | 描述 ---|--- GITLAB_BACKUP_SCHEDULE | 设置自动备份。选项有：disable daily weekly monthly或者 advanced。 默认是disable即禁用；daily为 每天进行备份；weekly为每周星期天备份； monthly为每月1号进行备份；advanced为全自定义，备份时间格式与cron相同。 GITLAB_BACKUP_TIME | 若选择备份策略\b为daily weekly monthly，自动备份的时间格式为 HH:MM，默认是01:00；若选择备份策略\b为advanced，自 动备份的时间格式为 ，默认是00 01 即每天1点进行备份。 GITLAB_BACKUP_SKIP | 选项有：db uploads (attachments) repositories builds (CI build output logs) artifacts (CI build artifacts) lfs (LFS objects)，默认为 repositories GITLAB_BACKUP_EXPIRY | 备份的数据多久（单位：秒）后进行删除。不进行自动删除则设置为0 开启自动备 份功能，默认是7天后进行删除，即604800秒。 使用ConfigMap挂载gitlab.rb配置文件 通过ConfigMap将gitlab.rb文件挂载到/opt/hand/devops/etc/gitlab.rb，运行镜像时就会加载此配置 文件。 创建数据库 登录到数据库创建gitlab用户及数据库: # 创建用户 CREATE USER 'gitlab'@'%' IDENTIFIED BY '******'; # 创建数据库并给gitlab用户授权: CREATE DATABASE gitlabhq_production DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON gitlabhq_production.* TO gitlab@'%'; FLUSH PRIVILEGES; 资源调整 若集群各节点资源充足可跳过此步。 由于gitlab运行需要大量的资源并且要保证其稳定性，不受到其他pod的影响，这里专们调整一台节点部署，这里我们选择了node5(4c16g) 节点准备 # 首先给node5节点打上标签 kubectl label nodes node5 gitlab=\"true\" # 对选好的节点上的pod进行驱赶 kubectl taint nodes node5 gitlab=\"true\":NoSchedule 修改kube-flannel和kube-proxy的配置文件让其可以忍受所有的taint使其能够在node5上运行 # 查看kube-flannel和kube-proxy部署是否在此命名空间下 kubectl get daemonset -n kube-system # 进行修改kube-flannel配置 kubectl edit daemonset kube-flannel -n kube-system # 以下配置请配置在containers属性中，与containers的image属性平级 tolerations: - effect: NoSchedule key: node-role.kubernetes.io/master operator: Exists - effect: NoSchedule operator: Exists # 进行修改kube-flannel配置 kubectl edit daemonset kube-proxy -n kube-system # 以下配置请配置在containers属性中，与containers的image属性平级 tolerations: - effect: NoSchedule key: node-role.kubernetes.io/master operator: Exists - effect: NoSchedule operator: Exists 修改gitlab/deploy.yml文件 # 以下配置请配置在containers属性中，与containers的image属性平级 nodeSelector: gitlab: \"true\" tolerations: - effect: NoSchedule key: gitlab operator: Exists 修改gitlab/redis.yml文件 # 以下配置请配置在containers属性中，与containers的image属性平级 nodeSelector: gitlab: \"true\" tolerations: - effect: NoSchedule key: gitlab operator: Exists 安装 Redis 部署Redis# 首先创建namespaces gitlab: kubectl create ns gitlab kubectl apply -f redis/ -n gitlab gitlab 修改gitlab/ingress.yml文件中的host地址，ip地址访问请忽略： apiVersion: extensions/v1beta1 kind: Ingress metadata: name: gitlab-ingress spec: rules: - host: git.*****************.com http: paths: - backend: serviceName: gitlab servicePort: 80 修改gitlab/pv.yml文件中的nfs的地址和路径。 ... capacity: storage: 50Gi nfs: path: /gitlab/gitlab-data server: 36b864afe1-phv23.cn-shanghai.nas.aliyuncs.com ... 将部署gilab kubectl apply -f gitlab/ -n gitlab 重要： 当容器通过健康检查后，就可以通过域名进行访问了，第一次访问须设置root用户初始密码。若配合Devops平台使用，请进入管理界面创建用户名为SonarQube和Gitlab的两个用户并将其设置为admin用户，并生成私钥保存下来，后面的其他服务搭建会用到它。 配置Gitlab 重要： 此步须等待gitlab容器已运行成功健康检查通过且Hapcloud框架服务也可使用了才进行后续操作 进入容器编辑/etc/gitlab/gitlab.rb文件： # 执行命令进入容器 kubectl get po -n gitlab kubectl exec -it [gilab pod name] -n gitlab bash # 备份原配置文件 mv /etc/gitlab/gitlab.rb /etc/gitlab/gitlab.rb.bak # 编辑配置文件 vi /etc/gitlab/gitlab.rb 重要： 请认真阅读以下配置，修改参数后粘贴进/etc/gitlab/gitlab.rb文件中，若须其他配置请参考gitlab/gitlab.rb gitlab配置文件事例： # `external_url`的值为gitlab的域名地址 external_url 'http://git.digital.saas.carllhw.com' # 设置gitlab的时区为北京时间 gitlab_rails['time_zone'] = 'Beijing' # 设置gitlab邮件启用 和回复的邮箱 gitlab_rails['gitlab_email_enabled'] = true gitlab_rails['gitlab_email_from'] = 'gitlab@choerodon.com' gitlab_rails['gitlab_email_display_name'] = 'Gitlab' gitlab_rails['gitlab_email_reply_to'] = 'noreply@choerodon.com' # 设置用户可以创建组和修改密码 gitlab_rails['gitlab_default_can_create_group'] = true gitlab_rails['gitlab_username_changing_enabled'] = true # 设置默认主题 gitlab_rails['gitlab_default_theme'] = 1 # 启用oauth授权单点登录 gitlab_rails['omniauth_enabled'] = true gitlab_rails['omniauth_allow_single_sign_on'] = ['oauth2_generic'] gitlab_rails['omniauth_auto_sign_in_with_provider'] = 'oauth2_generic' gitlab_rails['omniauth_block_auto_created_users'] = false # oauth2配置 这里配置的是hapcloud的oauth授权，注意修改gateway的地址，回调地址和授权客户端的id(app_id)、secret、和字段映射关系 gitlab_rails['omniauth_providers'] = [ { 'name' => 'oauth2_generic' 'app_id' => 'digital_gitlab' 'app_secret' => 'secret' 'args' => { client_options: { 'site' => 'http://gateway.devops.digital.saas.carllhw.com/' 'user_info_url' => '/oauth/api/user' 'authorize_url'=> '/oauth/oauth/authorize' 'token_url'=> '/oauth/public/gitlab/token' } user_response_structure: { root_path: ['userAuthentication' 'principal'] id_path: ['userAuthentication' 'principal' 'userId'] attributes: { nickname: 'username' name: 'username' email: 'email' } } name: 'oauth2_generic' strategy_class: \"OmniAuth::Strategies::OAuth2Generic\" redirect_url: \"http://git.digital.saas.carllhw.com/users/auth/oauth2_generic/callback\" } } ] # 关闭自带的postgresql postgresql['enable'] = false # 配置mysql连接 gitlab_rails['db_adapter'] = \"mysql2\" gitlab_rails['db_encoding'] = \"utf8mb4\" gitlab_rails['db_collation'] = \"utf8mb4_unicode_ci\" gitlab_rails['db_database'] = \"gitlabhq_production\" gitlab_rails['db_pool'] = 20 gitlab_rails['db_username'] = \"gitlab\" gitlab_rails['db_password'] = \"handhand\" gitlab_rails['db_host'] = \"rds.aliyuncs.com\" gitlab_rails['db_port'] = 3306 # 关闭自带的redis redis['enable'] = false # 配置redis连接 gitlab_rails['redis_host'] = \"gitlab-redis-svc\" gitlab_rails['redis_port'] = 6379 # gitlab邮箱服务器设置 gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = \"smtp.mxhichina.com\" gitlab_rails['smtp_port'] = 465 gitlab_rails['smtp_user_name'] = \"git.sys@carllhw.com\" gitlab_rails['smtp_password'] = \"Rdchandhand123\" gitlab_rails['smtp_domain'] = \"smtp.mxhichina.com\" gitlab_rails['smtp_authentication'] = \"login\" gitlab_rails['gitlab_email_from'] = \"git.sys@carllhw.com\" gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['smtp_tls'] = true # 关闭监控相关功能 prometheus['enable'] = false node_exporter['enable'] = false # 解密您的加密CI变量的秘钥 gitlab_rails['otp_key_base'] = \"long-and-random-alphanumeric-string\" gitlab_rails['db_key_base'] = \"long-and-random-alphanumeric-string\" gitlab_rails['secret_key_base'] = \"long-and-random-alphanumeric-string\" 使配置生效 # 停止启动的服务 gitlab-ctl stop # 生效配置 gitlab-ctl reconfigure # 启动服务 gitlab-ctl start 创建oauth客户端 通过gateway的swagger界面，选择用户服务client的API创建: # 回调地址为gitlab将要访问的地址 { \"name\": \"digital_gitlab\" \"resourceIds\": \"default\" \"secret\": \"secret\" \"scope\": \"default\" \"authorizedGrantTypes\": \"password implicit client_credentials authorization_code refresh_token\" \"webServerRedirectUri\": \"http://git.************.com\" \"autoApprove\": \"default\" } 优化 如果在gitlab中需要使用emoji图标(比如在issue、comment、merge request区域) 那么需要做以下配置: 首先，需要对数据库表编码和行类型进行转换，如果一开始创建表时就使用utf8mb4格式，会造成初始化时列的长度超出限制的错误(767/4)。所以先使用utf8初始化完成后，再用sql进行转换。 修改数据库参数 # Aliyun RDS通过界面控制台修改: innodb_large_prefix = ON # 自建Mysql执行以下sql set global innodb_file_format = `BARRACUDA`; set global innodb_large_prefix = `ON`; 执行下边sql 并复制返回结果执行，然后就会将表的行格式设置为动态类型: SELECT CONCAT( 'ALTER TABLE `' TABLE_NAME '` ROW_FORMAT=DYNAMIC;' ) AS 'Copy & run these SQL statements:' FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \"gitlabhq_production\" AND TABLE_TYPE = \"BASE TABLE\" AND ROW_FORMAT != \"Dynamic\"; 继续执行sql，并复制返回结果执行，把表的编码进行转换: SELECT CONCAT( 'ALTER TABLE `' TABLE_NAME '` CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;' ) AS 'Copy & run these SQL statements:' FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = \"gitlabhq_production\" AND TABLE_COLLATION != \"utf8mb4_general_ci\" AND TABLE_TYPE = \"BASE TABLE\"; 这样在gitlab里就可以使用emoji图标了。对于postgresql是可以直接使用utf8mb4编码的。而在mysql5.7中可以将ROW_FORMAT = \"Dynamic\"这一值设置为默认属性，因此可能不会遇到这个问题。 "},"/docs/installation-configuration/components/Harbor":{"url":"docs/installation-configuration/components/Harbor","title":"Harbor","description":"","body":"Harbor 安装 介绍 Harbor 的安装和配置，Choerodon 使用 Harbor 作为私有镜像库。 安装所需镜像及文件 镜像列表 registry.saas.hand-china.com/harbor/harbor-adminserver:v1.2.0 registry.saas.hand-china.com/harbor/harbor-jobservice:v1.2.0 registry.saas.hand-china.com/harbor/harbor-db:v1.2.0 registry.saas.hand-china.com/harbor/registry:2.6.2-photon registry.saas.hand-china.com/harbor/harbor-ui:v1.2.0 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs.git 使用外部数据库 如果使用自带数据库请忽略此步骤。 创建一个harbor用户，创建registry数据库，并授予harbor用户权限 # 创建用户 CREATE USER 'harbor'@'%' IDENTIFIED BY 'handhand'; # 请注意数据库名称一定不能改变 CREATE DATABASE registry DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON registry.* TO harbor@'%'; FLUSH PRIVILEGES; 将devops-install-docs/devops/harbor/registry.sql文件内容放到数据库执行初始化表结构。 安装Harbor 生成配置 进入devops-install-docs/devops/harbor目录，下文我们将以此目录进行讲解。搭建后若使用https进行访问，请先阅读访问。 修改harbor.cfg的参数配置，主要包括harbor的访问地址 (hostname)，harbor的管理员密码(harbor_admin_password)和其他配置，参考配置如下: 其他参数如果不清楚其用法请不要修改。 hostname = register.choerodon.com harbor_admin_password = Harbor12345 # 如果你使用的是外部数据库还需要修改以下参数为自己数据库实例相对于的值 db_host = mysql db_port = 3306 db_user = root 根据配置文件生成每个服务对应的configMap文件 生成的configMap文件位于每个service对应的文件夹下，并且会在kubernetes目录下生成一个 ingress.yaml文件。 python kubernetes/k8s-prepare 修改持久存储的地址 在kubernetes/pv文件加下有对应三个服务的pv和pvc的yaml文件。请根据各自的需求修改对应*.pv.yaml 文件的配置。 # 三对pv和pvc文件分别对应的服务是： log.pv.yaml log.pvc.yaml ===》 jobservice 存储日志文件 registry.pv.yaml registry.pvc.yaml ===》 registry 存储镜像文件 storage.pv.yaml storage.pvc.yaml ===》 mysql mysql数据库的存储文件 注意: 如果使用已有数据库实例，则不需要修改storage.pv.yaml的配置，并且在后面的部署操作中，有关mysql的部署操作请全部忽略。 开始安装 创建命名空间harbor： kubectl create ns harbor 部署： # 创建jobservice的存储 kubectl apply -f kubernetes/pv/log.pv.yaml kubectl apply -f kubernetes/pv/log.pvc.yaml -n harbor # 创建registry的存储 kubectl apply -f kubernetes/pv/registry.pv.yaml kubectl apply -f kubernetes/pv/registry.pvc.yaml -n harbor # 创建mysql存储【使用已有数据库实例请略过】 kubectl apply -f kubernetes/pv/storage.pv.yaml kubectl apply -f kubernetes/pv/storage.pvc.yaml -n harbor # 部署mysql【使用已有数据库实例请略过】 kubectl apply -f kubernetes/mysql -n harbor # 部署镜像服务(registry) kubectl apply -f kubernetes/registry -n harbor # 部署harbor管理服务(adminserver) kubectl apply -f kubernetes/adminserver -n harbor # 部署日志服务(jobservice) kubectl apply -f kubernetes/jobservice -n harbor # 部署前端(ui) kubectl apply -f kubernetes/ui -n harbor 查看所有pod的运行状态： kubectl get po -n harbor 访问 使用HTTP进行访问 请直接部署ingress kubectl apply -f kubernetes/ingress.yaml -n harbor 待所有pod的状态都为Running并且全部READY，表示已部署成功。可以使用在第一步中配置的hostname在浏览器中进行访问。 在需要对harbor使用docker命令进行pull和push操作时需要在相应的机器docker配置中添加 insecure-registries参数，该值为harbor.cfg文件中配置的hostname的值。 可以根据操作系统和docker版本不同在对应位置的配置添加参数(请自行查阅)，比如:在centos7.X上配置，只需要在/etc/docker/daemon.json文件中添加以下参数: # 示例(仅供参考) { \"exec-opts\": [\"native.cgroupdriver=systemd\"] \"storage-driver\": \"overlay\" \"log-driver\": \"json-file\" \"log-opts\": { \"max-size\": \"10m\" } \"insecure-registries\": [\"register.jaywoods.com\"] } 注意： 修改之后需要重启docker才能生效。 systemctl daemon-reload && systemctl restart docker 使用HTTPS进行访问 使用kube-lego申请证书 如果集群中部署了kube-lego申请证书，请编辑 ingress.yaml，添加secretName属性到spce.tls.hosts中。[kube-lego] (https://github.com/jetstack/kube-lego)会自动申请证书，部署成功后就可使用https进行访问了。 \b1.为ingress添加注解kubernetes.io/tls-acme: \"true\" metadata: annotations: kubernetes.io/tls-acme: \"true\" 2.为ingress添加添加spec.tls属性及其值 ` spec: tls: hosts: register.jaywoods.com secretName: harbor-cert ` 注意： 这里的secretName值在当前命名空间是唯一的，且secretName值是必需的（即使这个secret对象不存在，它将由kube-lego创建） 编辑完成后进行部署 kubectl apply -f kubernetes/ingress.yaml -n harbor 手动申请证书 如果单纯的在ingress这里配置一个可信任证书的secret是不行的。在docker的操作时registry会进行证书校验， 也就是说ingress这配置的证书要与registry.cm.yaml里配置的能够匹配，否则就会报错。 第一步：通过certbot生成证书(此方法每次更新只有3个月有效时间，若直接购买请跳过此步)。 使用certbot生成证书需要注意几点: 1.将域名解析到需要执行生成证书命令的机器上 2.确保该机器上的80和443端口不能被占用 3.该机器上已装有docker环境 # 执行以下命令，注意更换域名地址 docker run --rm -ti \\ --network host \\ -v /etc/letsencrypt:/etc/letsencrypt \\ -v /var/lib/letsencrypt:/var/lib/letsencrypt \\ certbot/certbot:v0.19.0 \\ certonly --standalone \\ -d example.choerodon.com # 过程中提示输入邮箱，完成之后证书在/etc/letsencrypt目录下 第二步：修改harbor参数配置，并生成configmap 这里需要修改除了生成配置中的变量还有以下参数: ui_url_protocol = https # 配置证书路径(修改为自己的证书路径) ssl_cert = /root/example.choerodon.com/fullchain.pem ssl_cert_key = /root/example.choerodon.com/privkey.pem 然后就使用命令生成configmap文件: python kubernetes/k8s-prepare 更新部署 # 部署镜像服务(registry) kubectl apply -f kubernetes/registry -n harbor # 部署harbor管理服务(adminserver) kubectl apply -f kubernetes/adminserver -n harbor # 部署日志服务(jobservice) kubectl apply -f kubernetes/jobservice -n harbor # 部署前端(ui) kubectl apply -f kubernetes/ui -n harbor 最后根据证书的内容生成一个secret: # 参数 --key 后指定证书私钥的路径 # 参数 --cert 后指定证书的路径 kubectl create secret tls harbor-cert --key privkey.pem --cert fullchain.pem -n harbor 修改ingress配置，添加secretName属性值: kubectl edit ingress harbor -n harbor # 参考示例如下 ... rules: - host: example.choerodon.com http: paths: - backend: serviceName: ui servicePort: 80 path: / - backend: serviceName: registry servicePort: repo path: /v2 - backend: serviceName: ui servicePort: 80 path: /service tls: - hosts: - example.choerodon.com secretName: harbor-cert "},"/docs/installation-configuration/components/SonarQube":{"url":"docs/installation-configuration/components/SonarQube","title":"SonarQube","description":"","body":"SonarQube 安装 介绍 SonarQube 的安装和配置，Choerodon 使用 SonarQube 作为代码质量的检查工具。 安装所需镜像及文件 镜像列表 registry.saas.hand-china.com/library/postgres:latest registry.saas.hand-china.com/library/sonarqube:6.5-alpine 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs.git 前置准备 进入devops-install-docs/devops/middleware/sonarqube目录，下文我们将以此目录进行讲解。 修改各目录下pv.yml的nfs地址和路径 安装 # pv修改后再自行以下命令 kubectl apply -f postgresql/ -n tools kubectl apply -f sonarqube/ -n tools 集成Gitlab 网络好 使用admin用户登录SonarQube，安装gitlab插件 网络不好 由于网络的原因，可能gitlab插件安装不了会提示错误。请使用以下方式安装。 下载此jar包 https://github.com/gabrie-allaigre/sonar-gitlab-plugin/releases/download/2.1.0/sonar-gitlab-plugin-2.1.0.jar 将jar包拷贝到SONARQUBE_HOME/extensions/plugins目录中。 重启SonarQube生效 接下来按照图片提示配置这两个选项 参考链接 "},"/docs/installation-configuration/components/":{"url":"docs/installation-configuration/components/","title":"组件","description":"","body":"安装其他组件 介绍Choerodon其他组件的安装。 Gitlab 是一个用于仓库管理系统的开源项目，Choerodon使用Gitlab作为代码托管仓库。 Gitlab Runner 是Gitlab提供的CI工具，作为Choerodon的持续集成工具使用。 Harbor 是开源镜像库，Choerodon通过其搭建私有企业镜像库。 SonarQube 是开源代码质量检查工具。 日志 主要用于服务器、系统和应用的日志收集和管理，Choerodon集成了多个系统日志工具集。 监控 主要用于主机、系统、应用等监控，Choerodon集成了多个系统监控工具集。 "},"/docs/installation-configuration/components/日志":{"url":"docs/installation-configuration/components/日志","title":"日志","date":"2018-03-09T14:14:43+08:00","description":"","body":"日志安装 日志服务聚集各个服务日志通过elasticsearch存储和提供高可用，高效率的日志查询和聚合服务，日志服务和监控服务相互补充构建一个完整的监控日志分析服务，对集群和服务的健康稳定运行，常规业务分析起着不可忽视的作用。 日志架构图 日志架构图如下 fluent-bit以daemonSet的方式运行在每一个节点上，并且绑定日志目录，fluent-bit收集日志同时调用kubernetesApi获取日志所属的容器信息随后加工压缩日志。经过加工后的日志发送到fluentd上，fluentd会进一步缓冲日志并发送到elasticsearch集群中。Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力。若要查看日志可以在kibana中查看。 为什么使用jsonfile存储日志： docker存储日志有多种形式，其中一种为fluentd可以直接发送给fluentd，看上去fluent-bit变得有点多余，但是我们考虑到了一点就是多行日志的处理问题，如果docker直接发送给fluentd则日志的顺序就会存在错乱的风险，处理多行日志就会变得异常\b复杂，而使用文件存储则可以安照顺序依次读取日志，判断处理多行日志。 安装 安装前准备 确认docker使用json-file作为日志存储方式 确认docker已经限制了日志文件的大小 确认docker限制的日志文件数量不小于2 使用我们的部署脚本部署kubernetes集群已默认配置了上述选项无需再次配置 下载安装脚本 $ wget https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs/raw/master/devops/monitoring/install_logging.sh 编辑参数 $ vim install_logging.sh 参数说明 参数 说明 默认值 NAMESPACE 日志服务所在的命名空间 logging REQUEST_MEMORY \b每个es\b节点请求的内存大小 4Gi LIMIT_MEMORY 每个es\b节点限制的内存大小 8Gi SCRAPE_INTERVAL prometheus\b收集指标间隔 10s SCRAPE_TIMEOUT prometheus\b收集指标超时 10s BASE_URL 服务的基础地址，如想要elasticsearch的地址为elasticsearch.example.com则BASE_URL的值应该设置为example.com NFS_SERVER 如果需要nfs存储日志数据则需要制定nfs服务器地址 运行前注意事项 脚本\b默认支持主机\b存储和nfs\b存储，如果需要使用glusterfs或者ceph请手动搜索create_pv_datalocaltion方法并\b将如下文本中关于nfs的内容替换成所需的存储方式 --- apiVersion: v1 kind: PersistentVolume metadata: labels: pv: ${name} name: ${name} spec: accessModes: - ReadWriteMany capacity: storage: ${storage_size}Gi nfs: path: ${dataPath} server: ${NFS-SERVER} 运行脚本 $ sh install_logging.sh 根据提示输入相关参数 - Do you want use pvc to storage elasticsearch/kibana data (default is no) yes/no： 是否使用pvc存储elasticsearch/kibana数据 - which node you run with elasticsearch/kibana 选择\b\b\belasticsearch/kibana可以运行的节点，根据提示的节点选择如`node1 node3` - what nfs size do you want assign to elasticsearch (unit Gi) 如果使用\bpvc，输入分配给prometheus的空间大小单位是Gi 查看服务 服务 地址 elasticsearch elasticsearch.example.com kibana kibana.example.com "},"/docs/installation-configuration/components/监控":{"url":"docs/installation-configuration/components/监控","title":"监控","description":"","body":"监控安装 提供全方位的监控服务，包括基础组件监控，各微服务运行情况监控，资源监控和智能预警。 监控架构图 架构图如下 监控以Google Prometheus为核心展开，Prometheus作为一个开源的监控和预警系统自2012年开始就被许多公司和机构使用，越来越多的项目也开始原生支持Prometheus收集性能指标。Prometheus主动收集性能指标压力集中在监控服务器上，而不会占用应用服务器过多的资源。在监控主机上，node-exporter为prometheus提供了主机的内存、CPU、网络和磁盘等相关信息，在容器监控上，kubernetes内置的cAdvisor提供了容器的各项指标，同样的内存、CPU、网络和磁盘的信息也一应俱全，kube-stat-metrics提供了集群中部署信息，如容器名称，容器标签等。在JAVA微服务的监控上，微服务使用micrometer为prometheus提供JAVA微服务的指标如线程数，消耗内存，请求数等。当微服务部署到集群后Prometheus能够自动发现并收集其提供的信息。其他各种服务也可以通过编写exporter为Prometheus提供指标。当配置报警规则之后Prometheus会将报警信息发送给alertmanager，alertmanager根据预先配置好的邮件地址或者短信接口发送报警信息。 安装 下载安装脚本 $ wget https://rdc.hand-china.com/gitlab/rdc_hip/devops-install-docs/raw/master/devops/monitoring/install_monitoring.sh 编辑参数 $ vim install_monitoring.sh 参数说明 参数 说明 默认值 NAMESPACE 监控服务所在的命名空间 monitoring REQUEST_MEMORY prometheus请求的内存大小 4Gi LIMIT_MEMORY prometheus限制的内存大小 8Gi SCRAPE_INTERVAL prometheus收集指标间隔 10s SCRAPE_TIMEOUT prometheus收集指标超时 10s BASE_URL 服务的基础地址，如想要prometheus的地址为prometheus.example.com则BASE_URL的值应该设置为example.com NFS_SERVER 如果需要nfs存储监控数据则需要制定nfs服务器地址 运行前注意事项 脚本默认支持主机存储和nfs存储，如果需要使用glusterfs或者ceph请手动搜索create_pv_datalocaltion方法并将如下文本中关于nfs的内容替换成所需的存储方式。 --- apiVersion: v1 kind: PersistentVolume metadata: labels: pv: ${name} name: ${name} spec: accessModes: - ReadWriteMany capacity: storage: ${storage_size}Gi nfs: path: ${dataPath} server: ${NFS-SERVER} 运行脚本 $ sh install_monitoring.sh 根据提示输入相关参数： - Do you want use pvc to storage prometheus/grafana data (default is no) yes/no： 是否使用pvc存储prometheus/grafana数据 - which node you run with prometheus/grafana 选择prometheus/grafana可以运行的节点，根据提示的节点选择如`node1 node3` - what nfs size do you want assign to prometheus (unit Gi) 如果使用\bpvc，输入分配给prometheus的空间大小单位是Gi 查看服务 服务 地址 grafana grafana.example.com prometheus prometheus.example.com alertmanager alertmanager.example.com "},"/docs/installation-configuration/deployment-install-guide":{"url":"docs/installation-configuration/deployment-install-guide","title":"运行区安装","description":"","body":"运行区安装 本章节介绍运行区的安装。 运行区服务 当前Choerodon运行区各服务版本信息如下： 服务名 服务组 服务代码 版本号 注册服务 com.choerodon.choerodoncloud choerodon-register-server 1.2.0 管理服务 com.choerodon.choerodoncloud choerodon-manager-service 1.2.0 配置服务 com.choerodon.choerodoncloud choerodon-config-server 1.2.0 用户服务 com.choerodon.choerodoncloud choerodon-user-service 1.2.11 授权服务 com.choerodon.choerodoncloud choerodon-oauth-server 1.2.1 网关服务 com.choerodon.choerodoncloud choerodon-api-gateway 1.2.2 消息服务 com.choerodon.choerodoncloud choerodon-event-store-service 1.2.1 框架服务 com.choerodon.choerodoncloud choerodon-framework-service 1.2.1 用户管理服务 com.choerodon.choerodoncloud choerodon-user-admin-service 1.2.0 K8S消息收集 com.choerodon.devops k8s-informer V0.1.1 K8S服务 com.choerodon.devops devops-kubernetes-service 1.1.0 文件服务 com.choerodon.devops choerodon-file-service 1.1.0 部署服务 com.choerodon.devops devops-deploy-service 1.1.6 数据整合服务 com.choerodon.insight data-intergration-service 1.0.0 数据提供服务 com.choerodon.insight data-provide-service 1.0.1 数据操作服务 com.choerodon.insight data-operation-service 1.0.0 移动服务 com.choerodon.mobile mobile-cloud-service 1.0.0 框架前端 com.choerodon.choerodoncloud choerodoncloud-front 1.2.2 部署前端 com.choerodon.devops deploy-front 1.1.5 监控前端 com.choerodon.insight monitor-front 1.0.0 移动前端 com.choerodon.mobile mobile-front 1.0.0 硬件需求 存储 存储空间的大小主要取决于你将存储的docker image以及使用文件服务时上传的文件大小。但是你应该考虑多留一些空间用来存储备份。 除此之外你还可以挂在一个支持NFS的分卷，比如NAS、 SAN、AWS、EBS。 CPU 将所有服务运行起来，一定要注意当前集群内至少有8C可用。 内存 安装使用Choerodon运行区所有应用需要至少50GB可用内存(RAM + Swap)! 由于操作系统和其他正在运行的应用也会使用内存， 所以安装Choerodon运行区前一定要注意当前集群内至少有50GB的可用内存. 少于50GB内存会导致在部署后Pod一直处于等待状态或者在使用中出现各种不可预知的问题。 Kubernetes v1.8.5 搭建Devops平台时，默认已经搭建好K8S集群，若未搭建请移步K8S集群搭建 依赖组件 名称 版本 Harbor(可选) 1.1.1 监控 1.0.0 日志 1.0.0 安装所需软件及文件 在要执行ansible脚本的机器上安装ansible运行需要的环境以及git。 sudo yum install -y epel-release && \\ sudo yum install -y ansible git 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-ansible.git 使用NFS存储 若选择其他存储方式或已有NFS Server请跳过此步。 复制搭建K8S集群时所用到的inventory/hosts文件内容到本项目的inventory/hosts文件中。添加[nfs]分区，该分区只能添加一个节点，[nfs]分区节点即为提供nfs服务的节点。 修改inventory/vars.yml文件，将不需要部署的资源enable置为false，这里会自动创建所需目录；请设置nfs.ip属性，默认为指定节点ipv4地址；计算包含所有各节点的子网掩码将值赋予nfs.client_net，默认为\"*\"即所有主机都可以访问。 执行以下命令搭建nfs ansible-playbook -i inventory/hosts -e @inventory/vars.yml nfs-server.yml 执行安装步骤 修改inventory/hosts文件，其中[run]分区只能添加一个节点且该节点可以使用kubectl命令。 确认所要部署的资源(mysql、rabbitmq、redis、zookeeper、kafka，minio)，若资源已有不需要部署，请在inventory/vars.yml文件中将资源enable置为false。 执行以下命令搭建运行区所需资源。 ansible-playbook -i inventory/hosts -e @inventory/vars.yml dev-resource.yml 手动部署监控参考链接 手动部署日志参考链接 创建运行区所需数据库 若使用容器运行的mysql，可以参照以下命令进入容器创建数据库 查看pod名称，进入容器 kubectl get po -n devops kubectl exec -it [PodName] -n devops bash 进入mysql命令行 mysql -uroot -p${MYSQL_ROOT_PASSWORD} 创建choerodoncloud用户及数据库 CREATE USER 'choerodoncloud'@'%' IDENTIFIED BY 'choerodonchoerodon123'; CREATE DATABASE choerodon_user_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_manager_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_event_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_framework_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON choerodon_user_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_manager_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_event_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_framework_service.* TO choerodoncloud@'%'; CREATE DATABASE devops_deploy_service DEFAULT CHARACTER SET utf8; CREATE DATABASE mobile_cloud_service DEFAULT CHARACTER SET utf8; CREATE DATABASE devops_operation_portal DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON devops_deploy_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON mobile_cloud_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON devops_operation_portal.* TO choerodoncloud@'%'; FLUSH PRIVILEGES; 重要： 注释掉inventory/config.yml文件中第2109行到文件最后一行的配置，这些配置为开发区所需的，若未注释那么系统搭建完成后会将开发区的信息扫描进去，所以注释掉它。 修改inventory/config.yml文件中资源区域维护好相应参数。 运行脚本搭建部署端 ansible-playbook -i inventory/hosts -e @inventory/config.yml run.yml "},"/docs/installation-configuration/development-install-guide":{"url":"docs/installation-configuration/development-install-guide","title":"开发区安装","description":"","body":"开发区安装 由于开发区各服务也需要进行更新和管理，所以将部署开发区和运行区的所有服务。本文以CentOS为例进行讲解。 本章节介绍开发区的安装。 开发区服务 当前Choerodon开发区各服务版本信息如下： 服务名 服务组 服务代码 版本号 注册服务 com.choerodon.choerodoncloud choerodon-register-server 1.2.0 管理服务 com.choerodon.choerodoncloud choerodon-manager-service 1.2.0 配置服务 com.choerodon.choerodoncloud choerodon-config-server 1.2.0 用户服务 com.choerodon.choerodoncloud choerodon-user-service 1.2.11 授权服务 com.choerodon.choerodoncloud choerodon-oauth-server 1.2.1 网关服务 com.choerodon.choerodoncloud choerodon-api-gateway 1.2.2 消息服务 com.choerodon.choerodoncloud choerodon-event-store-service 1.2.1 框架服务 com.choerodon.choerodoncloud choerodon-framework-service 1.2.1 用户管理服务 com.choerodon.choerodoncloud choerodon-user-admin-service 1.2.0 K8S消息收集 com.choerodon.devops k8s-informer V0.1.1 Gitlab服务 com.choerodon.devops choerodon-gitlab-service 1.1.0 K8S服务 com.choerodon.devops devops-kubernetes-service 1.1.0 文件服务 com.choerodon.devops choerodon-file-service 1.1.0 开发服务 com.choerodon.devops choerodon-devops-service 1.1.0 部署服务 com.choerodon.devops devops-deploy-service 1.1.6 SonarQube服务 com.choerodon.insight data-sonar-service 1.0.1 数据整合服务 com.choerodon.insight data-intergration-service 1.0.0 数据提供服务 com.choerodon.insight data-provide-service 1.0.1 数据操作服务 com.choerodon.insight data-operation-service 1.0.0 看板服务 com.choerodon.kanban choerodon-kanban-service 1.1.0 移动服务 com.choerodon.mobile mobile-cloud-service 1.0.0 框架前端 com.choerodon.choerodoncloud choerodoncloud-front 1.2.2 开发前端 com.choerodon.devops devops-front 1.1.3 部署前端 com.choerodon.devops deploy-front 1.1.5 洞察前端 com.choerodon.insight analysis-insight-front 1.0.0 监控前端 com.choerodon.insight monitor-front 1.0.0 看板前端 com.choerodon.kanban choerodon-kanban-front 1.1.0 移动前端 com.choerodon.mobile mobile-front 1.0.0 硬件需求 存储 存储空间的大小主要取决于你将存储的docker image，Gitlab所存储的Git仓库以及使用文件服务时上传的文件大小。但是你应该考虑多留一些空间用来存储备份。 除此之外你还可以挂在一个支持NFS的分卷，比如NAS、 SAN、AWS、EBS。 CPU 将所有服务运行起来，一定要注意当前集群内至少有16C可用。 内存 安装使用Choerodon开发区所有应用需要至少50GB可用内存(RAM + Swap)! 由于操作系统和其他正在运行的应用也会使用内存， 所以安装Choerodon开发区前一定要注意当前集群内至少有70GB的可用内存. 少于70GB内存会导致在部署后Pod一直处于等待状态或者在使用中出现各种不可预知的问题。 Kubernetes v1.8.5 搭建Devops平台时，默认已经搭建好K8S集群，若未搭建请移步K8S集群搭建 依赖组件 名称 版本 Gitlab 10.2.0 Gitlab Runner 10.1.0 SonarQube 6.5 Harbor(可选) 1.1.1 监控 1.0.0 日志 1.0.0 安装所需软件及文件 在要执行ansible脚本的机器上安装ansible运行需要的环境以及git。 sudo yum install -y epel-release && \\ sudo yum install -y ansible git 克隆安装脚本 git clone https://rdc.hand-china.com/gitlab/rdc_hip/devops-ansible.git 使用NFS存储 若选择其他存储方式或已有NFS Server请跳过此步。 复制搭建K8S集群时所用到的inventory/hosts文件内容到本项目的inventory/hosts文件中。添加[nfs]分区，该分区只能添加一个节点，[nfs]分区节点即为提供nfs服务的节点。 修改inventory/vars.yml文件，将不需要部署的资源enable置为false，这里会自动创建所需目录；请设置nfs.ip属性，默认为指定节点ipv4地址；计算包含所有各节点的子网掩码将值赋予nfs.client_net，默认为\"*\"即所有主机都可以访问。 执行以下命令搭建nfs ansible-playbook -i inventory/hosts -e @inventory/vars.yml nfs-server.yml 执行安装步骤 修改inventory/hosts文件，其中[dev]分区只能添加一个节点且该节点可以使用kubectl命令。 确认所要部署的资源(mysql、rabbitmq、redis、zookeeper、kafka、sonarqube，minio)，若资源已有不需要部署，请在inventory/vars.yml文件中将资源enable置为false。 执行以下命令搭建开发区所需资源 ansible-playbook -i inventory/hosts -e @inventory/vars.yml dev-resource.yml 手动部署harbor(外部数据库要手工初始化)参考链接 手动部署Gitlab，等Devops所有服务部署后再配置oauth授权(Mysql 5.6需要转表)参考链接 搭建完成Gitlab完成后创建一个名为template的Public Group，将http://git.choerodon.com.cn/template库中所有的仓科克隆并推送到新搭建的Gitlab仓库中，注意这个git库也应是public的，这样开发服务才能正常使用。 手动部署Gitlab Runner参考链接 配置SonarQube参考链接 手动部署监控参考链接 手动部署日志参考链接 创建开发区所需数据库 若使用容器运行的mysql，可以参照以下命令进入容器创建数据库 查看pod名称，进入容器 kubectl get po -n devops kubectl exec -it [PodName] -n devops bash 进入mysql命令行 mysql -uroot -p${MYSQL_ROOT_PASSWORD} 创建choerodoncloud用户及数据库 CREATE USER 'choerodoncloud'@'%' IDENTIFIED BY 'choerodonchoerodon123'; CREATE DATABASE choerodon_user_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_manager_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_event_service DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_framework_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON choerodon_user_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_manager_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_event_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_framework_service.* TO choerodoncloud@'%'; CREATE DATABASE choerodon_devops_service DEFAULT CHARACTER SET utf8; CREATE DATABASE devops_portal DEFAULT CHARACTER SET utf8; CREATE DATABASE choerodon_kanban_service DEFAULT CHARACTER SET utf8; CREATE DATABASE devops_operation_portal DEFAULT CHARACTER SET utf8; CREATE DATABASE devops_deploy_service DEFAULT CHARACTER SET utf8; CREATE DATABASE mobile_cloud_service DEFAULT CHARACTER SET utf8; GRANT ALL PRIVILEGES ON choerodon_devops_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON devops_portal.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON choerodon_kanban_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON devops_operation_portal.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON devops_deploy_service.* TO choerodoncloud@'%'; GRANT ALL PRIVILEGES ON mobile_cloud_service.* TO choerodoncloud@'%'; FLUSH PRIVILEGES; 修改inventory/config.yml文件中资源区域维护好相应参数。 执行以下命令开始开发区 ansible-playbook -i inventory/hosts -e @inventory/config.yml dev.yml "},"/docs/quick-start/":{"url":"docs/quick-start/","title":"快速入门","description":"","body":"快速入门 快速入门主要介绍 Choerodon 的使用。从创建项目开始，从创建应用和使用敏捷管理工具等功能入手，详细地介绍如何使用 Choerodon 创建应用，并且结合用户故事地图、迭代和看板管理项目。 目前，Choerodon 支持3种类型应用的创建。前端应用、 后端应用、Java 库。 创建一个项目 创建一个前端应用 创建一个后端应用 创建一个Java库 "},"/docs/quick-start/microservice-backend":{"url":"docs/quick-start/microservice-backend","title":"创建一个后端应用","description":"","body":"创建一个后端应用 概述 后端应用(Backend Application)的架构模式是将传统的单体应用拆分成多个小型应用，每个小型应用可以独立的编译和部署，应用之间的调用通过HTTP的restfull API方式进行通讯。它们彼此之间相互协作，作为一个整体对外开放。Choerodon 的应用后端采用SpringBoot、SpringCloud 作为应用的开发框架，利用丰富的文档、社区活跃和一套完整的应用框架解决方案提供技术支持。 目标 本章节将从创建后端应用、开发后端应用、生成版本、部署应用、查看运行信息等方面介绍，让读者能够熟悉使用Choerodon创建应用后端应用的步骤和流程，并且学会如何利用Choerodon部署应用等。 前置条件 在操作之前保证系统配置已经配置完全。特别在本章节用到的角色、环境管理等配置。 完成创建项目操作。本章节使用在前面章节创建的项目猪齿鱼研发。 创建后端应用 使用项目所有者或者源代码管理员的角色登录Choerodon系统，选择项目猪齿鱼研发； 选择持续交付模块，点击应用，进入应用管理页面； 点击创建应用，系统会弹出窗口，在窗口中输入应用编码、应用名称和选择应用模板，点击创建，即可创建一个后端应用； a. 应用编码：choerodon-backend b. 应用名称：猪齿鱼后端应用 c. 选择应用模板: MicroService 当应用创建成功，可在应用管理界面查看到新建的应用； 在创建应用的同时，系统还会在Gitlab中创建一个仓库，点击 仓库地址 ，链接到Gitlab新建的仓库； Gitlab 仓库的名称是 choerodon-backend，为应用编码。 创建后端应用模板 当应用模板不符合您的要求，你可手动创建一个应用模板。 在组织层的持续交付模块，选择应用模板； 点击创建应用模板，输入相关信息，点击创建，即可创建一个模板。 创建完成以后，会生成一个Gitlab地址，点击该地址； 进入Gitlab仓库，克隆代码； 创建一个spring-boot项目 编写一个dockerfile 目录结构如下 |--src ｜--main ｜--docker ｜--dockerfile ``` FROM registry.choerodon.io/choerodon-cloud/base COPY app.jar /app.jar ENTRYPOINT [ \"java\" \"-jar\" \"/app.jar\"] ``` 编写gitlab-ci文件 image: registry.choerodon.io/tools/devops-ci:1.1.0 image指ci运行基础镜像 stages: - maven-package - docker-build stages指包含 maven-package 和docker-build两个阶段 maven-feature: stage: maven-package script: - git_merge develop - update_pom_version - mvn package -U -DskipTests=false - mvn --batch-mode verify sonar:sonar -Dsonar.host.url=${SONAR_URL}- Dsonar.analysis.mode=preview -Dsonar.gitlab.commit_sha=${CI_COMMIT_SHA} -Dsonar.gitlab.ref_name=${CI_COMMIT_REF_NAME} -Dsonar.gitlab.project_id=${CI_PROJECT_ID} only: - /^feature-.*$/ maven-feature指job名称 stage指对应的阶段 only指触发的分支 .auto_devops: &auto_devops | curl -o .auto_devops.sh \\ \"${CHOERODON_URL}/devops/ci?token=${Token}&type=microservice\" source .auto_devops.sh .auto_devops: 从指定仓库地址中拉取script脚本 用于docker-build阶段 before_script: - *auto_devops before_script: ci执行前所执行的命令 编写charts模块 目录结构如下 |--charts ｜--model-service ｜--templates ｜--_helper.tpl ｜--deplopment.yaml ｜--pre-config-congig.yaml ｜--pre-config-db.yaml ｜--service.yaml ｜--.helmignore ｜--Chart.yaml ｜--values.yaml templates为模板文件，将模板文件渲染成实际文件，然后发送给Kubernetes。 values.yaml为模板的预定义变量。 Chart.yaml包含chart的版本信息说明，您可以从模板中访问它。 deployment.yaml：创建Kubernetes 部署的基本清单 service.yaml：为您的部署创建服务端点的基本清单 _helpers.tpl：放置模板助手的地方，您可以在整个chart中重复使用 提交代码，即可完成模板创建。 开发后端应用 应用创建完成之后，开发后端应用。具体的操作步骤如下： 创建Feature分支。 点击应用，进入到应用管理界面，选择应用编码choerodon-backend，点击右侧分支管理，选择创建分支，系统会弹出侧边栏，填写字段，点击创建按钮，即可创建一个Feature分支。 字段填写输入包含字母、数字、'——'、'_'），如feature-1 在存放代码的文件夹下，打开git bash 输入命令git clone [仓库地址]，拉取所需应用的代码仓库。 克隆成功之后，进入项目根目录，打开git bash 输入命令git checkout feature-1 切换到新建分支feature-1，并在此分支进行开发。 $ git checkout feature-1 提交代码。 # 将本地代码变动提交到暂存区 $ git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1 基于feature分支运行CI。点击CI流水线 查看 CI 执行情况。 当CI运行完成以后，点击应用，进入应用管理，点击choerodon-backend的分支管理，在分支列表找到feature-1，点击结束分支。 生成版本 应用版本是代码提交的历史记录，每提交一次修改后的代码，对应生成一个新的版本。具体的操作步骤如下： 结束分支之后，feature-1分支的代码会合并到develop分支，并触发Gitlab CI。点击CI流水线 查看CI执行情况。 Choerodon 缺省的 CI 流程有三个阶段: 单元测试，编译打包，代码质量检查 构建docker镜像 创建应用版本 点击应用版本进行查看，确定应用版本已经生成。 部署应用 提供可视化、一键式部署应用，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发； 在菜单栏选择应用部署，进入应用部署界面，点击部署应用； a. 选择应用：之前所创建的应用，choerodon-backend b. 选择版本：刚才所创建的应用版本 c. 选择环境: 选择所要部署的环境 d. 配置信息：配置部署应用所需的信息 e. 部署模式：新建实例（新建一个应用） 替换实例（新建一个实例，将旧实例替换） 配置网络 为所选的应用配置网络。 在持续交付模块中选择网络，进入网络配置界面，点击创建网络 a. 环境名称：选择要部署的环境 b. 应用名称：选择创建的应用名称 猪齿鱼后端应用 c. 版本：选择刚才创建的应用版本 d. 实例：选择刚才创建的实例 e. 网络名称：系统默认一个网络名称（可手动修改） f. 外部IP：需要外网时填写 g. 端口号：应用开放端口 查看运行信息 进入持续交付模块，选择应用部署，点击部署应用即可查看运行状态。有四种查看视图，分别为：部署实例、单环境单应用、多应用。 那么如何判断这个应用版本已经部署成功？当可用容器数量、当前容器状态为1时，代表该应用版本已经部署成功了。 在应用版本界面，右侧的查看部署详情，进入到查看部署详情界面。点击部署详情可以查看到阶段信息及日志。 产品迭代 任何产品几乎都会经历产品的初创期、成长期、成熟期。在产品的初创期，需要通过快速试错探索出有用户黏性的功能；探索成功之后，就需要快速导入用户，这时候也会产生新的需求和新的问题，不断去完善产品；在产品的相对成熟期，则可以考虑产品的变现，和新功能的延展，以提升用户活跃。因此，当一个产品开发完成上线后，产品的周期化迭代就变得非常重要。固定的周期有助于为项目团队形成规范，从而提高开发效率。 Choerodon第一次发版前就准备好下个版本的需求。一般第一个版本上线后，开发人员就进入下一个版本的开发和测试。这样当问题暴露的时候，就可以迅速解决问题，优化到某个程度后，再放缓迭代节奏，这样就能更好的平衡好需求。 "},"/docs/quick-start/microservice-front":{"url":"docs/quick-start/microservice-front","title":"创建一个前端应用","description":"","body":"创建一个前端应用 概述 就前端主流技术框架的开发而言，过去几年里发展极快，在填补原有技术框架空白和不足的同时也渐渐趋于成熟。未来前端在已经趋向成熟的技术方向上面会慢慢稳定下来，并进入技术迭代优化阶段，但这并不代表前端领域技术就此稳定了，因为新的技术方向已经出现，并在等待下一个风口的到来。可能是虚拟现实也有可能是人工智能或者其他。 Choerodon 使用 React 和 MobX 作为前端的UI应用框架，并且对前端的展示做了一定的封装和处理，能够让用户方便快捷地进行前端应用的开发和部署。React 和 MobX都提供了最优和独特的解决方案。React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。 目标 本章节将从创建前端应用、开发前端应用、生成版本、部署应用、配置网络、配置域名等方面介绍，让读者能够熟悉使用Choerodon创建前端应用的步骤和流程，并且学会如何利用Choerodon创建并部署前端应用。 前置条件 在操作之前保证系统配置已经配置完全。 完成创建项目，本章节使用在前面章节创建的项目猪齿鱼研发。 创建前端应用 使用项目所有者或者源代码管理员的角色登录Choerodon系统，选择项目猪齿鱼研发； 选择持续交付模块，点击应用，进入应用管理页面； 点击创建应用，系统会弹出窗口，在窗口中输入应用编码、应用名称和选择应用模板，点击创建按钮，即可创建一个前端应用；； a. 应用编码：choerodon-front 应用编码输入只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头。 b. 应用名称：猪齿鱼前端应用 c. 选择应用模板: MicroServiceUI 当应用创建成功，可在应用管理界面查看到新建的应用； 在创建应用的同时，系统还会在Gitlab中创建一个仓库，点击 仓库地址 ，链接到Gitlab新建的仓库； Gitlab 仓库的名称是 choerodon-backend，为应用编码。 创建前端应用模板 当应用模板不符合您的要求，你可手动创建一个应用模板。具体步骤如下： 在组织层的持续交付模块，选择应用模板； 点击创建应用模板，输入相关信息，点击创建，即可创建一个模板； 创建完成以后，会生成一个Gitlab地址，点击该地址； 进入Gitlab仓库，克隆代码； 创建一个react的前端UI项目； 编写一个dockerfile； 将dockerfile文件放在项目根目录下 FROM registry.choerodon.io/tools/nginx:stable RUN echo \"Asia/shanghai\" > /etc/timezone; ADD dist /usr/share/nginx/html COPY entrypoint.sh . ENTRYPOINT [ \"sh\" \"./entrypoint.sh\" ] entrypoint.sh文件如下 #bin/bash set -e PRO_API_HOST=${PRO_API_HOST:-\"gateway.devops.saas.choerodon.com\"} PRO_CLIENT_ID=${PRO_CLIENT_ID:-\"devops\"} find /usr/share/nginx/html -name '*.js' | xargs sed -i \"s/localhost:8080/$PRO_API_HOST/g\" find /usr/share/nginx/html -name '*.js' | xargs sed -i \"s/localhost:clientId/$PRO_CLIENT_ID/g\" nginx -g 'daemon off;' exec \"$@\" 编写gitlab-ci文件 image: registry.choerodon.io/tools/devops-ci:1.1.0 image指ci运行基础镜像 stages: - node_build - docker_build stages指包含 node_build 和docker_build两个阶段 ```yaml node_build_dev: stage: node_build script: - node_config - node_module iam - node_build devbuild - clean_cache only: - /^release-.*$/ - /^hotfix-.*$/ - develop - tags node_build_dev指job名称 stage指对应的阶段 script指执行的命令 only指触发的分支 ```yaml .auto_devops: &auto_devops | curl -o .auto_devops.sh \\ \"${CHOERODON_URL}/devops/ci?token=${Token}&type=microservice\" source .auto_devops.sh .auto_devops: 从指定仓库地址中拉取script脚本 用于docker-build阶段 ``` before_script: - *auto_devops ``` before_script:指ci执行前所执行的命令 编写charts模块； 目录结构如下 |--charts ｜--model-service ｜--templates ｜--_helper.tpl ｜--deplopment.yaml ｜--.helmignore ｜--Chart.yaml ｜--values.yaml templates为模板文件，将模板文件渲染成实际文件，然后发送给Kubernetes。 values.yaml为模板的预定义变量。 Chart.yaml包含chart的版本信息说明，您可以从模板中访问它。 deployment.yaml：创建Kubernetes 部署的基本清单。 _helpers.tpl：放置模板助手的地方，您可以在整个chart中重复使用。 编写config.js； 提交代码，即可完成模板创建； 开发前端应用 应用创建完成之后，开发前端应用。具体的操作步骤如下： 　1、 创建Feature分支。 点击应用，进入到应用管理界面，选择猪齿鱼前端应用，点击右侧分支管理； 点击创建分支； 系统弹出侧边栏，填写字段； 字段填写输入包含字母、数字、'——'、'_'），如feature-1 点击创建按钮，即可创建一个名称为feature-1的分支。 　２、 在存放代码的文件夹下，打开git bash 输入命令git clone [仓库地址]，拉取所需应用的代码仓库。 　３、 克隆成功后，进入项目根目录，打开git bash，输入git checkout feature-1，切换到新建分支feature-1，在此分支进行开发。 ```shell $ git checkout feature-1 ``` 　４、提交代码。 ```shell # 将本地代码变动提交到暂存区 $ git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1 ``` 　５、基于feature分支运行CI。点击CI流水线 查看 CI 执行情况。 　６、点击应用，进入应用管理，点击应用编码choerodon-front的分支管理，在分支列表找到feature-1，点击结束分支。 生成版本 应用版本是代码提交的历史记录，每提交一次修改后的代码，对应生成一个新的版本。具体的操作步骤如下： 结束分支之后，feature-1分支的代码会合并到develop分支，并触发Gitlab CI。点击CI流水线， 查看CI执行情况。 Choerodon 缺省的 CI 流程有三个阶段: 单元测试，编译打包，代码质量检查 构建docker镜像 创建应用版本 CI运行完成以后，点击应用版本进行查看，确定应用版本已经生成。 部署应用 提供可视化、一键式部署应用，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 使用部署管理员的角色登录Choerodon系统，选择项目猪齿鱼研发； 在菜单栏选择应用部署，进入应用部署界面，点击部署应用； a. 选择应用：刚才创建的应用，choerodon-front b. 选择版本：刚才所创建的应用版本 c. 选择环境: 选择所要部署的环境 d. 配置信息：配置部署应用所需的信息 e. 部署模式：新建实例（新建一个应用） 替换实例（新建一个实例，将旧实例替换） 配置网络 为所选的应用配置网络。 在持续交付模块中选择网络，进入网络配置界面，点击创建网络 a. 环境名称：选择要部署的环境 b. 应用名称：刚才创建的应用，猪齿鱼前端应用 c. 版本：选择刚才创建的应用版本 d. 实例：选择刚才创建的实例 e. 网络名称：系统默认一个网络名称（可手动修改） f. 外部IP：需要外网时填写 g. 端口号：应用开放端口 配置域名 为所选的应用配置域名。 在持续交付模块中选择域名，进入域名管理界面，点击创建网络 a. 域名名称：测试域名 b. 域名地址：填写域名地址，如choerodon.io c. 环境名称：选择要部署的环境 d. 路径：choerodon-front e. 网络：选择配置的网络 查看运行信息 进入持续交付模块，选择应用部署，点击部署应用即可查看运行状态。有四种查看视图，分别为：部署实例、单环境单应用、多应用。 那么如何判断这个应用版本已经部署成功？当可用容器数量、当前容器状态为1时，代表该应用版本已经部署成功了。 在应用版本界面，右侧的查看部署详情，进入到查看部署详情界面。点击部署详情可以查看到阶段信息及日志。 产品迭代 任何产品几乎都会经历产品的初创期、成长期、成熟期。在产品的初创期，需要通过快速试错探索出有用户黏性的功能；探索成功之后，就需要快速导入用户，这时候也会产生新的需求和新的问题，不断去完善产品；在产品的相对成熟期，则可以考虑产品的变现，和新功能的延展，以提升用户活跃。因此，当一个产品开发完成上线后，产品的周期化迭代就变得非常重要。固定的周期有助于为项目团队形成规范，从而提高开发效率。 Choerodon第一次发版前就准备好下个版本的需求。一般第一个版本上线后，开发人员就进入下一个版本的开发和测试。这样当问题暴露的时候，就可以迅速解决问题，优化到某个程度后，再放缓迭代节奏，这样就能更好的平衡好需求。 "},"/docs/quick-start/project":{"url":"docs/quick-start/project","title":"创建一个项目","description":"","body":"创建一个项目 目标 项目是 Choerodon 组织开发的基本形式，隶属于组织。一个项目包含与开发相关的资源、环境、敏捷管理，以及用户权限控制等。项目是进行应用创建开发，敏捷管理，持续交付的基础，必须先创建项目，才能够进行下一步的工作。 本章节将从创建项目、定义环境、资源等方面介绍 Choerodon 项目，让读者能够了解项目的基本概念，学会创建项目的基本操作和注意事项等，以及学会为项目分配权限，为项目创建环境信息等。 前置条件 在操作之前保证系统配置已经配置完全。 用户必须属于组织层，且属于唯一组织。 创建项目 具体操作步骤如下： 使用项目创建者的角色登录Choerodon系统，系统会默认一个组织，点击该组织，弹出组织/项目选择界面； 点击将要创建的项目所在的组织层，选择IAM和管理模块； 进入IAM和管理模块后，点击项目管理； 进入项目管理页面后，选择创建项目。系统会弹出侧边栏，在侧边栏中输入项目编码和项目名称； 项目编码：choerodon-dev 项目名称：猪齿鱼研发 项目编码 必须输入，且编码只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头。 点击创建，即可创建新的项目； 当项目创建成功，Choerodon同时会在Gitlab中创建一个Group和Issue库。我们可以登录到Gitlab检查创建。 Gitlab Group 的名称是 choerodon — choerodon-dev，为组织编码 — 项目编码。 创建环境 环境主要是开发区向运行区发布应用的通道。由于开发区和运行区都是部署Kubernetes集群上的微服务框架，所以，环境本质上就是目标运行区的gateway地址。开发区的应用会使用到这个环境地址，将新产生的版本，发布到对应的运行区。例如，项目A经过一个冲刺产生了应用B的最新版本1.0.1，此时在项目A下面定义了两个环境，即测试环境和正式环境，项目A按照既定的项目管理流程现将应用B的最新版本1.0.1发布到测试环境，并部署，以供测试人员测试；当测试通过，再将1.0.1版本发布到正式环境，并部署。 具体的创建步骤如下： 使用项目创建者角色登录系统，进入项目层，选择一个项目，例如choerodon下的猪齿鱼研发，点击环境流水线。 在环境流水线菜单，点击创建，系统会弹出一个侧边栏，请在侧边栏中输入相应的环境信息，有环境编码、环境名称、环境描述。 环境编码：dev-env 环境名称：开发环境 环境描述：开发环境 根据用途配置不同的环境，常见的有开发环境，集成测试环境，用户访问测试环境及正式环境。 填写完成后，点击保存，会出现一个指令，将指令代码复制至Kubernetes运行，与平台建立连接。 总结 项目是Choerodon最重要的概念，它是开发区组织资源的基本形式。通过本章节简单的学习，我们可以在Choerodon系统中创建自己的项目以及设置相关环境和权限等。用户可以根据自己具体的情况来创建项目，根据DevOps和敏捷管理的思想，Choerodon 建议按照一个Scrum中Develop团队的规模（6-9个人）来划分项目，例如，我们可能要开发3个后端和前端，那么我们可以分成3个项目组，每个项目组负责一个后端和一个前端。那么就需要创建3个项目。 "},"/docs/quick-start/web-application":{"url":"docs/quick-start/web-application","title":"创建一个Java库","description":"","body":"创建一个Java库 概述 众所周知，Java 的生态环境相当庞大，包含了数量相当可观的官方及第三方库。利用这些库，可以解决在用 Java 开发时遇到的各类问题，让开发效率得到显著提升。 目标 本页面介绍以DevOps平台为基础，演示如何创建一个Java库，让用户熟知整个操作流程。 前置条件 在操作之前保证系统配置已经配置完全。 完成创建项目操作。本章节使用在前面章节创建的项目猪齿鱼研发。 创建Java库 使用项目所有者或者源代码管理员的角色登录Choerodon系统，选择项目猪齿鱼研发； 选择持续交付模块，点击应用，进入应用管理页面； 点击创建应用，系统会弹出窗口，在窗口中输入应用编码、应用名称和选择应用模板， 点击创建按钮，即可创建一个Java库； a. 应用编码：choerodon-jar 应用编码输入只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头。 b. 应用名称：猪齿鱼jar应用 c. 选择应用模板: JavaLib 当应用创建成功，可以在应用管理查看到新建的应用； 在创建应用的同时，系统还会在Gitlab中创建一个仓库，点击 仓库地址 ，链接到Gitlab新建的仓库； Gitlab 仓库的名称是 choerodon-jar，为应用编码。 创建Java库应用模板 当应用模板不符合您的要求，你可手动创建一个应用模板。具体步骤如下： 在组织层的持续交付模块，选择应用模板； 点击创建应用模板，输入相关信息，点击创建，即可创建一个模板； 创建完成以后，会生成一个Gitlab地址，点击该地址； 进入Gitlab仓库，克隆代码； 创建一个普通Java应用 编写一个Gitlab CI stages: - mvn-package stage定义CI中包含的阶段 ``` stylus maven-branches: stage: mvn-package script: - update_pom_version - mvn clean && mvn package -U -DskipTests=false - mvn --batch-mode verify sonar:sonar -Dsonar.host.url=${SONAR_URL} -Dsonar.analysis.mode=preview -Dsonar.gitlab.commit_sha=${CI_COMMIT_SHA} -Dsonar.gitlab.ref_name=${CI_COMMIT_REF_NAME} -Dsonar.gitlab.project_id=${CI_PROJECT_ID} only: - develop - /^release-.*$/ - /^hotfix-.*$/ - /^feature-.*$/ except: - tags ``` maven-branches指job名称 stage指对应的阶段 script指执行的命令 only指触发的分支 except指不会触发的分支 ``` stylus .auto_devops: &auto_devops | curl -o .auto_devops.sh \\ \"${CHOERODON_URL}/devops/ci?token=${Token}&type=lib\" source .auto_devops.sh ``` .auto_devops: 从指定仓库地址中拉取script脚本 用于docker-build阶段 ```yaml before_script: - *auto_devops ``` before_script:指ci执行前所执行的命令 7.提交代码； 开发Java库 Java库创建完成之后，开发Java库。具体的操作步骤如下： 1、 创建Feature分支。 点击应用，进入到应用管理界面，选择猪齿鱼前端应用，点击右侧分支管理； 点击创建分支； 系统弹出侧边栏，填写字段； 字段填写输入包含字母、数字、'——'、'_'），如feature-1 点击创建按钮，即可创建一个名称为feature-1的分支。 　２、 在存放代码的文件夹下，打开git bash 输入命令git clone [仓库地址]，拉取所需应用的代码仓库。 　３、 克隆成功后，进入项目根目录，打开git bash，输入git checkout feature-1，切换到新建分支feature-1，在此分支进行开发。 ```shell $ git checkout feature-1 ``` 　4、 提交代码 ```shell # 将本地代码变动提交到暂存区 $ git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1 ``` 记得修改maven 仓库地址。 　5、 基于feature分支运行CI。点击CI流水线 查看 CI 执行情况。 　6、 当CI运行完成以后，点击应用，进入应用管理界面，点击猪齿鱼java应用的分支管理，在分支列表找到feature-1，点击结束分支。 　7、 创建Release分支。 在应用管理界面，选择应用编码`choerodon-java`，点击右侧`分支管理`，选择`创建分支`，系统会弹出侧边栏，填写字段，点击创建按钮，即可创建一个Release分支。 　8、 在分支列表找到刚才创建的分支，点击结束分支。 　9、 点击CI流水线，再次查看CI运行情况。 如果CI运行成功，去maven仓库地址查看是否打包成功。 10、生成的JAR包的信息如下： groupId：组织编码-项目编码 artifactId: 应用编码 version: 创建的Release分支名称 产品迭代 任何产品几乎都会经历产品的初创期、成长期、成熟期。在产品的初创期，需要通过快速试错探索出有用户黏性的功能；探索成功之后，就需要快速导入用户，这时候也会产生新的需求和新的问题，不断去完善产品；在产品的相对成熟期，则可以考虑产品的变现，和新功能的延展，以提升用户活跃。因此，当一个产品开发完成上线后，产品的周期化迭代就变得非常重要。固定的周期有助于为项目团队形成规范，从而提高开发效率。 Choerodon第一次发版前就准备好下个版本的需求。一般第一个版本上线后，开发人员就进入下一个版本的开发和测试。这样当问题暴露的时候，就可以迅速解决问题，优化到某个程度后，再放缓迭代节奏，这样就能更好的平衡好需求。 "},"/docs/reference/API":{"url":"docs/reference/API","title":"API","description":"","body":"正在更新，敬请期待... "},"/docs/reference/":{"url":"docs/reference/","title":"参考","description":"","body":"参考 "},"/docs/reference/markdown":{"url":"docs/reference/markdown","title":"Markdown 编写规范","description":"","body":"在App Engine灵活环境中快速启动Go 本快速入门介绍如何创建一个显示简短消息的小型App Engine应用程序。 在你开始之前 在运行和部署此示例之前，请执行以下步骤： 使用GCP控制台创建新的GCP项目，创建App Engine应用程序并启用计费： 提示时，选择的区域 ，你希望你的App Engine应用程序所在，然后启用计费。 在本地安装以下先决条件： a. 下载并安装git。 b. 下载并安装Google Cloud SDK，然后初始化该 gcloud工具： 或者：您可以使用 已安装git和Cloud SDK的Google Cloud Shell以及 许多其他功能，如语言支持和代码编辑器。 在Google云端Shell启动后，您可以继续本教程的其余部分，并在云端Shell中执行您的命令。 本快速入门假设您熟悉Go编程语言，并且已安装Go。 下载Hello World应用程序 我们为Go创建了一个简单的Hello World应用程序，因此您可以快速了解将应用程序部署到App Engine灵活环境的感受。从命令行执行这些步骤以将Hello World下载到本地计算机。 下载示例应用程序并导航到应用程序目录： 获取Hello World示例应用程序及其依赖项： go get -u -d github.com/GoogleCloudPlatform/golang-samples/appengine_flexible/helloworld 切换到包含示例代码的目录： cd $GOPATH/src/github.com/GoogleCloudPlatform/golang-samples/appengine_flexible/helloworld 在本地机器上运行Hello World 在本地计算机上运行Hello World应用程序： 启动本地Web服务器： go run *.go 在您的网络浏览器中，输入以下地址： http://localhost:8080 注意：如果您正在使用云端Shell，请在工具栏中单击 Web预览，然后选择端口8080上的预览。 如果您正在使用云端Shell，请在工具栏中单击 Web预览，然后选择端口8080上的预览。 如果您正在使用云端Shell，请在工具栏中单击 Web预览，然后选择端口8080上的预览。 如果您使用的是现有项目，则还会删除您在项目中完成的其他任何工作。 您不能重复使用已删除项目的项目ID。如果您创建了您计划在将来使用的自定义项目ID，则应该删除项目内部的资源。这可确保使用项目ID的appspot.comURL（例如URL）保持可用。 在App Engine上部署并运行 Hello World 要将您的应用部署到App Engine灵活环境： 通过从helloworld目录运行以下命令部署Hello World应用程序： gcloud应用程序部署 了解可选标志。 通过运行以下命令 启动浏览器并查看应用程序 ：http://YOUR_PROJECT_ID.appspot.com gcloud应用程序浏览 这一次，显示Hello World消息的页面由运行在App Engine实例上的Web服务器提供。 恭喜！您已将第一个Go应用程序部署到App Engine灵活环境！ 请参阅以下各节以获取有关清理的信息以及可以采取的下一步可能的链接。 清理 为避免收费，您可以删除您的GCP项目，以停止对该项目中使用的所有资源进行结算。 警告：删除项目会导致以下后果：如果您使用的是现有项目，则还会删除您在项目中完成的其他任何工作。 您不能重复使用已删除项目的项目ID。如果您创建了您计划在将来使用的自定义项目ID，则应该删除项目内部的资源。这可确保使用项目ID的appspot.comURL（例如URL）保持可用。 在云平台控制台中，转到“项目”页面。 在项目列表中，选择要删除的项目并单击删除项目。 在对话框中输入项目ID，然后单击关闭以删除该项目。 下一步是什么 现在您已经完成了Hello World，您可以开始探索您的下一个示例应用程序：Bookshelf应用程序。Bookshelf应用程序是一个更完整但仍然基本的Go Web应用程序，它使用多个Cloud Platform功能，如数据存储，身份验证，日志记录，发布/订阅等等。 有关App Engine灵活环境的更多信息，请参阅App Engine概述。 Hello World代码审查 Hello World是最简单的App Engine应用程序，因为它只包含一个服务，只有一个版本，所有代码都位于应用程序的根目录中。本节详细介绍每个应用程序文件。 helloworld.go 该helloworld.go文件注册一个侦听请求的处理程序/，并用'Hello world！'进行响应。信息。 package main import ( \"fmt\" \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/\" handle) http.HandleFunc(\"/_ah/health\" healthCheckHandler) log.Print(\"Listening on port 8080\") log.Fatal(http.ListenAndServe(\":8080\" nil)) } func handle(w http.ResponseWriter r *http.Request) { if r.URL.Path != \"/\" { http.NotFound(w r) return } fmt.Fprint(w \"Hello world!\") } func healthCheckHandler(w http.ResponseWriter r *http.Request) { fmt.Fprint(w \"ok\") } app.yaml ``` runtime: go env: flex # This sample incurs costs to run on the App Engine flexible environment. # The settings below are to reduce costs during testing and are not appropriate # for production use. For more information see: # https://cloud.google.com/appengine/docs/flexible/python/configuring-your-app-with-app-yaml manual_scaling: instances: 1 resources: cpu: 1 memory_gb: 0.5 disk_size_gb: 10 ``` 在这里， app.yaml指定应用程序使用的运行时和设置env: flex，指定应用程序使用灵活的环境。 有关Go运行时如何工作的更多信息，请参阅 Go运行时。 有关如何设计应用以利用版本和服务的更多详细信息，请参阅 App Engine概述。 有关App Engine配置设置的更多详细信息，请参阅 使用app.yaml配置您的应用程序。 "},"/docs/user-guide/":{"url":"docs/user-guide/","title":"用户手册","description":"","body":"用户手册 本用户手册介绍了Choerodon各环节的操作步骤。Choerodon的用户可以通过此章节了解每个环节的概念定义、主要功能流程及其他注意事项。使用本教程，你可以了解： 系统配置 是为了让Choerodon的用户更便捷、科学地使用平台，需在用户使用前进行的系统配置，包括角色、用户、项目、环境等。 敏捷管理 介绍了团队在需求从产生到确定的过程中需要进行绘制用户故事地图、计划产品发布、设立冲刺计划、使用看板管理需求等功能，融合敏捷开发、精益IT、DevOps思想，满足团队管理需求及计划。 持续集成 描述了用户在进行产品开发时可以使用Choerodon进行管理服务、使用Git-Flow模型进行分支管理、查看持续集成流水线、管理服务版本、了解代码质量，以及开发完成将服务版本发布至运行区。 持续部署 介绍了用户可以在Choerodon运行区进行服务部署，及与服务部署紧密相关的资源管理、网关管理、域名管理。 "},"/docs/user-guide/continuos-delivery/Continuous delivery-Application deployment":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-Application deployment","title":"应用部署","description":"","body":"应用部署 提供可视化、一键式部署应用，支持并行部署和流水线无缝集成，实现部署环境标准化和部署过程自动化。 菜单层次：组织层 菜单路径：持续交付 > 应用部署 默认角色：部署管理员 查看运行中的应用详情 可在运行中查看正在部署/运行的版本，以及对容器状态进行调整； 点击详情，查看应用部署阶段和详情信息。 不同应用类型，部署阶段不同。 部署实例 通过容器状态、实例、应用、环境的信息来观察应用的部署情况。 查看实例详情 点击页面右侧 按钮 ，再点击查看实例详情，进入实例详情后观察其运行详情和部署详情。 修改配置信息 点击页面右侧 按钮 ，再点击修改配置信息，进入修改配置信息界面后对实例配置信息进行修改后重新部署。 停止实例 点击页面右侧 按钮 ，再点击停止实例，该实例即为停止状态，且容器状态停止。 停止实例后，停止实例按钮转变为重启实例按钮。 删除实例 点击页面右侧 按钮，再点击删除实例，该实例被删除。 单环境 通过搜索单个环境名称来观察该环境应用中所部署的情况。 单应用 观察单个应用在不同环境下的部署情况。 在单应用界面中，点击页面右侧 ，对当前选择的条件进行快速部署。 多应用 观察所有应用在不同环境下的部署情况。 "},"/docs/user-guide/continuos-delivery/Continuous delivery-Assembly line":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-Assembly line","title":"CI流水线","description":"","body":"CI流水线 CI流水线是持续集成过程中的完成情况，包括状态、标识、应用编码、应用名称、提交、阶段、时长及创建时间。 菜单层次：项目层 菜单路径：持续交付 > CI流水线 默认角色：项目所有者、源代码管理员、项目成员 查看CI流水线详情 进入持续交付后，点击 CI流水线 页签； 查看应用CI pipeline的完成情况； 查看服务CI pipeline的完成情况，只有CI各个阶段跑成功了才会生成一个应用版本。 版本命名方式：合并至develop：develop. + 年月日时分秒。 Tag生成：版本号（三位号码，如：1.1.0。release修改前两位，hotfix修改第三位）。 提交：每次提交代码的操作，自动生成Commit ID，由于字数多，平时多取前八位。 列表字段： 状态：Job的状态 created，pending，running，failed，success，canceled，skipped，manual。 标识：CI标识+CI触发者。 提交：提交的信息。 阶段：CI的阶段 分为单元测试和生成镜像两个阶段。单元测试阶段完成单元测试的运行并且对代码质量进行审查，生成镜像阶段通过docker把应用生成镜像。 时长：CI持续的时长。 创建时间：CI创建的时间。 ：当处于skipped、canceled、failed状态时，可以重新运行CI。 "},"/docs/user-guide/continuos-delivery/Continuous delivery-Branch management":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-Branch management","title":"分支管理","description":"","body":"分支管理 Choerodon采用 git-flow 工作流模式，有master和develop两个默认分支。在持续交付过程中对 feature、release、hotfix 等分支进行管理。结束分支可自动触发分支合并和持续集成，可在流水线查看代码集成情况。 菜单层次：项目层 菜单路径：持续交付 > 应用 > 分支管理 默认角色：项目所有者、源代码管理员、项目成员 分支类型 Master：默认分支，版本发布分支。 Develop：默认分支，日常开发分支。 Feature：适用于日常开发、bug修复，基于开发分支生成，完成时合并至开发分支。 Release：适用于产品发布、产品迭代，基于开发分支生成，完成时合并至主分支和开发分支，并打上标签。 Hotfix：适用于产品发布后修复bug，基于主分支生成，完成时先合并至主分支和开发分支，并打上标签。 分支使用流程 分支使用流程包括四个部分：新建分支、拉下分支至本地开发、开发完提交代码/解决冲突、结束分支。 新建分支 点击创建Feature/创建Release/创建Hotfix按钮，创建对应分支； 输入Issue编码或版本号。点击保存按钮； Feature/Hotfix 分支创建时输入Issue编码作为分支名。 Release 分支创建时会自动生成下一个版本号，也可以手动输入需要的版本号。（版本号由三个数字组成，中间以小数点间隔。如：1.1.0。Release 版本号默认为末位清零，中间一位进一）。 结束分支 feature 分支在结束时会合并生成对应的服务版本，版本号与创建时填写一致； Release 分支在结束时会生成对应的服务版本，版本号与创建时填写一致； Hotfix 分支在结束时会提示以最新版本的第三位加一作为版本号。如最新版本为1.1.5，则hotfix分支结束时生成新版本为1.1.6； 无提交时点击结束分支，将不创建合并请求，直接删除。 另外，新建分支及结束分支只能在平台界面进行操作，请勿随意在gitlab界面创建合并请求和删除分支 示例：分支管理操作步骤 克隆代码到本地 # 在存放代码的文件夹下执行以下命令，拉取所需服务的代码仓库 git clone http://choerodon.io/choerodon-choerodon-dev/choerodon-backend.git # 拉取远程仓库成功后进入仓库 cd choerodon-backend.git 拉取最新代码和新建的分支 git pull 切换到分支 # 切换到新建分支，以 feature-1 为例 git checkout feature-1 开发 根据分支对应的 Issue 需求修改代码。完成后详细检查本地代码改动。 提交代码 # 将本地代码变动提交到暂存区 git add . # 提交代码并且为本次提交添加 commit 信息 # 注：[FIX]修改bug [ADD]新增 [IMP]完善 [DEL]删除 $ git commit –m “[ADD]readme: 新增代码示例” # 将本地提交推送至远程仓库对应分支 $ git push origin feature-1 界面操作结束分支 解决分支冲突 Feature 分支冲突 常见两种解决冲突的方式如下 本地修改代码解决： # 确保当前正在 Feature 分支上，以 feature-1 为例 git checkout feature-1 # 拉取最新远程仓库 develop 分支代码 git fetch origin develop:develop # 将 Feature 分支重新设立起点于最新的 develop 代码 git rebase develop 执行完 rebase 操作后，会产生对应的冲突，解决冲突后执行如下代码。 git add . git rebase --continue 根据本次 Feature 分支上提交次数的不同，解决冲突可能会重复多次，只需要重复执行上述解决冲突操作。 完成后强制提交至远程仓库。 git push -f origin feature-1 Release&Hotfix 分支冲突 当分支对于 develop 和 master 分支中任意一个或以上存在冲突时，会提示当前存在冲突及建议做法。 若此时继续点击确定按钮，并且没有解决冲突，那么会提示分支冲突，无法继续操作。 解决冲突具体步骤可查看界面提示，说明如下： 只有对应 develop 的合并请求存在冲突，按界面提示解决冲突会导致分支对应 develop 分支的合并请求被合并。此时再进行结束分支操作，会处理分支对 master 的合并请求，然后生成对应版本号的 Tag 并删除分支。 只有对应 master 的合并请求存在冲突，按界面提示解决冲突会导致分支对应 master 分支的合并请求被合并。此时再进行结束分支操作，会处理分支对 develop 的合并请求，然后生成对应版本号的 Tag 并删除分支。 若分支对应 develop 和 master 分支的合并请求都存在冲突，按界面提示解决冲突会导致分支对应 develop 和 master 分支的合并请求依次都被合并。此时再进行结束分支操作，会生成对应版本号的 Tag 并删除分支。 "},"/docs/user-guide/continuos-delivery/Continuous delivery-Network management":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-Network management","title":"网络管理","description":"","body":"网络管理 网络管理是将所选的应用的网络信息注册至应用管理服务，注册后，该应用才能正常访问。且支持删除网络的注册信息。 菜单层次：组织层 菜单路径：持续交付 > 网络 默认角色：部署管理员 应用可以访问的两个必要条件：网络注册、应用部署。 新建网络 点击 创建网络 ； 选择环境，只可选择运行中的环境，故障中的环境不可选； 选择应用名称、版本及实例； 输入网络名称、外部IP及端口号；外部IP为选填项，需要外部网络访问时填写。 点击 创建完成网络创建。 查看应用版本详情 进入持续交付后，点击网络管理 页签； 查看项目应用的网络配置信息。 修改网络信息 点击修改网络 → 对网络进行修改。 删除网络信息 点击删除网络 → 对网络进行修改。 若删除网络，该条数据将被永久删除，不可恢复! "},"/docs/user-guide/continuos-delivery/Continuous delivery-application management":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-application management","title":"应用管理","description":"","body":"应用管理 应用是满足用户某些需求的程序代码的集合。一个系统可以被解耦成很多应用。每一个应用都可以独立部署，每一个应用仅关注于完成一部分任务，每部分任务代表一个小的业务模块，因此各应用之间关系是松耦合的。另外，每创建一个应用，系统会自动在gitlab创建好对应的代码库。 只有该项目的项目所有者和源代码管理员才能创建应用，项目成员仅能查看应用。 菜单层次：项目层 菜单路径：持续交付 > 应用 默认角色：项目所有者、源代码管理员、项目成员 应用类型 后端应用：可以定义依赖的资源和应用，部署时需配置网关。 Web前端：部署时需配置域名。 Java库：管理Java工具包。 新建应用 输入应用编码及名称，也可以选择某个应用模板，快速创建应用。平台会为您自动创建对应的git库以便管理该应用代码。 点击 创建应用 按钮； 输入 “应用编码” 、 “应用名称” 、以及选择 “应用模板” ，点击 创建 按钮；（应用编码及名称均为自定义；应用模板：Java库-JavaLib;微服务-MicroService;前端-MicroServiceUI） 可以去gitlab中查看已创建的代码库。 查看应用详情 在详情界面根据应用名称、应用编码、仓库地址、应用状态来查看应用详情。 列表字段 应用名称：应用的自定义名称； 应用编码：应用的自定义编码； 仓库地址：应用git仓库地址； 应用状态：应用运行有三种状态，分别为启用、停用、创建中。 分支管理 点击分支管理→ 对应用信息进行分支管理。 修改应用信息 点击修改应用→ 对应用信息进行修改。 停用/启用应用信息 点击 停用→ ，如： “猪齿鱼研发” 已停用，应用详情不可查看。 点击 启用→ ，如： “猪齿鱼研发” 已启用，可对该应用进行相关操作。 "},"/docs/user-guide/continuos-delivery/Continuous delivery-container management":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-container management","title":"容器管理","description":"","body":"容器管理 容器的含义为每个容器中都运行一个应用并为该应用提供完整的运行环境。 容器管理是对容器状态、容器名称、应用、容器地址、容器日志、是否可用等情况信息的管理。 菜单层次：项目层 菜单路径：持续交付 > 容器 默认角色：项目所有者、源代码管理员、项目成员 查看容器管理详情 进入容器界面，通过列表信息观察应用状态、可用情况、创建时间； 点击容器日志→ 查看容器日志。 列表信息 状态：容器的状态分为以下五种，分别为Pending、Running、Succeeded、Failed和Unknown。 1）Pending：Kubernetes已经开始创建Pod，但是Pod中的一个或多个容器还没有被启动。比如Pod正处在应该被分配到哪个节点上这个调度过程中，或者Kubernetes还在从镜像仓库中下载Pod中容器镜像这个下载过程中。 2）Running：Kubernetes已经将Pod分配到节点上，并且Pod中的所有容器都启动了。还包括Pod中至少有一个容器仍然在运行状态，或者正在重新启动状态。 3）Succeeded：Pod中的所有容器都处在终止状态，并且这些容器是自主正常退出到终止状态的，也就是退出代码为0，而且Kubernetes也没有重启任何容器。 4）Failed：Pod中的所有容器都处在终止状态，并且至少有一个容器不是正常终止的，也就是退出代码不为0，或者是由于系统强行终止的。 5）Unknown：由于一些特殊情况无法获取Pod状态，比如由于网络原因无法同Pod所在的主机通讯。 容器名称：容器的名称。 应用：容器中的应用。 容器地址：容器的地址。 已创建：容器创建的时间。 "},"/docs/user-guide/continuos-delivery/Continuous delivery-deployment  Application":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-deployment  Application","title":"部署应用","description":"","body":"部署应用 部署应用是将一个版本的应用部署至指定环境的操作。 部署应用前期，需部署的应用及所操作的环境都是已创建状态，并且能正常运行。 应用管理和环境流水线可以帮助您梳理前期工作。 操作流程 选择前期所创建的应用； 选择版本； 选择环境；（若所选的环境为故障中，则不能完成部署应用操作） 确认配置信息； 选择部署模式；部署模式有新建实例和替换实例两种； 点击 部署 按钮，完成部署。 部署模式 新建实例：建立新的实例。 替换实例：替换之前所建立的实例。 "},"/docs/user-guide/continuos-delivery/Continuous delivery-domain name":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-domain name","title":"域名管理","description":"","body":"域名管理 域名管理是对相应的应用创建可访问域名，并可对其进行修改的管理。 目前Web前端及普通应用需配置域名，若不配置域名，不能进行外网访问该前端，只能查看系统提供的pod ip。 菜单层次：组织层 菜单路径：持续交付> 资源管理 默认角色：部署管理员 新建域名信息 点击 创建域名 ，选择需要配置域名的应用，并输入“域名”、“域名地址”、“路径”及选择网络，点击 创建 ； 创建成功后，域名将会出现在域名管理列表中。 编辑域名信息 点击页面右侧 按钮，进入修改域名界面后 对域名信息进行修改 最后保存。 删除域名信息 点击页面右侧 按钮，删除该域名。 若删除域名，该条数据将被永久删除，不可恢复! "},"/docs/user-guide/continuos-delivery/Continuous delivery-environment":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-environment","title":"环境流水线","description":"","body":"环境流水线 环境是指一个应用可以被部署的地方。常见环境有开发测试环境，预生产环境，生产环境等。平台自动为您的项目生成一条环境流水线，您可拖拽需要调整顺序的环境至目标位置。 环境流水线是面向平台管理员、项目创建者和项目所有者根据不同用途配置相对应的环境信息。可以创建环境，删除环境，及对环境详情信息进行编辑修改。 平台管理员 、项目创建者可以从组织层管理某组织的环境信息，这些环境会继承到该组织下的所有项目；项目所有者可以从项目层管理某项目的环境信息，由项目层创建的这些环境也会显示在对应的组织层；源代码管理员、项目成员仅可以从项目层查看该项目可用的环境列表（包括该项目上创建的及由组织上继承的）。 菜单层次：项目层 菜单路径：持续交付 >环境流水线 默认角色：项目所有者、源代码管理员、项目成员 新建环境 点击 创建 按钮； 输入 “环境编码” 、 “环境名称” 以及 “环境描述” ，点击 创建 按钮； 新环境默认新增在环境流水线的最后一个节点。 创建的环境可以任意拖拽，调换环境之间的位置； 查看环境流水线详情 进入持续交付后，点击 环境流水线 页签； 查看应用环境的运行情况； 在环境卡片中，点击复制指令→ 复制代码至Kubernetes运行，与平台建立链接。 在环境卡片中，点击修改环境→ 修改环境名称及描述。 在环境卡片中，点击禁用环境→ 当点击确认后，该环境将被禁用。 环境停用区 可在环境停用区查看已被停用的环境，点击卡片右上角启用按钮重新启用。 "},"/docs/user-guide/continuos-delivery/Continuous delivery-service version":{"url":"docs/user-guide/continuos-delivery/Continuous delivery-service version","title":"应用版本","description":"","body":"应用版本 应用版本是应用的版本记录，每提交一次修改后的代码，对应生成一个新的版本。 菜单层次：项目层 菜单路径：持续交付 > 应用版本 默认角色：项目所有者、源代码管理员、项目成员 查看应用版本详情 进入持续交付后，点击 应用版本 页签； 查看应用版本信息。 列表字段 应用版本：迭代升级中对应的不同版本。 应用编码：创建应用的自定义编码。 应用名称：创建应用的自定义名称。 创建时间：应用创建时的时间。 "},"/docs/user-guide/continuos-delivery/":{"url":"docs/user-guide/continuos-delivery/","title":"持续交付","description":"","body":"介绍 本节介绍持续交付（Continuous Delivery，简称CD） 持续交付是一种软件开发策略，用于优化软件交付的流程，以尽快得到高质量、有价值的软件。这种方法能帮助组织更快地验证业务想法，并通过快速迭代的方式持续为用户提供价值。 本页面介绍了研发团队在完成敏捷管理后进行产品开发时，如何管理服务、如何使用Git-Flow模型进行分支管理、如何查看持续集成流水线、如何管理服务版本、如何了解代码质量及如何进行服务发布。 功能 部署功能: 提供了部署功能，部署功能中包含了普通部署和灰度部署，普通部署又分为手动部署和自动部署，自动部署建议正式环境不启用。灰度部署目前Web前端和普通应用类型是使用自动生成域名的方式进行灰度部署，微服务是使用不同用户组方式进行灰度部署。部署功能中还提供取消部署，停止灰度部署，灰度部署转正式的功能。 持续集成: 持续集成（Continuous Integration，简称CI）是指开发过程中不断集成团队成员的代码，每次集成都可以通过自动化构建来实现，因此为开发人员节省大量的时间，让他们能更专注于实现业务逻辑。 本页面介绍了研发团队在完成敏捷管理后进行产品开发时，如何管理服务、如何使用Git-Flow模型进行分支管理、如何查看持续集成流水线、如何管理服务版本、如何了解代码质量及如何进行服务发布。 持续集成基本由敏捷开发团队所有成员完成，包括项目所有者、源代码管理员、项目成员。每个模块都包含其概念定义、主要功能及其他注意事项。 若您遇到无法访问对应功能，请联系对应负责人进行系统配置，特别是角色分配。 容器管理：容器管理是持续交付过程中的完成情况，包括状态、容器名称、应用、容器地址、是否可用等情况信息，从而生成容器日志。每个容器中都运行一个应用并为该应用提供完整的运行环境。 网络管理：网络管理是针对于应用，是为所选择的应用将网络信息注册至应用管理应用，取消网络，应用将无法访问。 域名管理：域名管理针对于Web前端和普通应用，为相应的服务按照一定的命名规则创建可访问的域名。域名可以随时修改。注意，若不配置域名，外网将不能访问服务。 "},"/docs/user-guide/continuos-delivery/application-template":{"url":"docs/user-guide/continuos-delivery/application-template","title":"应用模板","description":"","body":"应用模板 应用模板是将同类型应用的代码库结构整理成模板，用于创建应用时能引用相应模板快速创建初始代码库。 每种应用模板至少都包括CI文件以及Chart目录文件。 平台提供默认的常用模板，用户可以根据实际情况自定义符合更多需求的应用模板。 菜单层次：组织层 菜单路径：持续交付 > 应用模板 默认角色：平台管理员、项目创建者 新建应用模板 输入应用模板编码，名称，描述，创建默认最简模板。您也可以通过复制于现有模板，以便节省部分共同操作，提升效率。 点击创建应用模板按钮； 输入应用相关信息，点击创建按钮； 本地克隆应用模板对应的代码库。 一个正确的模板中应该包含: spring-boot项目+gitlab-ci.yml文件+dockerfile文件+charts模块 spring-boot项目: 模板项目 gitlab-ci.yml文件: 定义gitlab ci的阶段 dockerfile文件: 用于应用部署时生成镜像 charts模块: 用于创建应用时生成创建k8s对象 如:deployment job service ingress 部署时配置信息里的key-value值会被应用到对应的k8s对象中用于部署。 查看应用详情 在详情界面根据应用模板名称、应用模板编码、应用模板描述、应用模板地址、应用模板来源来查看应用详情。 列表字段 应用模板名称：应用模板的自定义名称。 应用模板编码：应用模板的自定义编码。 应用模板描述：应用模板的自定义描述。 应用模板地址：应用模板的git仓库地址。 应用模板来源：应用模板的来源。 修改模板信息 点击修改模板→ 按钮 ，进行应用模板名称和描述的修改。 删除模板信息 点击删除模板→ 按钮，进行模板的删除。 若删除模板，该条数据将被永久删除，不可恢复! "},"/docs/user-guide/scrum/1-story map":{"url":"docs/user-guide/scrum/1-story map","title":"故事地图","description":"","body":"故事地图 在开规划会议之前 用户可以按照角色，活动，任务分类来规划roadmap，整理用户故事，记录的用户故事将会被同步到gitlab的issue上，项目干系人可以在issue下放进行评论，对用户故事展开讨论。 菜单层次：项目层 菜单路径：敏捷管理 > 故事地图 默认角色：看板项目所有者、看板项目成员 使用故事地图 添加角色 角色：提出的用户需求是基于哪类角色考虑的。例如敏捷开发有三种角色，po，master和项目开发人员。 点击创建角色鼠标光标会变为加号，当出现加号图标时，用户在角色这一行任意位置单击，即可添加角色。 添加活动 活动:基于某一个角色下，具体的用户场景。 点击创建活动鼠标光标会变为加号，当出现加号图标时，用户在活动这一行任意位置单击，即可添加活动。 添加任务 任务：用户场景的细化。 点击创建任务鼠标光标会变为加号，当出现加号图标时，用户在任务这一行任意位置单击，即可添加任务。 创建发布计划 点击创建发布计划，即可在用户故事地图上面生成对应的发布计划，依次默认命名为发布计划1、发布计划2等，如果想修改发布计划名称或者删除发布计划，点击发布计划名称旁边的三点符号，可进行修改或者删除。处于安全考虑，已经有用户故事的发布计划，需要先删除里面的用户故事，才能删除整个发布计划。 创建卡片 用户故事：具体的需求。 在故事地图界面移动鼠标，见到卡片创建的提示时，点击提示卡中间的文字部分，也可以创建相应的卡片，比如角色，活动，任务，用户故事。 修改与删除卡片 修改卡片直接单击卡片，弹出卡片详情信息时即可修改标题。 删除卡片需要在没有子卡的情况下才能删除，否则提示相应报错信息。 故事地图工具栏介绍 未规划区的使用 点击未规划区，会出现一个侧边栏，如下图所示，在侧边栏中会放入您在其他界面创建的不属于任何发布计划的故事，比如您在用户故事界面创建了一个未选择发布计划的用户故事，就会以一张故事卡的形式出现在此处，顶部的搜索和过滤可以进行高级搜索，找到您想要的卡片，您考虑好此故事放在哪个发布计划下比较合适时，也可以拖动到具体的发布计划下。 数据统计 此项目下的数据进度的分析，可一键从此入口进入，也可去数据洞察界面选择具体项目查看。 导出为图片 点击导出为图片，即可把当前的地图以图片形式保存下来，导出格式为png。 放大缩小 点击放大缩小标志，或者拖动放大缩小的滚动条，都可完成整个地图的放大缩小。 "},"/docs/user-guide/scrum/2-user story":{"url":"docs/user-guide/scrum/2-user story","title":"用户故事","description":"","body":"用户故事 用户故事界面是用户故事的列表展现形式，在这里可以集中查看您创建的所有的用户故事，以及其下的任务缺陷等，方便快捷。 菜单层次：项目层 菜单路径：项目 > 敏捷管理 > 故事管理 > 用户故事 默认角色：看板项目所有者、看板项目成员 创建用户故事 点击创建故事，出现详情信息编辑的窗口，在窗口中进行编辑，编辑完成之后点击保存。 搜索用户故事 点击过滤可以进行高级搜索 删除用户故事 未进入冲刺的用户故事可以删除。 快捷创建任务 可以快捷创建用户故事下面的任务。 快捷创建缺陷 可以快捷创建用户故事下面的缺陷。 "},"/docs/user-guide/scrum/3-task":{"url":"docs/user-guide/scrum/3-task","title":"任务","description":"","body":"任务 可以查看您创建的所有任务，可视化您的任务流，同时后台会记录所以操作的时间数据，帮您完成数据分析和记录工作。 菜单层次：项目层。 菜单路径：项目 > 敏捷管理 > 任务和漏洞 > 任务。 默认角色：看板项目所有者、看板项目成员 查看任务 在任务界面，您可以查看您所有创建的任务，并且可以高级搜索您要找的任务。 删除任务 可以在中完成删除，快捷创建缺陷的快捷操作 漏洞 可以查看您创建的所有漏洞。 菜单层次：项目层。 菜单路径：项目>敏捷管理>任务和漏洞>漏洞。 默认角色：看板项目所有者、看板项目成员 查看缺陷 在任务界面，您可以查看您所有创建的缺陷，并且可以高级搜索您要找的缺陷。 删除缺陷 可以在中完成删除缺陷。 "},"/docs/user-guide/scrum/4-bug":{"url":"docs/user-guide/scrum/4-bug","title":"漏洞","description":"","body":"漏洞 可以查看您创建的所有漏洞。 菜单层次：项目层。 菜单路径：项目>敏捷管理>任务和漏洞>漏洞。 默认角色：看板项目所有者、看板项目成员 查看缺陷 在任务界面，您可以查看您所有创建的缺陷，并且可以高级搜索您要找的缺陷。 删除缺陷 可以在中完成删除缺陷。 "},"/docs/user-guide/scrum/5-sprint":{"url":"docs/user-guide/scrum/5-sprint","title":"冲刺","description":"","body":"冲刺 在冲刺中，可方便为您管理一个迭代周期内要完成的故事，并为您进行后台数据监测，可视化故事完成的情况，冲刺作为用户故事地图和看板的衔接环节，开启冲刺之后才能使用看板的全部功能。 菜单层次：项目层 菜单路径：项目 > 敏捷管理 > 冲刺管理 > 冲刺 默认角色：看板项目所有者、看板项目成员 创建冲刺 点击`创建冲刺，选择发布计划，输入冲刺名称，选择预计的冲刺起止时间(不必输)，即可创建一个新的冲刺。 搜索冲刺 可以在工具栏进行搜索。 开启/关闭冲刺 可以快捷开启或者关闭冲刺，完成状态切换。 点击开启冲刺可开启当前冲刺，开启之后，数据洞察就开始记录当前冲刺的数据。冲刺内添加的故事也会自动导入看板中，并放在第一列。 点击关闭冲刺可关闭当前冲刺，关闭之后不能再开启。 编辑冲刺信息 可以修改冲刺的具体信息，如冲刺名称，开始和结束时间，但是发布计划不允许修改。 添加故事 选择故事来源，从故事地图，或者未规划的故事中，勾选需要导入的故事，点击确定，添加到冲刺中，添加进冲刺的故事，在故事地图界面的颜色会与没有导入冲刺的颜色有一个变化。 创建任务 可以创建进入到冲刺中的用户故事下的具体任务。 创建缺陷 可以创建用户故事下或者任务下测试出现的bug。 筛选故事 可以对故事，任务和缺陷进行分类筛选。 移除故事 可以把导入冲刺的故事移除，移除后不会在故事地图里面删除，只是故事地图中的卡片颜色会变为未导入状态。也可以导入到其他冲刺中。 "},"/docs/user-guide/scrum/6-board":{"url":"docs/user-guide/scrum/6-board","title":"看板","description":"","body":"看板 开启冲刺之后才能使用看板的全部功能。看板可以取代物理看板，也可以可视化您的工作流，同时后台会记录所以操作的时间数据，帮您完成数据分析和记录工作。 菜单层次：项目层。 菜单路径：项目>敏捷管理>冲刺管理>看板。 默认角色：看板项目所有者、看板项目成员 选择模板 进入看板之后，先根据您的需要，选择一个看板模板，单击某个模板，可查看详情，双击就会为您选择当前模板并打开，看板界面没有卡片时，您也可以更换模板。 开启冲刺后看板展示 进入看板之后，您在当前开启的冲刺中添加的故事，会自动为您导入到当前看板，并放在SprintBacklog里面（第一列） 创建卡片 点击创建卡片，出现卡片详情编辑的窗口，选择卡片类型，故事，任务，缺陷，可创建对应类型的卡片，创建的卡片会同步到故事地图界面，放在当前发布计划的第一个角色的第一个任务列里。 看板绘制 点击看板绘制进入看板编辑界面： 1)增加列 2)绘制泳道 3)增加/减少列高 4)撤销/恢复 5)保存 6)在制品和起始列设置 拖动故事卡 点击故事卡，可按需在子卡处拖动任务卡或bug卡至看板对应位置。 "},"/docs/user-guide/scrum/":{"url":"docs/user-guide/scrum/","title":"敏捷管理","description":"","body":"介绍 敏捷管理服务简单说就是灵活+快速，既满足产品开发过程中需求的动态变化，又能通过短迭代管理监控项目的实时效果。敏捷管理方法充分考虑到了可能出现的不确定性因素，同时具有鲜明的创造性。它的结构是围绕着学习过程建立的，这样一来，团队既可以评估已经取得的成果，同样重要的是，也可以评估取得这些成果的方法。这种架构能够为团队提供更加高效的工作方式，帮助他们更好地自我组织，提高工作速度，改进工作质量。 功能 集成Gitlab，实现用户故事、任务、漏洞、冲刺等卡片的创建、更新、删除、查询。 项目创建后默认创建空白看板，可根据项目的需要选择合适的看板模板，用户也可自定义绘制看板。支持看板内卡片的拖动以及状态的实时更新。 根据项目的需求可创建冲刺，用户故事来源于故事地图里的发布计划。 用户可同时开启一个冲刺，对应的卡片会同步到看板中，实现冲刺与看板一对一的关系。 关闭冲刺后将当前看板保存为历史看板，以及将未完成的用户故事退回到故事地图中，同时将其下的任务、缺陷删除。 实现用户故事、任务、缺陷的全局查询，以及快捷方式创建、修改、删除。 集成文件服务、minio等对项目附件集中存储，提供附件的上传、下载、删除功能。 "},"/docs/user-guide/system-configuration/":{"url":"docs/user-guide/system-configuration/","title":"系统配置","description":"","body":"介绍 本页面介绍了用户使用系统功能前需要进行的系统配置，以便不同用户可以进行敏捷管理、持续交付等操作。该系统配置基本由平台管理员、项目创建者、项目所有者等高权限角色完成。每个模块都包含其概念定义、主要功能及其他注意事项。 功能 IAM和管理 IAM (Identity & Access Management)身份和访问管理的基础概念。Choerodon支持IAM，即管理谁（identity）对哪个资源有什么访问权限（role）。 使用IAM，你能允许对特定Choerodon资源的访问，并且阻止对其他资源的不必要的访问。 个人中心 用户信息维护用于让用户管理自己的信息，包括头像、用户名、邮箱、语言、时区，由于登录名是用户的标识，不可以修改登录名。 "},"/docs/user-guide/system-configuration/iam/Org1_project":{"url":"docs/user-guide/system-configuration/iam/Org1_project","title":"项目管理","body":"项目管理 项目管理是对项目的信息和启用状态的管理。进入某一个项目，在该项目下创建项目，则创建的项目属于该项目。在创建的项目中，可以在项目中给成员分配项目层角色。 层级： 组织层 项目列表 列表字段： 项目名称：项目的名称。 项目编码：项目编码具有唯一性，是项目的标识。 启用状态：启用状态有启用和停用两种形态。当启用状态为启用时，项目正常运行，可进入该项目中进行其他操作；当启用状态为停用时，无法进入该项目。创建成功一个项目后，该项目的启用状态默认为启用。 项目查询 可查询字段： 项目名称：项目的名称。 项目编码：项目编码具有唯一性，是项目的标识。 启用状态：启用状态有启用和停用两种。当启用状态为启用时，项目正常运行，可进入该项目中进行其他操作；当启用状态为停用时，无法进入该项目。创建成功一个新项目后，新项目的启用状态默认为启用。 创建项目 必填字段： 项目名称：项目的名称。该字段是必输的。 项目编码：项目编码具有唯一性，是项目的标识。该字段是必输的 编码只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头。 修改项目 不可修改字段： 项目编码：项目编码具有唯一性，是项目的标识。项目创建成功后，项目编码不可更改。 可修改字段： 项目名称：项目的名称。该字段是必输的 启用/停用项目 停用项目：项目的启用状态为启用时，可进行停用项目的操作。停用项目后，项目的启用状态变为停用，不可进入该项目。 启用项目：项目的启用状态为停用时，可进行启用项目的操作。启用项目后，项目的启用状态变为启用，可进入该项目进行项目设置、项目角色分配等操作。 "},"/docs/user-guide/system-configuration/iam/Org2_user":{"url":"docs/user-guide/system-configuration/iam/Org2_user","title":"用户管理","body":"用户管理 一个组织下可以有多个用户，一个用户必须且只能属于一个组织。在某个组织下创建用户，则这个用户属于该组织。 层级： 全局层 用户列表 列表字段： 登录名：登录名具有唯一性，是用户的标识。在登录平台时，可用登录名密码方式登录。在给用户分配角色时，需要输入用户的登录名。 用户名：用户的昵称。 认证来源：为LDAP用户时，密码将从LDAP所访问的外部系统中获取；非LDAP用户无法在本平台设置密码。 启用状态：用户的启用状态为启用时，用户可以登陆平台；启用状态为停用时，用户无法登陆平台。 安全状态：当登录安全策略启用时，如果用户输错密码次数大于登陆安全策略里的最大密码输错次数，则用户被锁住，在一定时间内无法登录平台，安全状态为\"锁住\"；否则，安全状态为“正常”。 用户查询 可查询字段： 登录名：登录名具有唯一性，是用户的标识。 用户名：用户的昵称。 认证来源：分为LDAP用户和非LDAP用户两种。 启用状态：分为启用和停用两种。 安全状态：分为正常和锁住两种。 创建用户 必填字段： 登录名：登录名具有唯一性，是用户的标识。在登录平台时，可用登录名密码方式登录。在给用户分配角色时，需要输入用户的登录名。 用户名：用户的昵称。 邮箱：一个邮箱只能被一个用户使用。用户需填写真实有效的邮箱。邮箱可用于登录平台、找回密码。 密码：用户登录系统所需的密码。须符合密码策略。 确认密码：两次密码输入要一致。 语言:默认为简体中文。 时区：默认为北京时间。 修改用户 不可修改字段： 登录名：登录名具有唯一性，是用户的标识。用户创建成功后，不可更改登录名。 可修改字段： 用户名：用户的昵称。 邮箱：一个邮箱只能被一个用户使用。用户需填写真实有效的邮箱。邮箱可用于登录平台、找回密码。 密码：用户登录系统所需的密码。须符合密码策略。 确认密码：两次密码输入要一致。 语言:默认为简体中文。 时区：默认为北京时间。 启用/停用用户 用户不可以被删除，可以被启用/停用。 停用用户：用户被停用之后，无法被分配角色，无法登录系统。 启用用户：用户被启用之后，可以被分配角色，可以登录系统。 解锁用户 当密码策略中的登录安全策略被启用时，如果用户输错密码的次数大于登录安全策略中设置的最大密码输错次数，则用户被锁住，在一定时间内无法登录平台。 当用户的安全状态为锁住时，可以解锁该用户。解锁成功后，用户的安全状态变为正常，用户可以被分配角色，可以正常登录系统。 "},"/docs/user-guide/system-configuration/iam/Org3_user_group":{"url":"docs/user-guide/system-configuration/iam/Org3_user_group","title":"用户组管理","body":"用户组管理 用户组是为了便于DevOps中灰度部署。在DevOps中，同一用户组里的用户能访问一个特定网关，不同用户组之间访问的网关可设置为不一样。这里的用户组管理，只是对用户组信息和用户组成员的管理。 层级： 组织层 创建用户组 必填字段： 用户组编码：具有唯一性。 用户组名：填写用户组的名称 用户组描述：附加的对用户组的描述信息 其他操作 删除：删除会删除用户组信息及与用户组关联的数据 编辑：不可编辑用户组编码，可编辑用户组名、用户组描述 搜索： 不选择属性，根据输入值进行全局搜索 选择一个属性：组ID(创建用户组时默认生成)、组编码、组名、描述，输入相应的属性值进行搜索 管理用户组用户 添加用户：选中添加用户选项后，进入到系统全用户列表，根据搜索条件查找用户进行勾选添加 删除用户：展开用户组，出现该用户组的用户列表，可直接进行删除操作 "},"/docs/user-guide/system-configuration/iam/Org4_client":{"url":"docs/user-guide/system-configuration/iam/Org4_client","title":"客户端管理","body":"客户端管理 客户端管理是对多个客户端信息设置的管理。配置文件中应用指定的客户端后，登录后跳转页面指向的该客户端设定的网址。 层级： 组织层 客户端列表 列表字段： 序号：从1开始加1递增。按客户端的创建时间排序。创建时间按先到后序号依次递增。 客户端ID:客户端ID具有唯一性 是客户端的标识。 授权类型：客户端必须得到用户的授权（authorization grant），才能获得令牌（access token），进而凭令牌获取本平台资源。目前平台提供password、implicit、client_credentials、authorization_code和refresh_token五种授权方式。 客户端查询 可查询字段： 客户端ID:客户端ID具有唯一性 是客户端的标识。可根据客户端ID模糊搜索。 创建客户端 必填字段: 客户端ID:客户端ID具有唯一性 是客户端的标识。 密钥：使用客户端的密码。例如用户登陆需要用户名和密码，密钥相当于密码。 授权类型：客户端必须得到用户的授权（authorization grant），才能获得令牌（access token），进而凭令牌获取本平台资源。下面提供了五种授权方式： password：密码模式，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向\"服务商提供商\"索要授权。 implicit：简化模式，不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了\"授权码\"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 client_credentials：客户端模式，客户端以自己的名义，而不是以用户的名义，向\"服务提供商\"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求\"服务提供商\"提供服务，其实不存在授权问题。 authorization_code：授权码模式，是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与\"服务提供商\"的认证服务器进行互动。 refresh_token：表示早前收到的更新令牌，如果用户访问的时候，客户端的\"访问令牌\"已经过期，则需要使用\"更新令牌\"申请一个新的访问令牌。 选填字段： 访问授权超时：access_token_validity assecc token的有效时间。 授权超时：refresh_token_validity refresh token的有效时间。 重定向地址：用户的登陆后从登陆界面跳转的地址。 附加信息：用json格式添加客户端的附加信息。如{ \"description\": \"string\"，\"name\": \"string\"}。 修改客户端 不可修改字段： 客户端ID:客户端ID具有唯一性 是客户端的标识。客户端创建成功后，客户端ID不可更改。 可修改字段： 密钥：使用客户端的密码。例如用户登陆需要用户名和密码，密钥相当于密码。 授权类型：客户端必须得到用户的授权（authorization grant），才能获得令牌（access token），进而凭令牌获取本平台资源。 访问授权超时：access_token_validity assecc token的有效时间。 授权超时：refresh_token_validity refresh token的有效时间。 重定向地址：用户的登陆后从登陆界面跳转的地址。 附加信息：用json格式添加客户端的附加信息。如{ \"description\": \"string\"，\"name\": \"string\"}。 删除客户端 点击删除图标，即可删除客户端。 "},"/docs/user-guide/system-configuration/iam/Org5_LDAP":{"url":"docs/user-guide/system-configuration/iam/Org5_LDAP","title":"LDAP管理","body":"LDAP LDAP管理是对组织应用的LDAP信息设置的管理。LDAP只针对LDAP用户，LDAP用户的登录名和密码取自LDAP指向的外部系统中的数据。 层级： 组织层 修改LDAP 必填字段： LDAP名称：通过应用LDAP访问LDAP 目录服务器中注册的用户、群组条目，方便统一管理用户的密码登陆方式 选填字段： 服务器地址：LDAP要访问的服务器地址 LDAP属性名：要访问的数据的名称 加密方式：分为SSL、TSL、STARTTLS三种 基础DN：获取数据的路径 描述：对该LDAP得附加信息 "},"/docs/user-guide/system-configuration/iam/Org6_secret_policy":{"url":"docs/user-guide/system-configuration/iam/Org6_secret_policy","title":"密码策略","body":"密码策略 密码策略是对组织应用的密码安全策略和登录安全策略的信息设置的管理。当应用密码安全策略时，同组织下用户的密码设定和修改都要遵守该密码规则；当应用登录安全策略时，同组织下用户登录系统时的密码输入情况要遵守该登录规则。 层级： 组织层 密码安全策略 密码安全策略为用户的密码创建或更改时需要满足的规则。修改完密码安全策略后，点击保存，修改的内容生效。 是否启用：如果启用，密码安全策略的其他字段保存后生效；否则，不生效。 不可与登录名相同：选择是，则用户的密码不能有用户的登录名相同；否则，可以与登录名相同。 最小密码长度：设置密码时，密码长度不能小于填入的最小密码长度。 最大密码长度：设置密码时，密码长度不能大于填入的最大密码长度。为空时，表示没有最大密码长度，即密码长度可以无限大。 最少小写字母数：密码中至少应包含的小写字母数。 最少大写字母数：密码中至少应包含的大写字母数。 最少特殊字符数：密码中至少应包含的特殊字符数。 最大近期密码数：与最近使用的n次密码不能相同。例：若填入数值为3，则表示不能与最近3次历史密码相同。 密码正则：定义针对给定文本检查的匹配模式，通过填入特定的正则表达式来制定密码规则。 登录安全策略 登录安全策略为用户使用密码登录平台时的规则。修改登录安全策略后，点击保存，修改的内容生效。 是否启用：如果启用，登录安全策略的其他字段保存后生效；否则，不生效。 开启验证码：如果开启，当用户密码输错次数大于设置的输错次数的值时，出现验证码；如果不开启，则不会出现验证吗。 输错次数：密码输错次数超过填写的输错次数后，，出现验证码。 开启锁定：如果开启，当用户密码输错次数大于设置的输错次数的值时，用户将会被锁定，无法登录系统。 输错次数：当用户密码输错次数大于设置的输错次数的值时，用户将会被锁定，无法登录系统。 锁定时长：用户被锁定后，经过输入的密码输错锁定时间后，系统自动将该用户解锁，该用户可重新进行输入密码登入系统的操作. "},"/docs/user-guide/system-configuration/iam/Pro1_project":{"url":"docs/user-guide/system-configuration/iam/Pro1_project","title":"项目设置","body":"项目设置 进入一个项目后，可以修改项目信息和停用项目。 层级： 项目层 修改项目信息 可修改字段： 项目名称:可以对项目的名称进行修改。项目编码是项目的标识，不可修改。 停用项目 可以停用此项目。停用后，无法进入该项目。如果需要再次启用此项目，需要在项目管理中对该项目进行启用操作。 "},"/docs/user-guide/system-configuration/iam/Site1_system":{"url":"docs/user-guide/system-configuration/iam/Site1_system","title":"系统设置","body":"系统设置 用于设置平台的Logo和名称、平台导航栏的功能。平台的Logo和名称显示在平台的登录界面、导航栏左上角、网页标签页。 层级： 全局层 修改系统设置 平台Logo：可以对平台的Logo进行修改，其格式为PNG、JPG、JPEG格式，且不能大于256KB。 平台名称：可以对平台的的名称进行修改。 是否开启调试：开启调试，导航栏显示调试按钮，点击调试按钮，界面将显示每个功能所需的权限。关闭调试，导航栏不显示调试按钮。 "},"/docs/user-guide/system-configuration/iam/Site2_organization":{"url":"docs/user-guide/system-configuration/iam/Site2_organization","title":"组织管理","body":"组织管理 组织是项目的集合。组织管理是对组织信息和启用状态的管理。 组织下的项目、用户、客户端的管理需进入到一个特定的组织进行组织层的操作。一个项目只能属于一个组织，但一个组织下可以有多个项目。一个用户只能属于一个组织，但一个组织下可以有多个用户。 层级： 全局层 组织列表 列表字段： 组织名称：组织的名称。 组织编码：组织编码具有唯一性，是组织的标识。 启用状态：启用状态有启用和停用两种。当启用状态为启用时，组织正常运行，可进入该组织中进行其他操作；当启用状态为停用时，无法进入该组织。一个新组织创建成功后，新组织的启用状态默认为启用。 组织查询 可查询字段： 组织名称：组织的名称。 组织编码：组织编码具有唯一性，是组织的标识。 启用状态：启用状态有启用和停用两种。当启用状态为启用时，组织正常运行，可进入该组织中进行其他操作；当启用状态为停用时，无法进入该组织。一个新组织创建成功后，新组织的启用状态默认为启用。 创建组织 必填字段： 组织名称：组织的名称。该字段是必输的。 组织编码：组织编码具有唯一性，是组织的标识。该字段是必输的 编码只能包含字母，数字，下划线，空格， '_' '.' \"——\" 只能以字母，数字，下划线开头 编辑组织 组织创建成功后，组织编码不可更改。 可编辑字段： 组织名称：组织的名称。该字段是必输的 启用/停用组织 停用组织：组织的启用状态为启用时，可进行停用组织的操作。停用组织后，组织的启用状态变为停用，不可进入该组织。 启用组织：组织的启用状态为停用时，可进行启用组织的操作。启用组织后，组织的启用状态变为启用，可进入该组织进行组织的用户管理、项目管理等操作。 "},"/docs/user-guide/system-configuration/iam/Site3_menu_configuration":{"url":"docs/user-guide/system-configuration/iam/Site3_menu_configuration","title":"菜单配置","body":"菜单配置 菜单配置用于配置平台菜单。进入管理中心、某一个组织、某一个项目、个人中心都需要菜单进行功能导航。因此，菜单配置按层级划分为全局层、组织层、项目层、用户层，且某一层级下只能配置相同层级的菜单。 层级： 全局层 菜单配置列表 按菜单层级的方式查看菜单列表。一共分为全局层、组织层、项目层、用户层，不同的层级对应不同的层级位置的菜单。按全局层查看时，列表为用户在管理中心看到的菜单（默认该用户有全局层所有权限）；按组织层查看时，列表为用户进入每一个组织看到的菜单（默认该用户有组织层所有权限）；按项目层查看时，列表为用户进入每一个项目看到菜单（默认该用户有项目层所有权限）；按用户层查看时，列表为用户进入到个人中心的菜单。 列表字段： 目录/菜单：目录、菜单的名称。预置目录、菜单的名称无法修改，自设目录的名称可修改。 图标：目录、菜单的图标。预置目录、菜单的图标无法修改，自设目录的图标可修改。 编码：目录、菜单的编码具有唯一性。 所属预置目录：只有菜单才有所属预置目录。 类型：分为目录和菜单两种，目录分为预置目录和自设目录两种。其中预置目录和菜单是系统定义的，用户无法修改，用户只能对自设目录进行创建、修改、删除。目录（包括预置目录和自设目录）和菜单为树型关系，菜单只能处于叶子位置，目录能处于根或分支的位置。预置目录和菜单的关系为从属关系，一个菜单必须属于一个预置目录，该关系为系统定义，用户无法修改。预置目录和自设目录为系统预定义目录和用户自定义目录的关系，预置目录无法创建、修改、删除，自设目录可以创建、修改、删除。 菜单详情 菜单是系统配置的，用户无法创建、修改菜单，只能查看菜单详情。 详情字段: 菜单名称：菜单的名称，根据菜单功能定义菜单名称。 菜单编码：菜单编码具有唯一性，是菜单的标识。 菜单层级：菜单有层级性，只能在相同的层级配置菜单。例如，在项目层只能配置菜单层级为项目层的菜单。 所属预置目录：一个菜单必须且只能属于一个预置目录。 菜单权限：要实现菜单里所有功能需要的权限。 创建自设目录 必填字段： 目录名称：用户可根据需要自定义名称。 目录编码：目录编码具有唯一性，是目录的标识。 目录图标：目录的图标可在系统提供的图标库中选择。 修改自设目录 不可修改字段： 目录编码：目录编码具有唯一性，是目录的标识。所以目录一旦成功创建，不可修改。 可修改字段： 目录名称：用户可根据需要自定义名称。 目录编码：目录编码具有唯一性，是目录的标识。 目录图标：目录的图标可在系统提供的图标库中选择。 删除自设目录 只有自设目录可删除，预置目录和菜单不可是系统定义的，无法删除。 如果目录下有菜单，则不可删除该目录；只有当目录下无菜单时，可删除该目录。例如，在一个目录A下有目录B，目录A可以被删除；在一个目录C下有目录D，目录D下有菜单1、菜单2，目录C、目录D不可被删除。 调整结构 将鼠标移至列表字段目录/菜单，会显示一个虚线框，该虚线框内则为鼠标长按拖动时可拖动的内容。如果一个目录下没有菜单，则不显示该目录。 如果鼠标悬停在目录上，虚线框内则为此目录和该目录下的所有目录/菜单，鼠标长按时可拖动此目录和该目录下的所有目录/菜单；若该目录下无目录/菜单，则虚线框内只有这个目录，鼠标长按时只可拖动这个目录； 如果鼠标悬停在菜单上，虚线框内只有这个菜单，鼠标长按只可拖动这个菜单。 "},"/docs/user-guide/system-configuration/iam/Site4_role":{"url":"docs/user-guide/system-configuration/iam/Site4_role","title":"角色管理","body":"角色管理 角色是一组特定权限的集合。因此，通过给成员分配角色来赋予成员权限。角色只有属于一个层级，给角色分配权限时只能分配相同层级的权限。在一个层级中给成员分配角色时，只能分配相同层级的角色。 层级： 全局层 角色列表 列表字段： 角色名称：角色名称是根据角色权限的集合定义的。在角色分配中的角色列表里面显示的为角色名称。 角色编码：角色编码具有唯一性，是角色的标识。 角色层级:一个角色只能选择一个层级。一共有全局层、组织层、项目层三种层级可供选择。 角色来源：角色分为用户自定义角色和预置角色，所以角色来源有自定义和预定义两种。用户自定义角色是用户在角色管理界面所创建的角色。预置角色是系统内置的角色，只能查看预置角色，基于预置角色创建新的角色，不能编辑和停用预置角色。 启用状态：是否启用字段有'启用'和'停用'两种值。角色的是否启用字段的值为'启用'时，在角色分配中可以看到该角色，因而可以选择该角色；否则，为'停用'时，在角色分配中不可看到该角色，因而无法选择该角色。 角色查询 可查询字段： 角色名称：角色的名称。可以模糊搜索。 角色编码：角色的编码。是角色标识。可以模糊搜索。 角色层级：分全局层、组织层、项目层三种。 角色来源：分预定义和自定义两种。 启用状态：分启用和停用两种。 创建角色 必填字段： 角色名称：角色的名称应该根据角色权限集合特征定义。 角色层级：角色层级分为全局层、组织层、项目层三种。一个角色只能属于一个层级。 角色编码：角色编码具有唯一性，是角色的标识。用户可自定义。角色创建成功后生成的角色编码为role/层级/custom/用户自定义角色编码，其中role和custom为常量，role表示角色这个大类，custom表示角色来源为用户自定义，即用户在界面创建的角色；层级和用户自定义编码为变量，层级为用户所选的角色层级，用户自定义角色编码为用户在角色编码输入框中所填写的值。 角色权限：权限层级与角色层级相同。创建角色时，至少要选择一个角色权限。 选填字段： 角色标签：用于控制平台外部角色的权限。例如，在角色标签gitlab-master与Gitlab系统中的Master角色相关联，若角色A有角色标签gitlab-master 角色B有角色标签gitlab-master，则Gitlab系统中的Master角色就有角色A和B的所有权限。 根据所选角色创建角色 可以选择多个角色，基于这些选择的角色创建一个新的角色。但是多选时，选择的角色只能为同一层级，不能为不同的层级。 不可填字段： 角色层级：新角色的层级与所选角色的层级相同，不可更改。 必填字段： 角色名称：角色的名称应该根据角色权限集合特征定义。 角色编码：角色编码具有唯一性，是角色的标识。用户可自定义。角色创建成功后生成的角色编码为role/层级/custom/用户自定义角色编码，其中role和custom为常量，role表示角色这个大类，custom表示角色来源为用户自定义，即用户在界面创建的角色；层级和用户自定义编码为变量，层级为用户所选的角色层级，用户自定义角色编码为用户在角色编码输入框中所填写的值。 角色权限：新角色的角色权限为所选角色权限的并集。可以后继删除或添加权限，至少要有一个角色权限。 选填字段： 角色标签：用于控制平台外部角色的权限。例如，在角色标签gitlab-master与Gitlab系统中的Master角色相关联，若角色A有角色标签gitlab-master 角色B有角色标签gitlab-master，则Gitlab系统中的Master角色就有角色A和B的所有权限。 编辑角色 预定义角色不可编辑，只能编辑用户自定义的角色。 不可编辑字段： 角色层级：因为权限的层级是根据角色层级而定的，如果角色层级更改，则与之前已选权限的角色层级不同，这与系统的角色-权限关联规则矛盾，所以角色一旦创建成功，角色层级不可更改。 角色编码：因为角色编码具有唯一性，是角色的标识，所以角色一旦创建成功，角色编码不可更改。 可编辑字段： 角色名称：应该根据角色的权限特性进行命名，这样分配角色的时候可以直观的选择角色。 角色标签：用于控制平台外部角色的权限。例如，在角色标签gitlab-master与Gitlab系统中的Master角色相关联，若角色A有角色标签gitlab-master 角色B有角色标签gitlab-master，则Gitlab系统中的Master角色就有角色A和B的所有权限。 角色权限：可以增加或删除角色的权限。 启用/停用角色 预定义角色不可停用，只能启用/停用用户自定义角色。 停用角色：只能停用用户自定义角色。停用角色后，角色状态变为'未启用'。赋予给该角色的权限将失效，即使这个角色已经被分配给了用户。并在角色分配中，不再显示该角色。 启用角色：用户自定义角色被停用后，可以再次启用。启用角色后，角色状态变为'启用'。赋予该角色的权限生效。并在角色分配中，显示该角色。 "},"/docs/user-guide/system-configuration/iam/Site5_role-assignment":{"url":"docs/user-guide/system-configuration/iam/Site5_role-assignment","title":"角色分配","body":"角色分配 角色分配时，可以给一到多个成员分配一到多个角色。角色是权限的集合，给成员分配角色即给成员赋予权限。权限与角色都具有层级性，且角色权限的层级必须与角色层级相同。角色分配具有层级性，角色分配中被分配的角色层级必须与角色分配的层级相同。即，在某一层级的角色分配中，只能给用户分配对应的层级的角色，只能给角色分配对应层级的权限。例如，在全局层角色分配中，只能给用户分配全局层角色，分配后用户具有使用全局层权限。 层级： 全局层 组织层 项目层 成员角色列表 列表查看方式： 按成员查看：列表项为成员信息和该成员的所有角色。可以直接对成员的角色进行更改操作。 按角色查看：列表项为角色。展开角色后，展示信息为角色下的成员信息。可以直接对角色下的成员进行更改操作。 列表字段-按成员查看时： 成员：若成员为用户，则为用户的登录名；若成员为微服务，则为微服务名称。 名称：若成员为用户，则为用户的用户名。 角色：角色名称。可以为一到多个。每一个角色都可以在列表中直接删除，或点击编辑，进入编辑成员角色的界面更改成员的角色。 成员类型：成员类型可以为用户、微服务。 列表字段-按角色查看时： 角色/成员：列表的列表项为角色名称。列表项展开后的子列表为角色下的成员 若成员为用户，则为用户的登录名；若成员为微服务，则为微服务名称。 名称：若子列表中的成员为用户，则名称为用户名。 成员角色查询 可查询字段: 成员：若成员为用户，按用户的登录名查找；若成员为微服务，按微服务名称查找。 名称：若成员为用户，按用户的用户名查找。 成员类型：分用户和微服务两种。 角色：按角色名称查找。 添加成员角色 添加新的成员角色之间的关联。如果成员已经被分配过角色，则将本次操作新增的与该成员有关的成员角色关联合并到已有关联列表，即已有的不变，新增的增加。 层级规则： 全局层角色分配的添加成员角色为，在平台中，给成员添加全局层的角色。例如，在Choerodon这个平台中，给登录名为123的用户添加管理员的角色，且管理员这个角色满足角色层级为全局层的条件。 组织层角色分配的添加成员角色为，在一个组织中，给成员添加组织层角色。例如，在运营组织这个组织中，给登录名为123的用户添加组织管理员的角色，且组织管理员这个角色满足角色层级为组织层的条件。 项目层角色分配的添加成员角色为，在一个项目中，给成员添加组织层角色。例如，在Choerodon这个项目中，给登录名为123的用户添加项目管理员的角色，且项目管理员这个角色满足角色层级为项目层的条件。 对应规则： 成员输入一个到多个。如果成员为用户，则输入用户的登录名，若成员为应用，则输入应用名称。 角色选择一到多个。根据角色名称进行选择。可以对角色名称进行过滤。 移除成员角色 可以进行批量删除，即可以一次性删除与某个成员或角色有关的所有成员角色关联。 按成员查看时：勾选一或多个成员，点击移除，批量删除所选成员和成员下所有角色的关联关系。 按角色查看时：勾选一或多个角色，点击移除，批量删除所选角色和角色下所有成员的关联关系。 删除成员角色 按成员查看时，点击删除图标，可直接删除与该成员有关联的角色，即删除了一个成员角色关联。 按角色查看时，点击删除图标，可直接删除与该角色有关联的成员，即删除了一个成员角色关联。 按成员或角色查看是，点击编辑图标，进入编辑成员的角色界面，点击删除图标，可删除与成员有关联的一个角色。 编辑成员的角色 点击编辑图标，进入编辑一个成员的所有角色界面，可编辑该成员的角色关联。即可以删除角色，更改已有角色，添加其他角色。只有上一个角色已选时才可以继续添加其他角色。 "},"/docs/user-guide/system-configuration/iam/":{"url":"docs/user-guide/system-configuration/iam/","title":"IAM和管理","description":"","body":"介绍 本节介绍IAM (Identity & Access Management)身份和访问管理的基础概念。 Choerodon支持IAM，即管理谁（identity）对哪个资源有什么访问权限（role）。 使用IAM，你能允许对特定Choerodon资源的访问，并且阻止对其他资源的不必要的访问。 与身份有关的概念 在IAM，你能对成员（member）授予访问权限。成员可以是以下类型： 用户（user） 客户端（client） 用户（user） 用户，代表一个独立的个体。在这里，用户是指在Choerodon有身份认证的任何人。(例如：游客、匿名用户不包括在用户里面) 用户有唯一的标识【用户名】；因此用户名一旦创建，不可更改。 用户可以绑定邮箱、手机号。 用户的登录为登陆账号（用户名/邮箱/手机号）密码方式登录。 客户端（client） 提供服务的一方我们称为 服务端（Server），而接受服务的另一方我们称作客户端（Client）。 与访问管理相关的概念 当一个已认证的成员要发送一个请求时，IAM会对这个成员是否能在资源进行操作做出授权决定。这里将介绍授权过程中要涉及到的实体和概念。 权限 权限决定了在资源上允许的操作。 在Choerodon中，权限以..的形式显示。例如Choerodon-user-service.groups.query。 目前，权限1：1对应到API资源上，一条API资源就是一个权限。 角色 角色是权限的集合。你不能直接给成员分配权限，而是要授予角色。当你给成员授予一个角色时，也就是将角色里包含的所有权限授予了成员。 在IAM中，有两种角色： 预定义角色：预定义角色比原始角色的粒度细，可对更细粒度的访问进行控制。例如，源代码管理员（role/Choerodon-devops-service.sourceCodeAdmin）是对environment、git-flow、devops-service、service-release这些资源进行访问授权。 用户自定义角色：如果原始角色、预定义角色不能满足需求时，用户可根据自身需求创建自定义角色，给该角色添加特定的权限组合。 有关角色的更多信息请参考角色管理 角色分配 你可以授予用户角色通过在角色分配管理中添加用户与角色的关联关系，即定义谁有什么样的访问权限的一组关联。 IAM的核心就是角色分配，用member_role对象表示。一个IAMmember_role对象由关联列表组成。一个关联是将成员列表和角色关联在一起。 角色是你想分配给成员的角色。角色有唯一的标识-角色编码。角色编码的指定形式为role/。如，role/Choerodon-kanban-service.kanbanMember（看板项目成员），role/devops-deploy-service.deploymentAdmin（部署管理员）。 成员包含一个列表，这个列表可以是一个或多个身份，参考上面提到的与身份有关的概念部分。 角色分配分层 角色分配是按层次划分的。一共分3层：Site（全局）层、Org（组织)层、Project（项目）层。角色也有分层，一共分3层：Site（全局）层、Org（组织)层、Project（项目）层。 在特定层级的角色分配中，只能分配对应层级的角色。 在全局层的角色分配中，只能分配全局层角色，而全局层角色只包含全局层权限，只能访问全局层的资源； 在组织层的角色分配中，只能分配组织层角色，而组织层角色只包含组织层权限，只能访问组织层资源； 在项目层的角色分配中，只能分配项目层的角色，而项目层角色只包含项目层权限，只能访问项目层资源。 在全局层对成员授予全局层角色后，成员有访问全局层资源的权限，能对Choerodon系统进行设置，设置将在Choerodon系统中的所有组织、项目生效； 在组织层对成员授予组织层角色后，成员有访问组织层资源的权限，对一个组织的关联对象进行设置，设置将在这个组织与属于这个组织的项目生效； 在项目层对成员授予项目层角色后，成员有访问项目层资源的权限，对一个项目进行操作，操作将只在这个项目生效。 关键流程设计及实现 "},"/docs/user-guide/system-configuration/person/User2_secret_change":{"url":"docs/user-guide/system-configuration/person/User2_secret_change","title":"修改密码","body":"修改密码 非LDAP用户可以修改自己的登录密码。LDAP用户的密码从外部系统获取，所以无修改密码的功能。 层级： 个人中心 修改密码 可修改字段： 原密码：原密码须正确，否则无法修改密码。 新密码：如果密码策略的密码安全策略被启用，则新密码需符合密码安全策略。 确认密码：须与新密码输入一致。 "},"/docs/user-guide/system-configuration/person/User3_org_info":{"url":"docs/user-guide/system-configuration/person/User3_org_info","title":"组织信息","body":"组织信息 用户必须且只能属于一个组织。用户可以在其他组织被分配角色。组织信息展示给该用户分配过角色的组织和用户在该组织下的角色。 层级： 个人中心 组织信息列表 用户必须且只能属于一个组织，列表的第一行为用户所属组织。用户可以在组织中被分配角色，即使用户不属于该组织，折叠列表的一级分类为组织。每一行组织展开后为用户在该组织下的所有角色。 列表字段： 组织/角色：显示组织名称或角色名称。 编码：但为组织时，显示组织编码；当为角色时，显示角色编码。 类型：为组织或角色。 组织信息查询 可查询字段： 组织名称：可以根据组织名称查询组织。 组织编码：可以根据组织编码查询组织。 角色名称：可以根据角色名称查询用户所有组织层角色，即使为在不同组织的角色。 角色编码：可以根据角色编码查询用户所有组织层角色，即使为在不同组织的角色。 "},"/docs/user-guide/system-configuration/person/User4_pro_info":{"url":"docs/user-guide/system-configuration/person/User4_pro_info","title":"项目信息","body":"项目信息 用户可以在不同的项目中被分配角色。项目信息展示给该用户分配过角色的项目和用户在该项目下的角色。 层级： 个人中心 项目信息列表 用户可以在不同的项目中被分配角色。折叠列表的一级分类为项目。每一行项目展开后为用户在该项目下的所有角色。 列表字段： 项目/角色：显示项目名称或角色名称。 编码：但为项目时，显示项目编码；当为角色时，显示角色编码。 类型：为项目或角色。 项目信息查询 可查询字段： 项目名称：可以根据项目名称查询项目。 项目编码：可以根据项目编码查询项目。 角色名称：可以根据角色名称查询用户所有项目层角色，即使为在不同项目的角色。 角色编码：可以根据角色编码查询用户所有项目层角色，即使为在不同项目的角色。 "},"/docs/user-guide/system-configuration/person/User5_token":{"url":"docs/user-guide/system-configuration/person/User5_token","title":"授权管理","body":"授权 授权用于用户生成自己的token。 层级： 个人中心 创建授权 必填字段： 名称：具有唯一性 过期时间:token的失效时间。无法选择当前时间之前的时间。 其他操作 删除：可删除token数据 编辑：可修改token的过期时间，不可修改token名称 "},"/docs/user-guide/system-configuration/person/":{"url":"docs/user-guide/system-configuration/person/","title":"个人中心","description":"","body":"个人信息 用户信息维护用于让用户管理自己的信息，包括头像、用户名、邮箱、语言、时区，由于登录名是用户的标识，不可以修改登录名。 层级： 个人中心 修改个人信息 可修改字段： 用户名：用户的别称。 邮箱：填写真实正确的邮箱，可用于登录平台、密码找回。 语言：系统界面显示的语言。 时区：系统所有与时间有关的操作根据选择的时区进行转换。 "}}